 
!>>>>> ././src/M_intrinsics.f90
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
module M_intrinsics
implicit none
private
public help_intrinsics
!interface help_intrinsics
!   module procedure help_intrinsics_all
!   module procedure help_intrinsics_one
!end interface help_intrinsics
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics(name,prefix,topic,m_help) result (textblock)
character(len=*),intent(in)                       :: name
logical,intent(in),optional                       :: prefix
logical,intent(in),optional                       :: topic
logical,intent(in),optional                       :: m_help
character(len=256),allocatable                    :: textblock(:)
character(len=:),allocatable                      :: a, b, c
integer                                           :: i, p, pg
   select case(name)
   case('','manual','intrinsics','fortranmanual','fortran_manual')
      textblock=help_intrinsics_all(prefix,topic,m_help)
   case('fortran','toc')
      textblock=help_intrinsics_section()
      do i=1,size(textblock)
         p = index(textblock(i), '[')
         pg = index(textblock(i), ']')
         if(p.gt.0.and.pg.gt.p)then
          a=textblock(i)(:p-1)
          b=textblock(i)(p:pg)
          c=textblock(i)(pg+1:)
          textblock(i)=b//' '//a//c
         endif
      enddo
      call sort_name(textblock)
   case default
      textblock=help_intrinsics_one(name,prefix,topic,m_help)
   end select
end function help_intrinsics
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_section() result (textblock)

!@(#) grab lines in NAME section and append them to generate an index of manpages

character(len=256),allocatable  :: textblock(:)
character(len=256),allocatable  :: add(:)
character(len=256),allocatable  :: label
character(len=10)               :: cnum
integer                         :: i
integer                         :: icount
logical                         :: is_label
logical                         :: grab
   allocate(textblock(0))
   icount=1
   do
      write(cnum,'(i0)') icount
      add=help_intrinsics_one(cnum) ! get a document by number
      if( size(add) .eq. 0 ) exit
      label=''
      grab=.false.
      is_label=.false.
      ! look for NAME then append everything together till a line starting in column 1 that is all uppercase letters
      ! and assume that is the beginning of the next section to extract the NAME section as one line
      do i=1,size(add)
         if(add(i).eq.'')cycle
            is_label=verify(trim(add(i)),'ABCDEFGHIJKLMNOPQRSTUVWXYZ _') == 0
         if(is_label.and.add(i).eq.'NAME')then
            grab=.true.
         elseif(is_label)then
            exit
         elseif(grab)then
            label=adjustl(trim(label))//' '//adjustl(trim(add(i)))
         endif
      enddo
      textblock=[character(len=256) :: textblock,label]
      icount=icount + 1
   enddo
end function help_intrinsics_section
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_all(prefix,topic,m_help) result (textblock)
logical,intent(in),optional     :: prefix
logical,intent(in),optional     :: topic
logical,intent(in),optional     :: m_help
character(len=256),allocatable  :: textblock(:)
character(len=256),allocatable  :: header(:)
character(len=256),allocatable  :: add(:)
character(len=10)               :: cnum
integer                         :: icount
   allocate(textblock(0))
   icount=1
   do
      write(cnum,'(i0)') icount
      add=help_intrinsics_one(cnum,prefix,topic,m_help)
      if( size(add) .eq. 0 ) exit
      textblock=[character(len=256) :: textblock,add]
      icount=icount + 1
   enddo
   if(present(m_help))then
      if(m_help)then
         header=[ character(len=256) :: &
         '================================================================================',    &
         'SUMMARY',    &
         ' The primary Fortran topics are',    &
         ' abs                   achar                     acos',    &
         ' acosh                 adjustl                   adjustr',    &
         ' aimag                 aint                      all',    &
         ' allocated             anint                     any',    &
         ' asin                  asinh                     associated',    &
         ' atan                  atan2                     atanh',    &
         ' atomic_add            atomic_and                atomic_cas',    &
         ' atomic_define         atomic_fetch_add          atomic_fetch_and',    &
         ' atomic_fetch_or       atomic_fetch_xor          atomic_or',    &
         ' atomic_ref            atomic_xor                backspace',    &
         ' bessel_j0             bessel_j1                 bessel_jn',    &
         ' bessel_y0             bessel_y1                 bessel_yn',    &
         ' bge                   bgt                       bit_size',    &
         ' ble                   block                     blt',    &
         ' btest                 c_associated              ceiling',    &
         ' c_f_pointer           c_f_procpointer           c_funloc',    &
         ' char                  c_loc                     close',    &
         ' cmplx                 co_broadcast              co_lbound',    &
         ' co_max                co_min                    command_argument_count',    &
         ' compiler_options      compiler_version          conjg',    &
         ' continue              co_reduce                 cos',    &
         ' cosh                  co_sum                    co_ubound',    &
         ' count                 cpu_time                  cshift',    &
         ' c_sizeof              date_and_time             dble',    &
         ' digits                dim                       dot_product',    &
         ' dprod                 dshiftl                   dshiftr',    &
         ' eoshift               epsilon                   erf',    &
         ' erfc                  erfc_scaled               event_query',    &
         ' execute_command_line  exit                      exp',    &
         ' exponent              extends_type_of           findloc',    &
         ' float                 floor                     flush',    &
         ' fraction              gamma                     get_command',    &
         ' get_command_argument  get_environment_variable  huge',    &
         ' hypot                 iachar                    iall',    &
         ' iand                  iany                      ibclr',    &
         ' ibits                 ibset                     ichar',    &
         ' ieor                  image_index               include',    &
         ' index                 int                       ior',    &
         ' iparity               is_contiguous             ishft',    &
         ' ishftc                is_iostat_end             is_iostat_eor',    &
         ' kind                  lbound                    leadz',    &
         ' len                   len_trim                  lge',    &
         ' lgt                   lle                       llt',    &
         ' log                   log10                     log_gamma',    &
         ' logical               maskl                     maskr',    &
         ' matmul                max                       maxexponent',    &
         ' maxloc                maxval                    merge',    &
         ' merge_bits            min                       minexponent',    &
         ' minloc                minval                    mod',    &
         ' modulo                move_alloc                mvbits',    &
         ' nearest               new_line                  nint',    &
         ' norm2                 not                       null',    &
         ' num_images            pack                      parity',    &
         ' popcnt                poppar                    precision',    &
         ' present               product                   radix',    &
         ' random_number         random_seed               range',    &
         ' rank                  real                      repeat',    &
         ' reshape               return                    rewind',    &
         ' rrspacing             same_type_as              scale',    &
         ' scan                  selected_char_kind        selected_int_kind',    &
         ' selected_real_kind    set_exponent              shape',    &
         ' shifta                shiftl                    shiftr',    &
         ' sign                  sin                       sinh',    &
         ' size                  sngl                      spacing',    &
         ' spread                sqrt                      stop',    &
         ' storage_size          sum                       system_clock',    &
         ' tan                   tanh                      this_image',    &
         ' tiny                  trailz                    transfer',    &
         ' transpose             trim                      ubound',    &
         ' unpack                verify',    &
         '']
         textblock=[header,textblock]
      endif
   endif
end function help_intrinsics_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_one(name,prefix,topic,m_help) result (textblock)
character(len=*),intent(in)      :: name
logical,intent(in),optional      :: prefix
logical,intent(in),optional      :: m_help
logical,intent(in),optional      :: topic
character(len=256),allocatable   :: textblock(:)
character(len=:),allocatable     :: shortname
integer                          :: i
select case(name)

case('1','abs')

textblock=[character(len=256) :: &
'', &
'abs(3fortran)                                                    abs(3fortran)', &
'', &
'NAME', &
'  ABS(3) - [NUMERIC] Absolute value', &
'', &
'SYNTAX', &
'  result = abs(a)', &
'', &
'         TYPE(kind=KIND) elemental function abs(a)', &
'', &
'         TYPE(kind=KIND),intent(in) :: a', &
'', &
'  where the TYPE and KIND is determined by the type and type attributes of A,', &
'  which may be any real, integer, or complex value.', &
'', &
'  If the type of A is complex the type returned will be real with the same', &
'  kind as the real part of the input value.', &
'', &
'    Otherwise the returned type will be the same type as A.', &
'', &
'DESCRIPTION', &
'  ABS(A) computes the absolute value of numeric argument A.', &
'', &
'  In mathematics, the absolute value or modulus of a real number X, denoted', &
'  |X|, is the magnitude of X without regard to its sign.', &
'', &
'  The absolute value of a number may be thought of as its distance from zero,', &
'  which is the definition used by ABS(3) when dealing with complex values (see', &
'  below).', &
'', &
'ARGUMENTS', &
'  o  A : the type of the argument shall be an integer, real, or complex scalar', &
'     or array.', &
'', &
'RETURNS', &
'  If A is of type integer or real, the value of the result is |A| and of the', &
'  same type and kind as the input argument.', &
'', &
'  (Take particular note) if A is complex with value (X, Y), the result is a', &
'  real equal to a processor-dependent approximation to SQRT(X**2 + Y**2)', &
'  computed without undue overflow or underflow.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_abs', &
'      implicit none', &
'      integer           :: i = -1', &
'      real              :: x = -1.0', &
'      complex           :: z = (-3.0,-4.0)', &
'      doubleprecision   :: rr = -45.78d+00', &
'      character(len=*),parameter :: &', &
'       frmt =  ''(1x,a15,1x," In: ",g0,            T51," Out: ",g0)'', &', &
'       frmtc = ''(1x,a15,1x," In: (",g0,",",g0,")",T51," Out: ",g0)''', &
'      integer,parameter :: dp=kind(0.0d0)', &
'', &
'        ! any integer, real, or complex type', &
'          write(*, frmt)  ''integer         '',  i, abs(i)', &
'          write(*, frmt)  ''real            '',  x, abs(x)', &
'          write(*, frmt)  ''doubleprecision '', rr, abs(rr)', &
'          write(*, frmtc) ''complex         '',  z, abs(z)', &
'', &
'        ! any value whose positive value is representable', &
'        ! A dusty corner is that abs(-huge(0)-1) of an integer would input', &
'        ! a representable negative value on most machines but result in a', &
'        ! positive value out of range.', &
'          write(*, *) ''abs range test : '', abs(huge(0)), abs(-huge(0))', &
'          write(*, *) ''abs range test : '', abs(huge(0.0)), abs(-huge(0.0))', &
'          write(*, *) ''abs range test : '', abs(tiny(0.0)), abs(-tiny(0.0))', &
'', &
'        ! elemental', &
'          write(*, *) ''abs is elemental: '', abs([20,  0,  -1,  -3,  100])', &
'', &
'        ! complex input produces real output', &
'          write(*, *)  cmplx(30.0,40.0)', &
'', &
'        ! the returned value for complex input can be thought of as the', &
'        ! distance from the origin <0,0>', &
'          write(*, *) ''distance of <XX,YY> from zero is'', &', &
'                     & distance(30.0_dp,40.0_dp)', &
'', &
'          contains', &
'', &
'          real(kind=dp) elemental function distance(x,y)', &
'          real(kind=dp),intent(in) :: x,y', &
'             ! dusty corners:', &
'             ! note that KIND=DP is NOT optional', &
'             ! if the desired result is KIND=dp.', &
'             ! See cmplx(3).', &
'             distance=abs( cmplx(x,y,kind=dp) )', &
'          end function distance', &
'', &
'      end program demo_abs', &
'', &
'  Results:', &
'', &
'          integer          In: -1                     Out: 1', &
'          real             In: -1.000000              Out: 1.000000', &
'          doubleprecision  In: -45.78000000000000     Out: 45.78000000000000', &
'          complex          In: (-3.000000,-4.000000)  Out: 5.000000', &
'          abs range test :   2147483647  2147483647', &
'          abs range test :   3.4028235E+38  3.4028235E+38', &
'          abs range test :   1.1754944E-38  1.1754944E-38', &
'          abs is elemental: 20 0 1 3 100', &
'          (30.00000,40.00000)', &
'          distance of <XX,YY> from zero is   50.0000000000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 abs(3fortran)', &
'']

shortname="abs"
call process()


case('2','achar')

textblock=[character(len=256) :: &
'', &
'achar(3fortran)                                                achar(3fortran)', &
'', &
'NAME', &
'  ACHAR(3) - [CHARACTER:CONVERSION] returns a character in a specified', &
'  position in the ASCII collating sequence', &
'', &
'SYNTAX', &
'  result = achar(i,kind=KIND)', &
'', &
'          character(len=1) elemental function :: achar(i,kind=KIND)', &
'', &
'          integer(kind=KIND),intent(in) :: i', &
'          integer(kind=KIND),intent(in),optional :: kind', &
'', &
'  where KIND may be any supported kind value for integer types.', &
'', &
'DESCRIPTION', &
'  ACHAR(I) returns the character located at position I (commonly called the', &
'  ADE or ASCII Decimal Equivalent) in the ASCII collating sequence.', &
'', &
'  The ACHAR(3) function is often used for generating in-band escape sequences', &
'  to control terminal attributes.', &
'', &
'         write(*,''(*(a))'')achar(27),''[2J''', &
'', &
'  will clear the screen on an ANSI-compatible terminal display, for example.', &
'', &
'ARGUMENTS', &
'  o  I : the integer value to convert to an ASCII character, in the range 0 to', &
'     127.', &
'', &
'  o  KIND : (optional) an integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is the requested character of type character with a length', &
'  of one. If the KIND argument is present, the return value is of the', &
'  specified kind and of the default kind otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_achar', &
'      use,intrinsic::iso_fortran_env,only:int8,int16,int32,int64', &
'      implicit none', &
'      integer :: i', &
'         i=65', &
'         write(*,''("decimal     =",i0)'')i', &
'         write(*,''("character   =",a1)'')achar(i)', &
'         write(*,''("binary      =",b0)'')achar(i)', &
'         write(*,''("octal       =",o0)'')achar(i)', &
'         write(*,''("hexadecimal =",z0)'')achar(i)', &
'', &
'         write(*,''(8(i3,1x,a,1x),/)'')(i,achar(i), i=32,126)', &
'', &
'         write(*,''(a)'')upper(''Mixed Case'')', &
'      contains', &
'      ! a classic use of achar(3) is to convert the case of a string', &
'', &
'      elemental pure function upper(str) result (string)', &
'      !', &
'      !$@(#) upper(3f): function to return a trimmed uppercase-only string', &
'      !', &
'      ! input string to convert to all uppercase', &
'      character(*), intent(in)      :: str', &
'      ! output string that contains no miniscule letters', &
'      character(len(str))           :: string', &
'      integer                       :: i, iend', &
'      integer,parameter             :: toupper = iachar(''A'')-iachar(''a'')', &
'         iend=len_trim(str)', &
'         ! initialize output string to trimmed input string', &
'         string = str(:iend)', &
'         ! process each letter in the string', &
'         do concurrent (i = 1:iend)', &
'             select case (str(i:i))', &
'             ! located miniscule letter', &
'             case (''a'':''z'')', &
'                ! change miniscule to majuscule letter', &
'                string(i:i) = achar(iachar(str(i:i))+toupper)', &
'             end select', &
'         enddo', &
'      end function upper', &
'      end program demo_achar', &
'', &
'  Results:', &
'', &
'         decimal     =65', &
'         character   =A', &
'         binary      =1000001', &
'         octal       =101', &
'         hexadecimal =41', &
'          32    33 !  34 "  35 #  36 $  37 %  38 &  39 ''', &
'', &
'          40 (  41 )  42 *  43 +  44 ,  45 -  46 .  47 /', &
'', &
'          48 0  49 1  50 2  51 3  52 4  53 5  54 6  55 7', &
'', &
'          56 8  57 9  58 :  59 ;  60 <  61 =  62 >  63 ?', &
'', &
'          64 @  65 A  66 B  67 C  68 D  69 E  70 F  71 G', &
'', &
'          72 H  73 I  74 J  75 K  76 L  77 M  78 N  79 O', &
'', &
'          80 P  81 Q  82 R  83 S  84 T  85 U  86 V  87 W', &
'', &
'          88 X  89 Y  90 Z  91 [  92 \  93 ]  94 ^  95 _', &
'', &
'          96 `  97 a  98 b  99 c 100 d 101 e 102 f 103 g', &
'', &
'         104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o', &
'', &
'         112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w', &
'', &
'         120 x 121 y 122 z 123 { 124 | 125 } 126 ~', &
'', &
'   MIXED CASE', &
'NOTE', &
'  The ADEs (ASCII Decimal Equivalents) for ASCII are', &
'', &
'      *-------*-------*-------*-------*-------*-------*-------*-------*', &
'      | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|', &
'      | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si |', &
'      | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb|', &
'      | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us |', &
'      | 32 sp | 33  ! | 34  " | 35  # | 36  $ | 37  % | 38  & | 39  '' |', &
'      | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / |', &
'      | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 |', &
'      | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? |', &
'      | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G |', &
'      | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O |', &
'      | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W |', &
'      | 88  X | 89  Y | 90  Z | 91  [ | 92  \ | 93  ] | 94  ^ | 95  _ |', &
'      | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g |', &
'      |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o |', &
'      |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w |', &
'      |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del|', &
'      *-------*-------*-------*-------*-------*-------*-------*-------*', &
'', &
'STANDARD', &
'  FORTRAN 77 and later, with KIND argument Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  CHAR(3), IACHAR(3), ICHAR(3)', &
'', &
'RESOURCES', &
'  o  ANSI escape sequences', &
'', &
'  o  M_attr module for controlling ANSI-compatible terminals', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               achar(3fortran)', &
'']

shortname="achar"
call process()


case('3','acos')

textblock=[character(len=256) :: &
'', &
'acos(3fortran)                                                  acos(3fortran)', &
'', &
'NAME', &
'  ACOS(3) - [MATHEMATICS:TRIGONOMETRIC] arccosine (inverse cosine) function', &
'', &
'SYNTAX', &
'  result = acos(x)', &
'', &
'         TYPE(kind=KIND),elemental :: acos', &
'', &
'         TYPE(kind=KIND,intent(in) :: x', &
'', &
'  where TYPE may be real or complex and KIND may be any KIND supported by the', &
'  associated type.', &
'', &
'DESCRIPTION', &
'  ACOS(X) computes the arccosine of X (inverse of COS(X)).', &
'', &
'ARGUMENTS', &
'  o  X : Must be type real or complex. If the type is real, the value must', &
'     satisfy |X| <= 1.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as X. The real part of the', &
'  result is in radians and lies in the range 0 <= ACOS(X%RE) <= PI .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_acos', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds,real32,real64,real128', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64) :: x = 0.866_real64', &
'      real(kind=real64),parameter :: d2r=acos(-1.0_real64)/180.0_real64', &
'', &
'          print all,''acos('',x,'') is '', acos(x)', &
'          print all,''90 degrees is '', d2r*90.0_real64, '' radians''', &
'          print all,''180 degrees is '', d2r*180.0_real64, '' radians''', &
'          print all,''for reference &', &
'          &PI ~ 3.14159265358979323846264338327950288419716939937510''', &
'          print all,''elemental'',acos([-1.0,-0.5,0.0,0.50,1.0])', &
'', &
'      end program demo_acos', &
'', &
'  Results:', &
'', &
'         acos( .8660000000000000 ) is  .5236495809318289', &
'         90 degrees is  1.570796326794897  radians', &
'         180 degrees is  3.141592653589793  radians', &
'         for reference PI ~ 3.14159265358979323846264338327950288419716939937510', &
'         elemental 3.141593 2.094395 1.570796 1.047198 .000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later; for a complex argument - Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Inverse function: COS(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                acos(3fortran)', &
'']

shortname="acos"
call process()


case('4','acosh')

textblock=[character(len=256) :: &
'', &
'acosh(3fortran)                                                acosh(3fortran)', &
'', &
'NAME', &
'  ACOSH(3) - [MATHEMATICS:TRIGONOMETRIC] Inverse hyperbolic cosine function', &
'', &
'SYNTAX', &
'  result = acosh(x)', &
'', &
'         TYPE(kind=KIND),elemental :: acosh', &
'', &
'         TYPE(kind=KIND,intent(in) :: x', &
'', &
'  where TYPE may be real or complex and KIND may be any KIND supported by the', &
'  associated type.', &
'', &
'DESCRIPTION', &
'  ACOSH(X) computes the inverse hyperbolic cosine of X in radians.', &
'', &
'ARGUMENTS', &
'  o  X : the type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value has the same type and kind as X.', &
'', &
'  If X is complex, the imaginary part of the result is in radians and lies', &
'  between', &
'', &
'    0 <= AIMAG(ACOSH(X)) <= PI', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_acosh', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=dp), dimension(3) :: x = [ 1.0d0, 2.0d0, 3.0d0 ]', &
'         write (*,*) acosh(x)', &
'      end program demo_acosh', &
'', &
'  Results:', &
'', &
'       0.000000000000000E+000   1.31695789692482        1.76274717403909', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Inverse function: COSH(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               acosh(3fortran)', &
'']

shortname="acosh"
call process()


case('5','adjustl')

textblock=[character(len=256) :: &
'', &
'adjustl(3fortran)                                            adjustl(3fortran)', &
'', &
'NAME', &
'  ADJUSTL(3) - [CHARACTER:WHITESPACE] Left-adjust a string', &
'', &
'SYNTAX', &
'  result = adjustl(string)', &
'', &
'           character(len=(len(string)) elemental function adjustr(a)', &
'', &
'           character(len=*),intent(in) :: string', &
'', &
'DESCRIPTION', &
'  ADJUSTL(STRING) will left-adjust a string by removing leading spaces.', &
'  Spaces are inserted at the end of the string as needed.', &
'', &
'ARGUMENTS', &
'  o  STRING : the type shall be character.', &
'', &
'RETURNS', &
'  The return value is of type character and of the same kind as STRING where', &
'  leading spaces are removed and the same number of spaces are inserted on the', &
'  end of STRING.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_adjustl', &
'      implicit none', &
'      character(len=20) :: str = ''   sample string''', &
'      character(len=:),allocatable :: astr', &
'          !', &
'          ! basic use', &
'          str = adjustl(str)', &
'          write(*,''("[",a,"]")'') str, trim(str)', &
'          !', &
'          ! an allocatable string stays the same length', &
'          ! and is not trimmed.', &
'          astr=''    allocatable string   ''', &
'          write(*,''("[",a,"]")'') adjustl(astr)', &
'          !', &
'      end program demo_adjustl', &
'', &
'  Results:', &
'', &
'         [sample string       ]', &
'         [sample string]', &
'         [allocatable string       ]', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  ADJUSTR(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022             adjustl(3fortran)', &
'']

shortname="adjustl"
call process()


case('6','adjustr')

textblock=[character(len=256) :: &
'', &
'adjustr(3fortran)                                            adjustr(3fortran)', &
'', &
'NAME', &
'  ADJUSTR(3) - [CHARACTER:WHITESPACE] Right-adjust a string', &
'', &
'SYNTAX', &
'  result = adjustr(string)', &
'', &
'           elemental function adjustr(a)', &
'           character(len=(len(string)) :: adjustr', &
'           character(len=*),intent(in) :: string', &
'', &
'DESCRIPTION', &
'  ADJUSTR(STRING) right-adjusts a string by removing trailing spaces.  Spaces', &
'  are inserted at the start of the string as needed to retain the original', &
'  length.', &
'', &
'ARGUMENTS', &
'  o  STRING : the type shall be character.', &
'', &
'RETURNS', &
'  The return value is of type character and of the same kind as STRING where', &
'  trailing spaces are removed and the same number of spaces are inserted at', &
'  the start of STRING.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_adjustr', &
'      implicit none', &
'      character(len=20) :: str = '' sample string ''', &
'         ! print a short number line', &
'         write(*,''(a)'')repeat(''1234567890'',5)', &
'', &
'         !', &
'         ! basic usage', &
'         !', &
'         str = adjustr(str)', &
'         write(*,''(a)'') str', &
'', &
'         !', &
'         ! elemental', &
'         !', &
'         write(*,''(a)'')adjustr([character(len=50) :: &', &
'         ''  first           '', &', &
'         ''     second       '', &', &
'         ''         third    '' ])', &
'', &
'         write(*,''(a)'')repeat(''1234567890'',5)', &
'      end program demo_adjustr', &
'', &
'  Results:', &
'', &
'         12345678901234567890123456789012345678901234567890', &
'                sample string', &
'                                                      first', &
'                                                     second', &
'                                                      third', &
'         12345678901234567890123456789012345678901234567890', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  ADJUSTL(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022             adjustr(3fortran)', &
'']

shortname="adjustr"
call process()


case('7','aimag')

textblock=[character(len=256) :: &
'', &
'aimag(3fortran)                                                aimag(3fortran)', &
'', &
'NAME', &
'  AIMAG(3) - [TYPE:NUMERIC] Imaginary part of complex number', &
'', &
'SYNTAX', &
'  result = aimag(z)', &
'', &
'           complex(kind=KIND),elemental :: aimag', &
'', &
'           complex(kind=KIND),intent(in) :: z', &
'', &
'DESCRIPTION', &
'  AIMAG(Z) yields the imaginary part of complex argument Z.', &
'', &
'  This is similar to the modern complex-part-designator %IM which also', &
'  designates the imaginary part of a value, accept a designator can appear on', &
'  the left-hand side of an assignment as well, as in VAL%IM=10.0.', &
'', &
'ARGUMENTS', &
'  o  Z : The type of the argument shall be complex.', &
'', &
'RETURNS', &
'  The return value is of type real with the kind type parameter of the', &
'  argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_aimag', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'       & real32, real64, real128', &
'      implicit none', &
'      complex(kind=real32) z4', &
'      complex(kind=real64) z8', &
'          z4 = cmplx(1.e0, 2.e0)', &
'          z8 = cmplx(3.e0_real64, 4.e0_real64,kind=real64)', &
'          print *, aimag(z4), aimag(z8)', &
'          ! an elemental function can be passed an array', &
'          print *', &
'          print *, [z4,z4/2.0,z4+z4,z4**3]', &
'          print *', &
'          print *, aimag([z4,z4/2.0,z4+z4,z4**3])', &
'      end program demo_aimag', &
'', &
'  Results:', &
'', &
'        2.000000       4.00000000000000', &
'', &
'  (1.000000,2.000000) (0.5000000,1.000000) (2.000000,4.000000)', &
'  (-11.00000,-2.000000)', &
'', &
'             2.000000       1.000000       4.000000      -2.000000', &
'', &
'SEE ALSO', &
'  REAL(3), CMPLX(3)', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               aimag(3fortran)', &
'']

shortname="aimag"
call process()


case('8','aint')

textblock=[character(len=256) :: &
'', &
'aint(3fortran)                                                  aint(3fortran)', &
'', &
'NAME', &
'  AINT(3) - [NUMERIC] Truncate to a whole number', &
'', &
'SYNTAX', &
'  result = aint(x)', &
'', &
'         real(kind=kind(x)),elemental  :: aint', &
'', &
'         real(kind=kind(x)),intent(in) :: x', &
'', &
'  or', &
'', &
'      result = aint(x, KIND)', &
'', &
'         real(kind=KIND),elemental     :: aint', &
'', &
'         integer,intent(in),optional   :: KIND', &
'         real(kind=kind(x)),intent(in) :: x', &
'', &
'DESCRIPTION', &
'  AINT(X, KIND) truncates its argument to a whole number.', &
'', &
'ARGUMENTS', &
'  o  X : the type of the argument shall be real.', &
'', &
'  o  KIND : (optional) an integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type real with the kind type parameter of the', &
'  argument if the optional kind is absent; otherwise, the kind type parameter', &
'  will be given by kind. If the magnitude of X is less than one, AINT(X)', &
'  returns zero. If the magnitude is equal to or greater than one then it', &
'  returns the largest whole number that does not exceed its magnitude. The', &
'  sign is the same as the sign of X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_aint', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64', &
'      implicit none', &
'      real(kind=real32) :: x4', &
'      real(kind=real64) :: x8', &
'', &
'         x4 = 4.3210_real32', &
'         x8 = 4.3210_real64', &
'         print *, aint(x4), aint(x8)', &
'         print *', &
'         ! elemental', &
'         print *,aint([ &', &
'          &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'          &  0.0,   &', &
'          &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'', &
'      end program demo_aint', &
'', &
'  Results:', &
'', &
'           4.00000000       4.0000000000000000', &
'', &
'    -2.00000000', &
'      -2.00000000      -2.00000000      -2.00000000', &
'', &
'    -1.00000000', &
'      -1.00000000      -0.00000000       0.00000000', &
'', &
'      0.00000000', &
'        1.00000000       1.00000000       2.00000000', &
'', &
'      2.00000000', &
'        2.00000000       2.00000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  ANINT(3), INT(3), NINT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                aint(3fortran)', &
'']

shortname="aint"
call process()


case('9','all')

textblock=[character(len=256) :: &
'', &
'all(3fortran)                                                    all(3fortran)', &
'', &
'NAME', &
'  ALL(3) - [ARRAY REDUCTION] determines if all the values are true', &
'', &
'SYNTAX', &
'  result = all(mask, dim)', &
'', &
'DESCRIPTION', &
'  Logical conjunction of elements of MASK along dimension DIM.', &
'', &
'  "ALL(MASK, DIM)" determines if all the values are true in MASK in the array', &
'  along dimension DIM.', &
'', &
'ARGUMENTS', &
'  o  MASK : shall be a logical array.', &
'', &
'  o  DIM : (optional) DIM shall be a scalar integer with a value that lies', &
'     between one and the rank of MASK. The corresponding actual argument shall', &
'     not be an optional dummy argument.', &
'', &
'RETURNS', &
'  "ALL(MASK)" returns a scalar value of type logical where the kind type', &
'  parameter is the same as the kind type parameter of MASK. If DIM is present,', &
'  then ALL(MASK, DIM) returns an array with the rank of MASK minus 1. The', &
'  shape is determined from the shape of MASK where the DIM dimension is', &
'  elided.', &
'', &
'  1.  ALL(MASK) is true if all elements of MASK are true. It also is true if', &
'      MASK has zero size; otherwise, it is false.', &
'', &
'  2.  If the rank of MASK is one, then ALL(MASK, DIM) is equivalent to', &
'      ALL(MASK). If the rank is greater than one, then ALL(MASK, DIM) is', &
'      determined by applying ALL() to the array sections.', &
'', &
'  3.  Result Characteristics. The result is of type logical with the same kind', &
'      type parameter as MASK. It is scalar if DIM is absent or N = 1;', &
'      otherwise, the result has rank N - 1 and shape [D1, D2, . . ., DDIM-1,', &
'      DDIM+1, . . ., DN ] where [D1, D2, . . ., DN ] is the shape of MASK.', &
'', &
'  4.  Result Value.', &
'', &
'      Case (i): : The result of ALL(MASK) has the value true if all', &
'      elements of MASK are true or if MASK has size zero, and the result', &
'      has value false if any element of MASK is false.', &
'', &
'      Case (ii): : If MASK has rank one, ALL(MASK,DIM) is equal to', &
'      ALL(MASK). Otherwise, the value of element (S1, S2, . . ., SDIM-1,', &
'      SDIM+1, . . ., SN ) of all (MASK, DIM) is equal to ALL(MASK (S1, S2,', &
'      . . ., SDIM-1, :, SDIM+1, . . ., SN )).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_all', &
'      implicit none', &
'      logical bool', &
'        ! basic usage', &
'         ! is everything true?', &
'         bool = all([ .true., .true., .true. ])', &
'         bool = all([ .true., .false., .true. ])', &
'         print *, bool', &
'        ! by a dimension', &
'         ARRAYS: block', &
'         integer :: a(2,3), b(2,3)', &
'          ! set everything to one except one value in b', &
'          a = 1', &
'          b = 1', &
'          b(2,2) = 2', &
'          ! now compare those two arrays', &
'          print *,''entire array :'', all(a .eq. b )', &
'          print *,''compare columns:'', all(a .eq. b, dim=1)', &
'          print *,''compare rows:'', all(a .eq. b, dim=2)', &
'        end block ARRAYS', &
'      end program demo_all', &
'', &
'  Results:', &
'', &
'   T', &
'   F', &
'  entire array : F compare columns: T F T compare rows: T F', &
'', &
'SEE ALSO', &
'  ANY(3)', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 all(3fortran)', &
'']

shortname="all"
call process()


case('10','allocated')

textblock=[character(len=256) :: &
'', &
'allocated(3fortran)                                        allocated(3fortran)', &
'', &
'NAME', &
'  ALLOCATED(3) - [ARRAY INQUIRY] Status of an allocatable entity', &
'', &
'SYNTAX', &
'  result = allocated(array)', &
'', &
'  or', &
'', &
'        result = allocated(scalar)', &
'', &
'DESCRIPTION', &
'  ALLOCATED(ARRAY) and ALLOCATED(SCALAR) check the allocation status of ARRAY', &
'  and SCALAR, respectively.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : the argument shall be an allocatable array or allocatable scalar.', &
'', &
'  o  SCALAR : the argument shall be an allocatable scalar.', &
'', &
'RETURNS', &
'  The return value is a scalar logical with the default logical kind type', &
'  parameter. If the argument is allocated then the result is .true.;', &
'  otherwise, it returns .false..', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_allocated', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      integer :: i = 4', &
'      real(kind=sp), allocatable :: x(:)', &
'      character(len=256) :: message', &
'      integer :: istat', &
'', &
'         ! if already allocated, deallocate', &
'         if ( allocated(x) ) deallocate(x,STAT=istat, ERRMSG=message )', &
'         if(istat.ne.0)then', &
'            write(*,*)trim(message)', &
'            stop', &
'         endif', &
'', &
'         ! only if not allocated, allocate', &
'         if ( .not. allocated(x) ) allocate(x(i))', &
'', &
'         write(*,*)allocated(x), size(x)', &
'         if( allocated(x)) then', &
'             write(*,*)''do things if allocated''', &
'         else', &
'             write(*,*)''do things if not allocated''', &
'         endif', &
'', &
'         call intentout(x)', &
'         write(*,*)''note it is deallocated!'',allocated(x)', &
'', &
'         contains', &
'', &
'         subroutine intentout(arr)', &
'         ! note that if arr has intent(out) and is allocatable,', &
'         ! arr is deallocated on entry', &
'         real(kind=sp),intent(out),allocatable :: arr(:)', &
'             write(*,*)''note it was allocated in calling program'',allocated(arr)', &
'         end subroutine intentout', &
'', &
'      end program demo_allocated', &
'', &
'  Results:', &
'', &
'          T           4', &
'          do things if allocated', &
'          note it was allocated in calling program F', &
'          note it is deallocated! F', &
'', &
'STANDARD', &
'  Fortran 95 and later. Note, the scalar= keyword and allocatable scalar', &
'  entities are available in Fortran 2003 and later.', &
'', &
'SEE ALSO', &
'  MOVE_ALLOC(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           allocated(3fortran)', &
'']

shortname="allocated"
call process()


case('11','anint')

textblock=[character(len=256) :: &
'', &
'anint(3fortran)                                                anint(3fortran)', &
'', &
'NAME', &
'  ANINT(3) - [NUMERIC] Nearest whole number', &
'', &
'SYNTAX', &
'  result = anint(a, kind)', &
'', &
'DESCRIPTION', &
'  ANINT(A [, KIND]) rounds its argument to the nearest whole number.', &
'', &
'ARGUMENTS', &
'  o  A : the type of the argument shall be real.', &
'', &
'  o  KIND : (optional) an integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type real with the kind type parameter of the', &
'  argument if the optional KIND is absent; otherwise, the kind type parameter', &
'  will be given by KIND. If A is greater than zero, ANINT(A) returns AINT(A +', &
'  0.5). If A is less than or equal to zero then it returns AINT(A - 0.5).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_anint', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'      implicit none', &
'      real(kind=real32) :: x4', &
'      real(kind=real64) :: x8', &
'', &
'         x4 = 1.234E0_real32', &
'         x8 = 4.321_real64', &
'         print *, anint(x4), dnint(x8)', &
'         x8 = anint(x4,kind=real64)', &
'         print *, x8', &
'         print *', &
'         ! elemental', &
'         print *,anint([ &', &
'          & -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'          &  0.0, &', &
'          & +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'', &
'      end program demo_anint', &
'', &
'  Results:', &
'', &
'          1.00000000       4.0000000000000000', &
'          1.0000000000000000', &
'', &
'    -3.00000000', &
'      -3.00000000      -2.00000000      -2.00000000', &
'', &
'    -2.00000000', &
'      -1.00000000      -1.00000000       0.00000000', &
'', &
'      1.00000000', &
'        1.00000000       2.00000000       2.00000000', &
'', &
'      2.00000000', &
'        3.00000000       3.00000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  AINT(3), INT(3), NINT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               anint(3fortran)', &
'']

shortname="anint"
call process()


case('12','any')

textblock=[character(len=256) :: &
'', &
'any(3fortran)                                                    any(3fortran)', &
'', &
'NAME', &
'  ANY(3) - [ARRAY REDUCTION] determines if any of the values in the logical', &
'  array are true.', &
'', &
'SYNTAX', &
'  result = any(mask, dim)', &
'', &
'DESCRIPTION', &
'  ANY(MASK, DIM) determines if any of the values in the logical array MASK', &
'  along dimension DIM are .true..', &
'', &
'ARGUMENTS', &
'  o  MASK : the type of the argument shall be logical and it shall not be', &
'     scalar.', &
'', &
'  o  DIM : (optional) dim shall be a scalar integer with a value that lies', &
'     between one and the rank of mask.', &
'', &
'RETURNS', &
'  ANY(MASK) returns a scalar value of type logical where the kind type', &
'  parameter is the same as the kind type parameter of MASK. If DIM is present,', &
'  then ANY(MASK, DIM) returns an array with the rank of MASK minus 1. The', &
'  shape is determined from the shape of MASK where the DIM dimension is', &
'  elided.', &
'', &
'  1.  ANY(MASK) is true if any element of MASK is true; otherwise, it is', &
'', &
'  2.  If the rank of MASK is one, then ANY(MASK, DIM) is equivalent to', &
'      ANY(MASK). If the rank is greater than one, then ANY(MASK, DIM) is', &
'      determined by applying ANY() to the array sections.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_any', &
'      implicit none', &
'      logical l', &
'         l = any([.true., .true., .true.])', &
'         print *, l', &
'         call section', &
'         contains', &
'           subroutine section', &
'           integer a(2,3), b(2,3)', &
'             a = 1', &
'             b = 1', &
'             b(2,2) = 2', &
'             print *, any(a .eq. b, 1)', &
'             print *, any(a .eq. b, 2)', &
'           end subroutine section', &
'      end program demo_any', &
'', &
'  Results:', &
'', &
'   T', &
'   T T T', &
'   T T', &
'SEE ALSO', &
'  ANY(3)', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 any(3fortran)', &
'']

shortname="any"
call process()


case('13','asin')

textblock=[character(len=256) :: &
'', &
'asin(3fortran)                                                  asin(3fortran)', &
'', &
'NAME', &
'  ASIN(3) - [MATHEMATICS:TRIGONOMETRIC] Arcsine function', &
'', &
'SYNTAX', &
'  result = asin(x)', &
'', &
'          elemental TYPE(kind=KIND) function asin(x)', &
'          TYPE(kind=KIND) :: x', &
'', &
'  where the returned value has the kind of the input value and TYPE may be', &
'  real or complex', &
'', &
'DESCRIPTION', &
'  ASIN(X) computes the arcsine of its argument X.', &
'', &
'  The arcsine is the inverse function of the sine function. It is commonly', &
'  used in trigonometry when trying to find the angle when the lengths of the', &
'  hypotenuse and the opposite side of a right triangle are known.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be either real and a magnitude that is less than or', &
'     equal to one; or be complex.', &
'', &
'RETURNS', &
'  o  RESULT : The return value is of the same type and kind as X. The real', &
'     part of the result is in radians and lies in the range -PI/2 <= ASIN(X)', &
'     <= PI/2.', &
'', &
'EXAMPLES', &
'  The arcsine will allow you to find the measure of a right angle when you', &
'  know the ratio of the side opposite the angle to the hypotenuse.', &
'', &
'  So if you knew that a train track rose 1.25 vertical miles on a track that', &
'  was 50 miles long, you could determine the average angle of incline of the', &
'  track using the arcsine. Given', &
'', &
'       sin(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'', &
'  Sample program:', &
'', &
'      program demo_asin', &
'      use, intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      ! value to convert degrees to radians', &
'      real(kind=dp),parameter :: D2R=acos(-1.0_dp)/180.0_dp', &
'      real(kind=dp)           :: angle, rise, run', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'        ! given sine(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'        ! then taking the arcsine of both sides of the equality yields', &
'        ! theta = arcsine(1.25 miles/50 miles) ie. arcsine(opposite/hypotenuse)', &
'        rise=1.250_dp', &
'        run=50.00_dp', &
'        angle = asin(rise/run)', &
'        print all, ''angle of incline(radians) = '', angle', &
'        angle = angle/D2R', &
'        print all, ''angle of incline(degrees) = '', angle', &
'', &
'        print all, ''percent grade='',rise/run*100.0_dp', &
'      end program demo_asin', &
'', &
'  Results:', &
'', &
'          angle of incline(radians) =    2.5002604899361139E-002', &
'          angle of incline(degrees) =    1.4325437375665075', &
'          percent grade=   2.5000000000000000', &
'', &
'  The percentage grade is the slope, written as a percent. To calculate the', &
'  slope you divide the rise by the run. In the example the rise is 1.25 mile', &
'  over a run of 50 miles so the slope is 1.25/50 = 0.025.  Written as a', &
'  percent this is 2.5 %.', &
'', &
'  For the US, two and 1/2 percent is generally thought of as the upper limit.', &
'  This means a rise of 2.5 feet when going 100 feet forward. In the US this', &
'  was the maximum grade on the first major US railroad, the Baltimore and', &
'  Ohio. Note curves increase the frictional drag on a train reducing the', &
'  allowable grade.', &
'', &
'STANDARD', &
'  FORTRAN 77 and later, for a complex argument Fortran 2008 or later', &
'', &
'SEE ALSO', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Inverse function: SIN(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                asin(3fortran)', &
'']

shortname="asin"
call process()


case('14','asinh')

textblock=[character(len=256) :: &
'', &
'asinh(3fortran)                                                asinh(3fortran)', &
'', &
'NAME', &
'  ASINH(3) - [MATHEMATICS:TRIGONOMETRIC] Inverse hyperbolic sine function', &
'', &
'SYNTAX', &
'  result = asinh(x)', &
'', &
'          elemental TYPE(kind=KIND) function asinh(x)', &
'          TYPE(kind=KIND) :: x', &
'', &
'  Where the returned value has the kind of the input value and TYPE may be', &
'  real or complex', &
'', &
'DESCRIPTION', &
'  ASINH(X) computes the inverse hyperbolic sine of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as X. If X is complex, the', &
'  imaginary part of the result is in radians and lies between -PI/2 <=', &
'  AIMAG(ASINH(X)) <= PI/2.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_asinh', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=dp), dimension(3) :: x = [ -1.0d0, 0.0d0, 1.0d0 ]', &
'', &
'          write (*,*) asinh(x)', &
'', &
'      end program demo_asinh', &
'', &
'  Results:', &
'', &
'        -0.88137358701954305  0.0000000000000000  0.88137358701954305', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Inverse function: SINH(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               asinh(3fortran)', &
'']

shortname="asinh"
call process()


case('15','associated')

textblock=[character(len=256) :: &
'', &
'associated(3fortran)                                      associated(3fortran)', &
'', &
'NAME', &
'  ASSOCIATED(3) - [STATE] Status of a pointer or pointer/target pair', &
'', &
'SYNTAX', &
'  result = associated(pointer, target)', &
'', &
'DESCRIPTION', &
'  ASSOCIATED(POINTER [, TARGET]) determines the status of the pointer POINTER', &
'  or if POINTER is associated with the target TARGET.', &
'', &
'ARGUMENTS', &
'  o  POINTER : POINTER shall have the pointer attribute and it can be of any', &
'     type.', &
'', &
'  o  TARGET : (Optional) TARGET shall be a pointer or a target. It must have', &
'     the same type, kind type parameter, and array rank as POINTER.', &
'', &
'  The association status of neither POINTER nor TARGET shall be undefined.', &
'', &
'RETURNS', &
'  ASSOCIATED(POINTER) returns a scalar value of type logical. There are', &
'  several cases:', &
'', &
'  1.  When the optional TARGET is not present then ASSOCIATED(POINTER) is true', &
'      if POINTER is associated with a target; otherwise, it returns false.', &
'', &
'  2.  If TARGET is present and a scalar target, the result is true if TARGET', &
'      is not a zero-sized storage sequence and the target associated with', &
'      POINTER occupies the same storage units. If POINTER is disassociated,', &
'      the result is false.', &
'', &
'  3.  If TARGET is present and an array target, the result is true if TARGET', &
'      and POINTER have the same shape, are not zero-sized arrays, are arrays', &
'      whose elements are not zero-sized storage sequences, and TARGET and', &
'      POINTER occupy the same storage units in array element order.', &
'', &
'      As in case 2, the result is false, if POINTER is disassociated.', &
'', &
'  4.  If TARGET is present and an scalar pointer, the result is true if TARGET', &
'      is associated with POINTER, the target associated with TARGET are not', &
'      zero-sized storage sequences and occupy the same storage units.', &
'', &
'      The result is .false., if either TARGET or POINTER is disassociated.', &
'', &
'  5.  If TARGET is present and an array pointer, the result is true if target', &
'      associated with POINTER and the target associated with TARGET have the', &
'      same shape, are not zero-sized arrays, are arrays whose elements are not', &
'      zero-sized storage sequences, and TARGET and POINTER occupy the same', &
'      storage units in array element order. The result is false, if either', &
'      TARGET or POINTER is disassociated.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_associated', &
'      implicit none', &
'      real, target  :: tgt(2) = [1., 2.]', &
'      real, pointer :: ptr(:)', &
'         ptr => tgt', &
'         if (associated(ptr)     .eqv. .false.) &', &
'         & stop ''POINTER NOT ASSOCIATED''', &
'         if (associated(ptr,tgt) .eqv. .false.) &', &
'         & stop ''POINTER NOT ASSOCIATED TO TARGET''', &
'      end program demo_associated', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  NULL(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          associated(3fortran)', &
'']

shortname="associated"
call process()


case('16','atan2')

textblock=[character(len=256) :: &
'', &
'atan2(3fortran)                                                atan2(3fortran)', &
'', &
'NAME', &
'  ATAN2(3) - [MATHEMATICS:TRIGONOMETRIC] Arctangent (inverse tangent) function', &
'', &
'SYNTAX', &
'  elemental function atan2(y, x)', &
'', &
'          type(real,kind=KIND) :: atan2', &
'          type(real,kind=KIND),intent(in) :: y, x', &
'', &
'  The return value has the same type and kind as Y and X.', &
'', &
'DESCRIPTION', &
'  ATAN2(Y, X) computes in radians a processor-dependent approximation of the', &
'  arctangent of the complex number ( X, Y ) or equivalently the principal', &
'  value of the arctangent of the value Y/X (which determines a unique angle).', &
'', &
'ARGUMENTS', &
'  o  Y : The imaginary component of the complex value (X,Y) or the Y component', &
'     of the point <X,Y>.', &
'', &
'  o  X : The real component of the complex value (X,Y) or the X component of', &
'     the point <X,Y>.', &
'', &
'     If must be of the same kind as Y.', &
'', &
'RETURNS', &
'  The type and kind of the result are the same as the elements of X. and Y.', &
'', &
'  The value returned is by definition the principal value of the complex', &
'  number (X, Y).', &
'', &
'  The principal value is simply what we get when we adjust a radian value to', &
'  lie between -PI and PI inclusive,', &
'', &
'  The classic definition of the arctangent is the angle that is formed in', &
'  Cartesian coordinates of the line from the origin point <0,0> to the point', &
'  <X,Y> .', &
'', &
'  Pictured as a vector it is easy to see that if X and Y are both zero the', &
'  angle is indeterminate because it sits directly over the origin, so', &
'  ATAN(0.0,0.0) will produce an error.', &
'', &
'  Range of returned values by quadrant:', &
'', &
'      >                   +PI/2', &
'      >                     |', &
'      >                     |', &
'      >     PI/2 < z < PI   |   0 > z < PI/2', &
'      >                     |', &
'      >   +-PI -------------+---------------- +-0', &
'      >                     |', &
'      >     PI/2 < -z < PI  |   0 < -z < PI/2', &
'      >                     |', &
'      >                     |', &
'      >                   -PI/2', &
'      >', &
'           NOTES:', &
'', &
'           If the processor distinguishes -0 and +0 then the sign of the', &
'           returned value is that of Y when Y is zero, else when Y is zero', &
'           the returned value is always positive.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atan2', &
'      real :: z', &
'      complex :: c', &
'', &
'       ! basic usage', &
'        ! ATAN2 (1.5574077, 1.0) has the value 1.0 (approximately).', &
'        z=atan2(1.5574077, 1.0)', &
'        write(*,*) ''radians='',z,''degrees='',r2d(z)', &
'', &
'       ! elemental arrays', &
'        write(*,*)''elemental'',atan2( [10.0, 20.0], [30.0,40.0] )', &
'', &
'       ! elemental arrays and scalars', &
'        write(*,*)''elemental'',atan2( [10.0, 20.0], 50.0 )', &
'', &
'       ! break complex values into real and imaginary components', &
'       ! (note TAN2() can take a complex type value )', &
'        c=(0.0,1.0)', &
'        write(*,*)''complex'',c,atan2( x=c%re, y=c%im )', &
'', &
'       ! extended sample converting cartesian coordinates to polar', &
'        COMPLEX_VALS: block', &
'        real                :: ang, radius', &
'        complex,allocatable :: vals(:)', &
'', &
'        vals=[ &', &
'          ( 1.0, 0.0 ), & ! 0', &
'          ( 1.0, 1.0 ), & ! 45', &
'          ( 0.0, 1.0 ), & ! 90', &
'          (-1.0, 1.0 ), & ! 135', &
'          (-1.0, 0.0 ), & ! 180', &
'          (-1.0,-1.0 ), & ! 225', &
'          ( 0.0,-1.0 )]   ! 270', &
'        do i=1,size(vals)', &
'           call cartesian_to_polar(vals(i)%re, vals(i)%im, radius,ang)', &
'           write(*,101)vals(i),ang,r2d(ang),radius', &
'        enddo', &
'        101 format(             &', &
'        & ''X= '',f5.2,           &', &
'        & '' Y= '',f5.2,          &', &
'        & '' ANGLE= '',g0,        &', &
'        & T38,''DEGREES= '',g0.4, &', &
'        & T54,''DISTANCE='',g0)', &
'       endblock COMPLEX_VALS', &
'', &
'      contains', &
'', &
'      elemental real function r2d(radians)', &
'      ! input radians to convert to degrees', &
'      doubleprecision,parameter :: DEGREE=0.017453292519943d0 ! radians', &
'      real,intent(in)           :: radians', &
'         r2d=radians / DEGREE ! do the conversion', &
'      end function r2d', &
'', &
'      subroutine cartesian_to_polar(x,y,radius,inclination)', &
'      ! return angle in radians in range 0 to 2*PI', &
'      implicit none', &
'      real,intent(in)  :: x,y', &
'      real,intent(out) :: radius,inclination', &
'         radius=sqrt(x**2+y**2)', &
'         if(radius.eq.0)then', &
'            inclination=0.0', &
'         else', &
'            inclination=atan2(y,x)', &
'            if(inclination < 0.0)inclination=inclination+2*atan2(0.0d0,-1.0d0)', &
'         endif', &
'      end subroutine cartesian_to_polar', &
'', &
'      end program demo_atan2', &
'', &
'  Results:', &
'', &
'          radians=   1.000000     degrees=   57.29578', &
'          elemental  0.3217506      0.4636476', &
'          elemental  0.1973956      0.3805064', &
'          complex (0.0000000E+00,1.000000)   1.570796', &
'', &
'    X=', &
'      1.00 Y=  0.00 ANGLE= .000000     DEGREES= .000   DISTANCE=1.000000', &
'', &
'    X=', &
'      1.00 Y=  1.00 ANGLE= .7853982    DEGREES= 45.00  DISTANCE=1.414214', &
'', &
'    X=', &
'      0.00 Y=  1.00 ANGLE= 1.570796    DEGREES= 90.00  DISTANCE=1.000000', &
'', &
'    X= -1.00 Y=', &
'      1.00 ANGLE= 2.356194    DEGREES= 135.0  DISTANCE=1.414214', &
'', &
'    X= -1.00 Y=', &
'      0.00 ANGLE= 3.141593    DEGREES= 180.0  DISTANCE=1.000000', &
'', &
'    X= -1.00 Y= -1.00 ANGLE= 3.926991', &
'      DEGREES= 225.0  DISTANCE=1.414214', &
'', &
'    X=', &
'      0.00 Y= -1.00 ANGLE= 4.712389    DEGREES= 270.0  DISTANCE=1.000000', &
'', &
'SEE ALSO', &
'  o  ATAN(3)', &
'', &
'  o  arctan:wikipedia', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               atan2(3fortran)', &
'']

shortname="atan2"
call process()


case('17','atan')

textblock=[character(len=256) :: &
'', &
'atan(3fortran)                                                  atan(3fortran)', &
'', &
'NAME', &
'  ATAN(3) - [MATHEMATICS:TRIGONOMETRIC] Arctangent function', &
'', &
'SYNTAX', &
'  result = atan(y, x)', &
'', &
'          TYPE(kind=KIND):: atan', &
'          TYPE(kind=KIND,intent(in) :: x', &
'          TYPE(kind=KIND,intent(in),optional :: y', &
'', &
'  where TYPE may be real or complex and KIND may be any KIND supported by the', &
'  associated type. If Y is present X is _real`.', &
'', &
'DESCRIPTION', &
'  ATAN(X) computes the arctangent of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex; if Y is present, X shall be real.', &
'', &
'  o  Y : Shall be of the same type and kind as X. If X is zero, Y must not be', &
'     zero.', &
'', &
'RETURNS', &
'  The returned value is of the same type and kind as X. If Y is present, the', &
'  result is identical to ATAN2(Y,X). Otherwise, it is the arc tangent of X,', &
'  where the real part of the result is in radians and lies in the range -PI/2', &
'  <= ATAN(X) <= PI/2', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atan', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'       & real32, real64, real128', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64),parameter :: &', &
'       Deg_Per_Rad = 57.2957795130823208767981548_real64', &
'      real(kind=real64) :: x', &
'          x=2.866_real64', &
'          print all, atan(x)', &
'', &
'          print all, atan( 2.0d0, 2.0d0),atan( 2.0d0, 2.0d0)*Deg_Per_Rad', &
'          print all, atan( 2.0d0,-2.0d0),atan( 2.0d0,-2.0d0)*Deg_Per_Rad', &
'          print all, atan(-2.0d0, 2.0d0),atan(-2.0d0, 2.0d0)*Deg_Per_Rad', &
'          print all, atan(-2.0d0,-2.0d0),atan(-2.0d0,-2.0d0)*Deg_Per_Rad', &
'', &
'      end program demo_atan', &
'', &
'  Results:', &
'', &
'         1.235085437457879', &
'         .7853981633974483 45.00000000000000', &
'         2.356194490192345 135.0000000000000', &
'         -.7853981633974483 -45.00000000000000', &
'         -2.356194490192345 -135.0000000000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later for a complex argument; and for two arguments Fortran', &
'  2008 or later', &
'', &
'SEE ALSO', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  ATAN2(3), TAN(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                atan(3fortran)', &
'']

shortname="atan"
call process()


case('18','atanh')

textblock=[character(len=256) :: &
'', &
'atanh(3fortran)                                                atanh(3fortran)', &
'', &
'NAME', &
'  ATANH(3) - [MATHEMATICS:TRIGONOMETRIC] Inverse hyperbolic tangent function', &
'', &
'SYNTAX', &
'  result = atanh(x)', &
'', &
'DESCRIPTION', &
'  ATANH(X) computes the inverse hyperbolic tangent of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value has same type and kind as X. If X is complex, the imaginary', &
'  part of the result is in radians and lies between', &
'', &
'  -PI/2 <= AIMAG(ATANH(X)) <= PI/2', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atanh', &
'      implicit none', &
'      real, dimension(3) :: x = [ -1.0, 0.0, 1.0 ]', &
'', &
'         write (*,*) atanh(x)', &
'', &
'      end program demo_atanh', &
'', &
'  Results:', &
'', &
'         -Infinity   0.00000000             Infinity', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Inverse function: TANH(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               atanh(3fortran)', &
'']

shortname="atanh"
call process()


case('19','atomic_add')

textblock=[character(len=256) :: &
'', &
'atomic_add(3fortran)                                      atomic_add(3fortran)', &
'', &
'NAME', &
'  ATOMIC_ADD(3) - [ATOMIC] Atomic ADD operation', &
'', &
'SYNTAX', &
'  call atomic_add (atom, value, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_AD(ATOM, VALUE) atomically adds the value of VAR to the variable', &
'  ATOM. When STAT is present and the invocation was successful, it is assigned', &
'  the value 0. If it is present and the invocation has failed, it is assigned', &
'  a positive value; in particular, for a coindexed ATOM, if the remote image', &
'  has stopped, it is assigned the value of iso_fortran_env''s', &
'  stat_stopped_image and if the remote image has failed, the value', &
'  stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_add', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'         call atomic_add (atom[1], this_image())', &
'      end program demo_atomic_add', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_FETCH_ADD(3), ATOMIC_AND(3), ATOMIC_OR(3),', &
'  ATOMIC_XOR(3) ISO_FORTRAN_ENV(3),', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          atomic_add(3fortran)', &
'']

shortname="atomic_add"
call process()


case('20','atomic_and')

textblock=[character(len=256) :: &
'', &
'atomic_and(3fortran)                                      atomic_and(3fortran)', &
'', &
'NAME', &
'  ATOMIC_AND(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation', &
'', &
'SYNTAX', &
'  call atomic_and(atom, value, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_AND(ATOM, VALUE) atomically defines ATOM with the bitwise AND between', &
'  the values of ATOM and VALUE. When STAT is present and the invocation was', &
'  successful, it is assigned the value 0. If it is present and the invocation', &
'  has failed, it is assigned a positive value; in particular, for a coindexed', &
'  ATOM, if the remote image has stopped, it is assigned the value of', &
'  iso_fortran_env''s stat_stopped_image and if the remote image has failed, the', &
'  value stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_and', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'         call atomic_and(atom[1], int(b''10100011101''))', &
'      end program demo_atomic_and', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_FETCH_AND(3), ATOMIC_DEFINE(3), ATOMIC_REF(3), ATOMIC_CAS(3),', &
'  ISO_FORTRAN_ENV(3), ATOMIC_ADD(3), ATOMIC_OR(3), ATOMIC_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          atomic_and(3fortran)', &
'']

shortname="atomic_and"
call process()


case('21','atomic_cas')

textblock=[character(len=256) :: &
'', &
'atomic_cas(3fortran)                                      atomic_cas(3fortran)', &
'', &
'NAME', &
'  ATOMIC_CAS(3) - [ATOMIC] Atomic compare and swap', &
'', &
'SYNTAX', &
'  call atomic_cas (atom, old, compare, new, stat)', &
'', &
'DESCRIPTION', &
'  atomic_cas compares the variable ATOM with the value of COMPARE; if the', &
'  value is the same, ATOM is set to the value of NEW. Additionally, OLD is set', &
'  to the value of ATOM that was used for the comparison. When STAT is present', &
'  and the invocation was successful, it is assigned the value 0.  If it is', &
'  present and the invocation has failed, it is assigned a positive value; in', &
'  particular, for a coindexed ATOM, if the remote image has stopped, it is', &
'  assigned the value of iso_fortran_env''s stat_stopped_image and if the remote', &
'  image has failed, the value stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of either integer type with', &
'     atomic_int_kind kind or logical type with atomic_logical_kind kind.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  COMPARE : Scalar variable of the same type and kind as ATOM.', &
'', &
'  o  NEW : Scalar variable of the same type as ATOM. If kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_cas', &
'      use iso_fortran_env', &
'      implicit none', &
'      logical(atomic_logical_kind) :: atom[*], prev', &
'         call atomic_cas(atom[1], prev, .false., .true.)', &
'      end program demo_atomic_cas', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_REF(3), ISO_FORTRAN_ENV(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          atomic_cas(3fortran)', &
'']

shortname="atomic_cas"
call process()


case('22','atomic_define')

textblock=[character(len=256) :: &
'', &
'atomic_define(3fortran)                                atomic_define(3fortran)', &
'', &
'NAME', &
'  ATOMIC_DEFINE(3) - [ATOMIC] Setting a variable atomically', &
'', &
'SYNTAX', &
'  call atomic_define (atom, value, stat)', &
'', &
'         subroutine atomic_define(atom, value, stat)', &
'         TYPE(kind=KIND) :: atom', &
'         TYPE(kind=KIND) :: value', &
'         integer,intent(out),optional :: stat', &
'', &
'DESCRIPTION', &
'  ATOMIC_DEFINE(ATOM, VALUE) defines the variable ATOM with the value VALUE', &
'  atomically. When STAT is present and the invocation was successful, it is', &
'  assigned the value 0. If it is present and the invocation has failed, it is', &
'  assigned a positive value; in particular, for a coindexed ATOM, if the', &
'  remote image has stopped, it is assigned the value of iso_fortran_env''s', &
'  stat_stopped_image and if the remote image has failed, the value', &
'  stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of either integer type with', &
'     atomic_int_kind kind or logical type with atomic_logical_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_define', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'          call atomic_define(atom[1], this_image())', &
'      end program demo_atomic_define', &
'', &
'STANDARD', &
'  Fortran 2008 and later; with STAT, TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_REF(3), ATOMIC_CAS(3), ISO_FORTRAN_ENV(3), ATOMIC_ADD(3),', &
'  ATOMIC_AND(3), ATOMIC_OR(3), ATOMIC_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022       atomic_define(3fortran)', &
'']

shortname="atomic_define"
call process()


case('23','atomic_fetch_add')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_add(3fortran)                          atomic_fetch_add(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_ADD(3) - [ATOMIC] Atomic ADD operation with prior fetch', &
'', &
'SYNTAX', &
'  call atomic_fetch_add(atom, value, old, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_FETCH_ADD(ATOM, VALUE, OLD) atomically stores the value of ATOM in', &
'  OLD and adds the value of VAR to the variable ATOM. When STAT is present and', &
'  the invocation was successful, it is assigned the value 0.  If it is present', &
'  and the invocation has failed, it is assigned a positive value; in', &
'  particular, for a coindexed ATOM, if the remote image has stopped, it is', &
'  assigned the value of iso_fortran_env''s stat_stopped_image and if the remote', &
'  image has failed, the value stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind. atomic_logical_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_add', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'         call atomic_add(atom[1], this_image(), old)', &
'      end program demo_atomic_fetch_add', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_ADD(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_AND(3), ATOMIC_FETCH_OR(3),', &
'', &
'  ATOMIC_FETCH_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022    atomic_fetch_add(3fortran)', &
'']

shortname="atomic_fetch_add"
call process()


case('24','atomic_fetch_and')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_and(3fortran)                          atomic_fetch_and(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_AND(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation', &
'  with prior fetch', &
'', &
'SYNTAX', &
'  call atomic_fetch_and(atom, value, old, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_FETCH_AND(ATOM, VALUE, OLD) atomically stores the value of ATOM in', &
'  OLD and defines ATOM with the bitwise AND between the values of ATOM and', &
'  VALUE. When STAT is present and the invocation was successful, it is', &
'  assigned the value 0. If it is present and the invocation has failed, it is', &
'  assigned a positive value; in particular, for a coindexed ATOM, if the', &
'  remote image has stopped, it is assigned the value of iso_fortran_env''s', &
'  stat_stopped_image and if the remote image has failed, the value', &
'  stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_and', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'         call atomic_fetch_and (atom[1], int(b''10100011101''), old)', &
'      end program demo_atomic_fetch_and', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_AND(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_OR(3),', &
'', &
'  ATOMIC_FETCH_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022    atomic_fetch_and(3fortran)', &
'']

shortname="atomic_fetch_and"
call process()


case('25','atomic_fetch_or')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_or(3fortran)                            atomic_fetch_or(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_OR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation', &
'  with prior fetch', &
'', &
'SYNTAX', &
'  call atomic_fetch_or(atom, value, old, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_FETCH_OR(ATOM, VALUE, OLD) atomically stores the value of ATOM in OLD', &
'  and defines ATOM with the bitwise OR between the values of ATOM and VALUE.', &
'  When STAT is present and the invocation was successful, it is assigned the', &
'  value 0. If it is present and the invocation has failed, it is assigned a', &
'  positive value; in particular, for a coindexed ATOM, if the remote image has', &
'  stopped, it is assigned the value of iso_fortran_env''s stat_stopped_image', &
'  and if the remote image has failed, the value stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_or', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'         call atomic_fetch_or(atom[1], int(b''10100011101''), old)', &
'      end program demo_atomic_fetch_or', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_OR(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_AND(3),', &
'', &
'  ATOMIC_FETCH_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022     atomic_fetch_or(3fortran)', &
'']

shortname="atomic_fetch_or"
call process()


case('26','atomic_fetch_xor')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_xor(3fortran)                          atomic_fetch_xor(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_XOR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise XOR operation', &
'  with prior fetch', &
'', &
'SYNTAX', &
'  call atomic_fetch_xor (atom, value, old, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_FETCH_XOR(ATOM, VALUE, OLD) atomically stores the value of ATOM in', &
'  OLD and defines ATOM with the bitwise XOR between the values of ATOM and', &
'  VALUE. When STAT is present and the invocation was successful, it is', &
'  assigned the value 0. If it is present and the invocation has failed, it is', &
'  assigned a positive value; in particular, for a coindexed ATOM, if the', &
'  remote image has stopped, it is assigned the value of iso_fortran_env''s', &
'  stat_stopped_image and if the remote image has failed, the value', &
'  stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_xor', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'         call atomic_fetch_xor (atom[1], int(b''10100011101''), old)', &
'      end program demo_atomic_fetch_xor', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_XOR(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_AND(3),', &
'', &
'  ATOMIC_FETCH_OR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022    atomic_fetch_xor(3fortran)', &
'']

shortname="atomic_fetch_xor"
call process()


case('27','atomic_or')

textblock=[character(len=256) :: &
'', &
'atomic_or(3fortran)                                        atomic_or(3fortran)', &
'', &
'NAME', &
'  ATOMIC_OR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation', &
'', &
'SYNTAX', &
'  call atomic_or(atom, value, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_OR(ATOM, VALUE) atomically defines ATOM with the bitwise OR between', &
'  the values of ATOM and VALUE. When STAT is present and the invocation was', &
'  successful, it is assigned the value 0. If it is present and the invocation', &
'  has failed, it is assigned a positive value; in particular, for a coindexed', &
'  ATOM, if the remote image has stopped, it is assigned the value of', &
'  iso_fortran_env''s stat_stopped_image and if the remote image has failed, the', &
'  value stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_or', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'         call atomic_or(atom[1], int(b''10100011101''))', &
'      end program demo_atomic_or', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_FETCH_OR(3),', &
'', &
'  ISO_FORTRAN_ENV(3), ATOMIC_ADD(3), ATOMIC_OR(3),', &
'', &
'  ATOMIC_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           atomic_or(3fortran)', &
'']

shortname="atomic_or"
call process()


case('28','atomic_ref')

textblock=[character(len=256) :: &
'', &
'atomic_ref(3fortran)                                      atomic_ref(3fortran)', &
'', &
'NAME', &
'  ATOMIC_REF(3) - [ATOMIC] Obtaining the value of a variable atomically', &
'', &
'SYNTAX', &
'  call atomic_ref(value, atom, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_REF(VALUE, ATOM) atomically assigns the value of the variable ATOM to', &
'  VALUE. When STAT is present and the invocation was successful, it is', &
'  assigned the value 0. If it is present and the invocation has failed, it is', &
'  assigned a positive value; in particular, for a coindexed ATOM, if the', &
'  remote image has stopped, it is assigned the value of iso_fortran_env''s', &
'  STAT_STOPPED_IMAGE and if the remote image has failed, the value', &
'  STAT_FAILED_IMAGE.', &
'', &
'ARGUMENTS', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  ATOM : Scalar coarray or coindexed variable of either integer type with', &
'     atomic_int_kind kind or logical type with atomic_logical_kind kind.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_ref', &
'      use iso_fortran_env', &
'      implicit none', &
'      logical(atomic_logical_kind) :: atom[*]', &
'      logical :: val', &
'         call atomic_ref( val, atom[1] )', &
'         ! ```', &
'         call atomic_ref( val, atom[1] )', &
'         if (val) then', &
'            print *, "Obtained"', &
'         endif', &
'      end program demo_atomic_ref', &
'', &
'STANDARD', &
'  Fortran 2008 and later; with STAT, TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_CAS(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_AND(3),', &
'', &
'  ATOMIC_FETCH_OR(3), ATOMIC_FETCH_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          atomic_ref(3fortran)', &
'']

shortname="atomic_ref"
call process()


case('29','atomic_xor')

textblock=[character(len=256) :: &
'', &
'atomic_xor(3fortran)                                      atomic_xor(3fortran)', &
'', &
'NAME', &
'  ATOMIC_XOR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation', &
'', &
'SYNTAX', &
'  call atomic_xor(atom, value, stat)', &
'', &
'DESCRIPTION', &
'  ATOMIC_XOR(ATOM, VALUE) atomically defines ATOM with the bitwise XOR between', &
'  the values of ATOM and VALUE. When STAT is present and the invocation was', &
'  successful, it is assigned the value 0. If it is present and the invocation', &
'  has failed, it is assigned a positive value; in particular, for a coindexed', &
'  ATOM, if the remote image has stopped, it is assigned the value of', &
'  iso_fortran_env''s stat_stopped_image and if the remote image has failed, the', &
'  value stat_failed_image.', &
'', &
'ARGUMENTS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_xor', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'         call atomic_xor(atom[1], int(b''10100011101''))', &
'      end program demo_atomic_xor', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_FETCH_XOR(3), ISO_FORTRAN_ENV(3), ATOMIC_ADD(3),', &
'  ATOMIC_OR(3), ATOMIC_XOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          atomic_xor(3fortran)', &
'']

shortname="atomic_xor"
call process()


case('30','bessel_j0')

textblock=[character(len=256) :: &
'', &
'bessel_j0(3fortran)                                        bessel_j0(3fortran)', &
'', &
'NAME', &
'  BESSEL_J0(3) - [MATHEMATICS] Bessel function of the first kind of order 0', &
'', &
'SYNTAX', &
'  result = bessel_j0(x)', &
'', &
'DESCRIPTION', &
'  BESSEL_J0(X) computes the Bessel function of the first kind of order 0 of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of type real and lies in the range -0.4027 <=', &
'  BESSEL(0,X) <= 1. It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_besj0', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'         implicit none', &
'         real(kind=real64) :: x = 0.0_real64', &
'         x = bessel_j0(x)', &
'         write(*,*)x', &
'      end program demo_besj0', &
'', &
'  Results:', &
'', &
'            1.0000000000000000', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           bessel_j0(3fortran)', &
'']

shortname="bessel_j0"
call process()


case('31','bessel_j1')

textblock=[character(len=256) :: &
'', &
'bessel_j1(3fortran)                                        bessel_j1(3fortran)', &
'', &
'NAME', &
'  BESSEL_J1(3) - [MATHEMATICS] Bessel function of the first kind of order 1', &
'', &
'SYNTAX', &
'  result = bessel_j1(x)', &
'', &
'DESCRIPTION', &
'  BESSEL_J1(X) computes the Bessel function of the first kind of order 1 of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of type real and lies in the range -0.5818 <=', &
'  BESSEL(0,X) <= 0.5818 . It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_besj1', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'       & real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'         x = bessel_j1(x)', &
'         write(*,*)x', &
'      end program demo_besj1', &
'', &
'  Results:', &
'', &
'           0.44005058574493350', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           bessel_j1(3fortran)', &
'']

shortname="bessel_j1"
call process()


case('32','bessel_jn')

textblock=[character(len=256) :: &
'', &
'bessel_jn(3fortran)                                        bessel_jn(3fortran)', &
'', &
'NAME', &
'  BESSEL_JN(3) - [MATHEMATICS] Bessel function of the first kind', &
'', &
'SYNTAX', &
'  result = bessel_jn(n, x)', &
'', &
'  result = bessel_jn(n1, n2, x)', &
'', &
'DESCRIPTION', &
'  BESSEL_JN(N, X) computes the Bessel function of the first kind of order N of', &
'  X. If N and X are arrays, their ranks and shapes shall conform.', &
'', &
'  BESSEL_JN(N1, N2, X) returns an array with the Bessel function|Bessel', &
'  functions of the first kind of the orders N1 to N2.', &
'', &
'ARGUMENTS', &
'  o  N : Shall be a scalar or an array of type integer.', &
'', &
'  o  N1 : Shall be a non-negative scalar of type integer.', &
'', &
'  o  N2 : Shall be a non-negative scalar of type integer.', &
'', &
'  o  X : Shall be a scalar or an array of type real. For BESSEL_JN(N1, N2, X)', &
'     it shall be scalar.', &
'', &
'RETURNS', &
'  The return value is a scalar of type real. It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_besjn', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'         & real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'          x = bessel_jn(5,x)', &
'          write(*,*)x', &
'      end program demo_besjn', &
'', &
'  Results:', &
'', &
'            2.4975773021123450E-004', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_Y0(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           bessel_jn(3fortran)', &
'']

shortname="bessel_jn"
call process()


case('33','bessel_y0')

textblock=[character(len=256) :: &
'', &
'bessel_y0(3fortran)                                        bessel_y0(3fortran)', &
'', &
'NAME', &
'  BESSEL_Y0(3) - [MATHEMATICS] Bessel function of the second kind of order 0', &
'', &
'SYNTAX', &
'  result = bessel_y0(x)', &
'', &
'DESCRIPTION', &
'  BESSEL_Y0(X) computes the Bessel function of the second kind of order 0 of', &
'  X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of type real. It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_besy0', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'      implicit none', &
'        real(kind=real64) :: x = 0.0_real64', &
'        x = bessel_y0(x)', &
'        write(*,*)x', &
'      end program demo_besy0', &
'', &
'  Results:', &
'', &
'                          -Infinity', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           bessel_y0(3fortran)', &
'']

shortname="bessel_y0"
call process()


case('34','bessel_y1')

textblock=[character(len=256) :: &
'', &
'bessel_y1(3fortran)                                        bessel_y1(3fortran)', &
'', &
'NAME', &
'  BESSEL_Y1(3) - [MATHEMATICS] Bessel function of the second kind of order 1', &
'', &
'SYNTAX', &
'  result = bessel_y1(x)', &
'', &
'DESCRIPTION', &
'  BESSEL_Y1(X) computes the Bessel function of the second kind of order 1 of', &
'  X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is real. It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_besy1', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'      implicit none', &
'        real(kind=real64) :: x = 1.0_real64', &
'        write(*,*)x, bessel_y1(x)', &
'      end program demo_besy1', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_YN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           bessel_y1(3fortran)', &
'']

shortname="bessel_y1"
call process()


case('35','bessel_yn')

textblock=[character(len=256) :: &
'', &
'bessel_yn(3fortran)                                        bessel_yn(3fortran)', &
'', &
'NAME', &
'  BESSEL_YN(3) - [MATHEMATICS] Bessel function of the second kind', &
'', &
'SYNTAX', &
'  result = bessel_yn(n, x)', &
'', &
'  result = bessel_yn(n1, n2, x)', &
'', &
'DESCRIPTION', &
'  BESSEL_YN(N, X) computes the Bessel function of the second kind of order N', &
'  of X. If N and X are arrays, their ranks and shapes shall conform.', &
'', &
'  BESSEL_YN(N1, N2, X) returns an array with the Bessel function|Bessel', &
'  functions of the first kind of the orders N1 to N2.', &
'', &
'ARGUMENTS', &
'  o  N : Shall be a scalar or an array of type integer.', &
'', &
'  o  N1 : Shall be a non-negative scalar of type integer.', &
'', &
'  o  N2 : Shall be a non-negative scalar of type integer.', &
'', &
'  o  X : Shall be a scalar or an array of type real; for BESSEL_YN(N1, N2, X)', &
'     it shall be scalar.', &
'', &
'RETURNS', &
'  The return value is real. It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_besyn', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'        write(*,*) x,bessel_yn(5,x)', &
'      end program demo_besyn', &
'', &
'  Results:', &
'', &
'            1.0000000000000000       -260.40586662581222', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_Y1(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           bessel_yn(3fortran)', &
'']

shortname="bessel_yn"
call process()


case('36','bge')

textblock=[character(len=256) :: &
'', &
'bge(3fortran)                                                    bge(3fortran)', &
'', &
'NAME', &
'  BGE(3) - [BIT:COMPARE] Bitwise greater than or equal to', &
'', &
'SYNTAX', &
'  elemental function bge(i, j)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=KIND),intent(in) :: j', &
'           logical :: bge', &
'', &
'  where the kind of I and J may be of any supported integer kind, not', &
'  necessarily the same. An exception is that values may be a BOZ constant with', &
'  a value valid for the integer kind available with the most bits on the', &
'  current platform.', &
'', &
'DESCRIPTION', &
'  Determines whether one integer is bitwise greater than or equal to another.', &
'', &
'  The bit-level representation of a value is platform dependent. The endian-', &
'  ness of a system and whether the system uses a "two''s complement"', &
'  representation of signs can affect the results, for example.', &
'', &
'  A BOZ constant (Binary, Octal, Hexadecimal) does not have a kind or type of', &
'  its own, so be aware it is subject to truncation when transferred to an', &
'  integer type. The most bits the constant may contain is limited by the most', &
'  bits representable by any integer kind supported by the compilation.', &
'', &
'  Bit Sequence Comparison', &
'', &
'  When bit sequences of unequal length are compared, the shorter sequence is', &
'  padded with zero bits on the left to the same length as the longer sequence', &
'  (up to the largest number of bits any available integer kind supports).', &
'', &
'  Bit sequences are compared from left to right, one bit at a time, until', &
'  unequal bits are found or until all bits have been compared and found to be', &
'  equal.', &
'', &
'  The bits are always evaluated in this order, not necessarily from MSB to LSB', &
'  (most significant bit to least significant bit).', &
'', &
'  If unequal bits are found the sequence with zero in the unequal position is', &
'  considered to be less than the sequence with one in the unequal position.', &
'', &
'ARGUMENTS', &
'  o  I : The value to test if >= J based on the bit representation of the', &
'     values. Shall be of integer type or a BOZ literal constant.', &
'', &
'  o  J : The value to test I against. Shall be of integer type or a BOZ', &
'     literal constant.', &
'', &
'RETURNS', &
'  The return value is of type logical and of the default kind. It is \.true.', &
'  if I is bit-wise greater than J and .false. otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bge', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: i', &
'      integer(kind=int8) :: byte', &
'      integer(kind=int8),allocatable :: arr1(:), arr2(:)', &
'', &
'        ! BASIC USAGE', &
'         write(*,*)''bge(-127,127)='',bge( -127, 127 )', &
'         ! on (very common) "two''s complement" machines that are', &
'         ! little-endian -127 will be greater than 127', &
'', &
'         ! BOZ constants', &
'         ! BOZ constants are subject to truncation, so make sure', &
'         ! your values are valid for the integer kind being compared to', &
'         write(*,*)''bge(b"0001",2)='',bge( b"1", 2)', &
'', &
'        ! ELEMENTAL', &
'         ! an array and scalar', &
'         write(*, *)''compare array of values [-128, -0, +0, 127] to 127''', &
'         write(*, *)bge(int([-128, -0, +0, 127], kind=int8), 127_int8)', &
'', &
'         ! two arrays', &
'         write(*, *)''compare two arrays''', &
'         arr1=int( [ -127, -0, +0,  127], kind=int8 )', &
'         arr2=int( [  127,  0,  0, -127], kind=int8 )', &
'         write(*,*)''arr1='',arr1', &
'         write(*,*)''arr2='',arr2', &
'         write(*, *)''bge(arr1,arr2)='',bge( arr1, arr2 )', &
'', &
'        ! SHOW TESTS AND BITS', &
'         ! actually looking at the bit patterns should clarify what affect', &
'         ! signs have ...', &
'         write(*,*)''Compare some one-byte values to 64.''', &
'         write(*,*)''Notice that the values are tested as bits not as integers''', &
'         write(*,*)''so the results are as if values are unsigned integers.''', &
'         do i=-128,127,32', &
'            byte=i', &
'            write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,bge(byte,64_int8),byte', &
'         enddo', &
'', &
'        ! SIGNED ZERO', &
'         ! are +0 and -0 the same on your platform? When comparing at the', &
'         ! bit level this is important', &
'         write(*,''("plus zero=",b0)'')  +0', &
'         write(*,''("minus zero=",b0)'') -0', &
'', &
'      end program demo_bge', &
'', &
'  Results:', &
'', &
'  How an integer value is represented at the bit level can vary. These are', &
'  just the values expected on Today''s most common platforms ...', &
'', &
'          > bge(-127,127)= T', &
'          > bge(b"0001",2)= F', &
'          > compare array of values [-128, -0, +0, 127] to 127', &
'          > T F F T', &
'          > compare two arrays', &
'          > arr1= -127    0    0  127', &
'          > arr2=  127    0    0 -127', &
'          > bge(arr1,arr2)= T T T F', &
'          > Compare some one-byte values to 64.', &
'          > Notice that the values are tested as bits not as integers', &
'          > so the resuls are as if values are unsigned integers.', &
'          > -0128  T 10000000', &
'          > -0096  T 10100000', &
'          > -0064  T 11000000', &
'          > -0032  T 11100000', &
'          > +0000  F 00000000', &
'          > +0032  F 00100000', &
'          > +0064  T 01000000', &
'          > +0096  T 01100000', &
'          > plus zero=0', &
'          > minus zero=0', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BGT(3), BLE(3), BLT(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 bge(3fortran)', &
'']

shortname="bge"
call process()


case('37','bgt')

textblock=[character(len=256) :: &
'', &
'bgt(3fortran)                                                    bgt(3fortran)', &
'', &
'NAME', &
'  BGT(3) - [BIT:COMPARE] Bitwise greater than', &
'', &
'SYNTAX', &
'  elemental function bgt(i, j)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=KIND),intent(in) :: j', &
'           logical :: bgt', &
'', &
'  where the kind of I and J may be of any supported integer kind, not', &
'  necessarily the same. An exception is that values may be a BOZ constant with', &
'  a value valid for the integer kind available with the most bits on the', &
'  current platform.', &
'', &
'DESCRIPTION', &
'  Determines whether an integer is bitwise greater than another. Bit-level', &
'  representations of values are platform-dependent.', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of integer type or a BOZ literal constant.', &
'', &
'  o  J : Shall be of integer type or a BOZ literal constant.', &
'', &
'RETURNS', &
'  The return value is of type logical and of the default kind. The result is', &
'  true if the sequence of bits represented by i is greater than the sequence', &
'  of bits represented by j, otherwise the result is false.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bgt', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: i', &
'      integer(kind=int8) :: byte', &
'        ! Compare some one-byte values to 64.', &
'         ! Notice that the values are tested as bits not as integers', &
'         ! so sign bits in the integer are treated just like any other', &
'         do i=-128,127,32', &
'            byte=i', &
'            write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,bgt(byte,64_int8),byte', &
'         enddo', &
'', &
'         ! see the BGE() description for an extended description', &
'         ! of related information', &
'', &
'      end program demo_bgt', &
'', &
'  Results:', &
'', &
'         > -0128  T 10000000', &
'         > -0096  T 10100000', &
'         > -0064  T 11000000', &
'         > -0032  T 11100000', &
'         > +0000  F 00000000', &
'         > +0032  F 00100000', &
'         > +0064  F 01000000', &
'         > +0096  T 01100000', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BGE(3), BLE(3), BLT(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 bgt(3fortran)', &
'']

shortname="bgt"
call process()


case('38','bit_size')

textblock=[character(len=256) :: &
'', &
'bit_size(3fortran)                                          bit_size(3fortran)', &
'', &
'NAME', &
'  BIT_SIZE(3) - [BIT:INQUIRY] Bit size inquiry function', &
'', &
'SYNTAX', &
'  result = bit_size(i)', &
'', &
'           function(kind=KIND) :: bit_size', &
'           integer(kind=KIND),intent(in) :: ii', &
'', &
'DESCRIPTION', &
'  BIT_SIZE(I) returns the number of bits (integer precision plus sign bit)', &
'  represented by the type of the integer I. I can be a scalar or an array.', &
'', &
'ARGUMENTS', &
'  o  I : An integer value of any kind to determine the size of in bits.', &
'     Because only the type of the argument is examined, the argument need not', &
'     be defined.', &
'', &
'RETURNS', &
'  Returns the number of bits used to represent a value of the type of I.  The', &
'  result is a integer scalar of the same kind as I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bit_size', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int64)          :: answer', &
'      character(len=*),parameter   :: fmt=''(*(g0,1x))''', &
'          write(*,fmt)''default integer size is'',bit_size(0),''bits''', &
'          write(*,fmt)bit_size(bit_size(0_int8)), ''which is kind='',kind(0_int8)', &
'          write(*,fmt)bit_size(bit_size(0_int16)),''which is kind='',kind(0_int16)', &
'          write(*,fmt)bit_size(bit_size(0_int32)),''which is kind='',kind(0_int32)', &
'          write(*,fmt)bit_size(bit_size(0_int64)),''which is kind='',kind(0_int64)', &
'', &
'          ! Check size of value not explicitly defined.', &
'          write(*,fmt) int(bit_size(answer))', &
'      end program demo_bit_size', &
'', &
'  Typical Results:', &
'', &
'         default integer size is 32 bits', &
'         8 which is kind= 1', &
'         16 which is kind= 2', &
'         32 which is kind= 4', &
'         64 which is kind= 8', &
'         64', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022            bit_size(3fortran)', &
'']

shortname="bit_size"
call process()


case('39','ble')

textblock=[character(len=256) :: &
'', &
'ble(3fortran)                                                    ble(3fortran)', &
'', &
'NAME', &
'  BLE(3) - [BIT:COMPARE] Bitwise less than or equal to', &
'', &
'SYNTAX', &
'  elemental function ble(i, j)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=KIND),intent(in) :: j', &
'           logical :: ble', &
'', &
'  where the kind of I and J may be of any supported integer kind, not', &
'  necessarily the same. An exception is that values may be a BOZ constant with', &
'  a value valid for the integer kind available with the most bits on the', &
'  current platform.', &
'', &
'SYNTAX', &
'DESCRIPTION', &
'  Determines whether an integer is bitwise less than or equal to another.', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of integer type or a BOZ literal constant.', &
'', &
'  o  J : Shall be of integer type or a BOZ constant.', &
'', &
'RETURNS', &
'  The return value is of type logical and of the default kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ble', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: i', &
'      integer(kind=int8) :: byte', &
'        ! Compare some one-byte values to 64.', &
'         ! Notice that the values are tested as bits not as integers', &
'         ! so sign bits in the integer are treated just like any other', &
'         do i=-128,127,32', &
'            byte=i', &
'            write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,ble(byte,64_int8),byte', &
'         enddo', &
'', &
'         ! see the BGE() description for an extended description', &
'         ! of related information', &
'', &
'      end program demo_ble', &
'', &
'  Results:', &
'', &
'         > -0128  F 10000000', &
'         > -0096  F 10100000', &
'         > -0064  F 11000000', &
'         > -0032  F 11100000', &
'         > +0000  T 00000000', &
'         > +0032  T 00100000', &
'         > +0064  T 01000000', &
'         > +0096  F 01100000', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BGE(3), BGT(3), BLT(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 ble(3fortran)', &
'']

shortname="ble"
call process()


case('40','blt')

textblock=[character(len=256) :: &
'', &
'blt(3fortran)                                                    blt(3fortran)', &
'', &
'NAME', &
'  BLT(3) - [BIT:COMPARE] Bitwise less than', &
'', &
'SYNTAX', &
'  elemental function blt(i, j)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=KIND),intent(in) :: j', &
'           logical :: blt', &
'', &
'  where the kind of I and J may be of any supported integer kind, not', &
'  necessarily the same. An exception is that values may be a BOZ constant with', &
'  a value valid for the integer kind available with the most bits on the', &
'  current platform.', &
'', &
'DESCRIPTION', &
'  Determines whether an integer is bitwise less than another.', &
'', &
'ARGUMENTS', &
'  o  I Shall be of integer type or a BOZ literal constant.', &
'', &
'  o  J : Shall be of integer type or a BOZ constant.', &
'', &
'RETURNS', &
'  The return value is of type logical and of the default kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_blt', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: i', &
'      integer(kind=int8) :: byte', &
'        ! Compare some one-byte values to 64.', &
'         ! Notice that the values are tested as bits not as integers', &
'         ! so sign bits in the integer are treated just like any other', &
'         do i=-128,127,32', &
'            byte=i', &
'            write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,blt(byte,64_int8),byte', &
'         enddo', &
'', &
'         ! see the BGE() description for an extended description', &
'         ! of related information', &
'', &
'      end program demo_blt', &
'', &
'  Results:', &
'', &
'         > -0128  F 10000000', &
'         > -0096  F 10100000', &
'         > -0064  F 11000000', &
'         > -0032  F 11100000', &
'         > +0000  T 00000000', &
'         > +0032  T 00100000', &
'         > +0064  F 01000000', &
'         > +0096  F 01100000', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BGE(3), BGT(3), BLE(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 blt(3fortran)', &
'']

shortname="blt"
call process()


case('41','btest')

textblock=[character(len=256) :: &
'', &
'btest(3fortran)                                                btest(3fortran)', &
'', &
'NAME', &
'  BTEST(3) - [BIT:INQUIRY] Tests a bit of an integer value.', &
'', &
'SYNTAX', &
'  result = btest(i, pos)', &
'', &
'          integer(kind=KIND) elemental function btest(i,pos)', &
'          integer,intent(in)  :: i', &
'          logical,intent(out) :: pos', &
'', &
'  where KIND is any integer kind supported by the programming environment.', &
'', &
'DESCRIPTION', &
'  BTEST(I,POS) returns logical .true. if the bit at POS in I is set.', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'  o  POS : The bit position to query. it must be a valid position for the', &
'     value I; ie. 0 <= POS <= BIT_SIZE(I) .', &
'', &
'     A value of zero refers to the least significant bit.', &
'', &
'RETURNS', &
'  The result is a logical that has the value .true. if bit position POS of I', &
'  has the value 1 and the value .false. if bit POS of I has the value 0.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_btest', &
'      implicit none', &
'      integer :: i, j, pos, a(2,2)', &
'      logical :: bool', &
'      character(len=*),parameter :: g=''(*(g0))''', &
'', &
'           i = 32768 + 1024 + 64', &
'          write(*,''(a,i0,"=>",b32.32,/)'')''Looking at the integer: '',i', &
'', &
'          ! looking one bit at a time from LOW BIT TO HIGH BIT', &
'          write(*,g)''from bit 0 to bit '',bit_size(i),''==>''', &
'          do pos=0,bit_size(i)-1', &
'              bool = btest(i, pos)', &
'              write(*,''(l1)'',advance=''no'')bool', &
'          enddo', &
'          write(*,*)', &
'', &
'          ! a binary format the hard way.', &
'          ! Note going from bit_size(i) to zero.', &
'          write(*,*)', &
'          write(*,g)''so for '',i,'' with a bit size of '',bit_size(i)', &
'          write(*,''(b32.32)'')i', &
'          write(*,g)merge(''^'',''_'',[(btest(i,j),j=bit_size(i)-1,0,-1)])', &
'          write(*,*)', &
'          write(*,g)''and for '',-i,'' with a bit size of '',bit_size(i)', &
'          write(*,''(b32.32)'')-i', &
'          write(*,g)merge(''^'',''_'',[(btest(-i,j),j=bit_size(i)-1,0,-1)])', &
'', &
'          ! elemental:', &
'          !', &
'          a(1,:)=[ 1, 2 ]', &
'          a(2,:)=[ 3, 4 ]', &
'          write(*,*)', &
'          write(*,''(a,/,*(i2,1x,i2,/))'')''given the array a ...'',a', &
'          ! the second bit of all the values in a', &
'          write(*,''(a,/,*(l2,1x,l2,/))'')''the value of btest (a, 2)'',btest(a,2)', &
'          ! bits 1,2,3,4 of the value 2', &
'          write(*,''(a,/,*(l2,1x,l2,/))'')''the value of btest (2, a)'',btest(2,a)', &
'      end program demo_btest', &
'', &
'  Results:', &
'', &
'      Looking at the integer: 33856=>11111111111111110111101111000000', &
'', &
'      00000000000000001000010001000000', &
'      11111111111111110111101111000000', &
'      1000010001000000', &
'      11111111111111110111101111000000', &
'      from bit 0 to bit 32==>', &
'', &
'   FFFFFFTFFFTFFFFTFFFFFFFFFFFFFFFF', &
'  so for 33856 with a bit size of 32 00000000000000001000010001000000', &
'  ________________^____^___^______', &
'', &
'  and for -33856 with a bit size of 32 11111111111111110111101111000000', &
'  ^^^^^^^^^^^^^^^^_^^^^_^^^^______', &
'', &
'  given the array a ...', &
'', &
'    1', &
'', &
'    2', &
'', &
'  the value of btest (a, 2)', &
'', &
'   F F', &
'   F T', &
'  the value of btest (2, a)', &
'', &
'   T F', &
'   F F', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), IBCLR(3), NOT(3), IBCLR(3), IBITS(3), IBSET(3), IAND(3), IOR(3),', &
'  IEOR(3), MVBITS(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               btest(3fortran)', &
'']

shortname="btest"
call process()


case('42','c_associated')

textblock=[character(len=256) :: &
'', &
'c_associated(3fortran)                                  c_associated(3fortran)', &
'', &
'NAME', &
'  C_ASSOCIATED(3) - [ISO_C_BINDING] Status of a C pointer', &
'', &
'SYNTAX', &
'  result = c_associated(c_prt_1, c_ptr_2)', &
'', &
'DESCRIPTION', &
'  C_ASSOCIATED(C_PRT_1[, C_PTR_2]) determines the status of the C pointer', &
'  c_ptr_1 or if c_ptr_1 is associated with the target c_ptr_2.', &
'', &
'ARGUMENTS', &
'  o  C_PTR_1 : Scalar of the type c_ptr or c_funptr.', &
'', &
'  o  C_PTR_2 : (Optional) Scalar of the same type as c_ptr_1.', &
'', &
'RETURNS', &
'  The return value is of type logical; it is .false. if either c_ptr_1 is a C', &
'  NULL pointer or if c_ptr1 and c_ptr_2 point to different addresses.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_associated', &
'', &
'      contains', &
'', &
'      subroutine association_test(a,b)', &
'      use iso_c_binding, only: c_associated, c_loc, c_ptr', &
'      implicit none', &
'      real, pointer :: a', &
'      type(c_ptr) :: b', &
'         if(c_associated(b, c_loc(a))) &', &
'            stop ''b and a do not point to same target''', &
'      end subroutine association_test', &
'', &
'      end program demo_c_associated', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  C_LOC(3), C_FUNLOC(3), ISO_C_BINDING(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022        c_associated(3fortran)', &
'']

shortname="c_associated"
call process()


case('43','ceiling')

textblock=[character(len=256) :: &
'', &
'ceiling(3fortran)                                            ceiling(3fortran)', &
'', &
'NAME', &
'  CEILING(3) - [NUMERIC] Integer ceiling function', &
'', &
'SYNTAX', &
'  result = ceiling(a, kind)', &
'', &
'         integer(kind=KIND) elemental function ceiling(a,kind)', &
'         real(kind=ANY),intent(in)   :: a', &
'         integer,intent(in),optional :: kind', &
'', &
'DESCRIPTION', &
'  CEILING(A) returns the least integer greater than or equal to A.', &
'', &
'ARGUMENTS', &
'  o  A : The type shall be real.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RETURNS', &
'  The return value is of type INTEGER(kind) if KIND is present and a default-', &
'  kind integer otherwise.', &
'', &
'  The result is undefined if it cannot be represented in the specified integer', &
'  type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ceiling', &
'      implicit none', &
'      real :: x = 63.29', &
'      real :: y = -63.59', &
'         print *, ceiling(x)', &
'         print *, ceiling(y)', &
'         ! elemental', &
'         print *,ceiling([ &', &
'         &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'         &  0.0,   &', &
'         &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'      end program demo_ceiling', &
'', &
'  Results:', &
'', &
'         64', &
'  -63', &
'', &
'    -2', &
'      -2      -2      -2      -1      -1', &
'', &
'      0 0       1       1       2       2', &
'', &
'      3 3       3', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  FLOOR(3), NINT(3)', &
'', &
'  AINT(3), ANINT(3), INT(3), SELECTED_INT_KIND(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             ceiling(3fortran)', &
'']

shortname="ceiling"
call process()


case('44','c_f_pointer')

textblock=[character(len=256) :: &
'', &
'c_f_pointer(3fortran)                                    c_f_pointer(3fortran)', &
'', &
'NAME', &
'  C_F_POINTER(3) - [ISO_C_BINDING] Convert C into Fortran pointer', &
'', &
'SYNTAX', &
'  call c_f_pointer(cptr, fptr, shape)', &
'', &
'DESCRIPTION', &
'  C_F_POINTER(CPTR, FPTR[, SHAPE]) Assign the target, the C pointer, CPTR to', &
'  the Fortran pointer FPTR and specify its shape.', &
'', &
'ARGUMENTS', &
'  o  CPTR : scalar of the type c_ptr. It is INTENT(IN).', &
'', &
'  o  FPTR : pointer interoperable with CPTR. it is INTENT(OUT).', &
'', &
'  o  SHAPE : (Optional) Rank-one array of type integer with INTENT(IN) .  It', &
'     shall be present if and only if FPTR is an array. The size must be equal', &
'     to the rank of FPTR.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_f_pointer', &
'      use iso_c_binding', &
'      implicit none', &
'      interface', &
'         subroutine my_routine(p) bind(c,name=''myC_func'')', &
'            import :: c_ptr', &
'            type(c_ptr), intent(out) :: p', &
'         end subroutine', &
'      end interface', &
'      type(c_ptr) :: cptr', &
'      real,pointer :: a(:)', &
'         call my_routine(cptr)', &
'         call c_f_pointer(cptr, a, [12])', &
'      end program demo_c_f_pointer', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  C_LOC(3), C_F_PROCPOINTER(3), ISO_C_BINDING(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         c_f_pointer(3fortran)', &
'']

shortname="c_f_pointer"
call process()


case('45','c_f_procpointer')

textblock=[character(len=256) :: &
'', &
'c_f_procpointer(3fortran)                            c_f_procpointer(3fortran)', &
'', &
'NAME', &
'  C_F_PROCPOINTER(3) - [ISO_C_BINDING] Convert C into Fortran procedure', &
'  pointer', &
'', &
'SYNTAX', &
'  call c_f_procpointer(cptr, fptr)', &
'', &
'DESCRIPTION', &
'  C_F_PROCPOINTER(CPTR, FPTR) assigns the target of the C function pointer', &
'  CPTR to the Fortran procedure pointer FPTR.', &
'', &
'ARGUMENTS', &
'  o  CPTR : scalar of the type c_funptr. It is INTENT(IN).', &
'', &
'  o  FPTR : procedure pointer interoperable with CPTR. It is INTENT(OUT).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_f_procpointer', &
'      use iso_c_binding', &
'      implicit none', &
'      abstract interface', &
'         function func(a)', &
'         import :: c_float', &
'         real(c_float), intent(in) :: a', &
'         real(c_float) :: func', &
'         end function', &
'      end interface', &
'      interface', &
'         function getIterFunc() bind(c,name="getIterFunc")', &
'         import :: c_funptr', &
'         type(c_funptr) :: getIterFunc', &
'         end function', &
'      end interface', &
'      type(c_funptr) :: cfunptr', &
'      procedure(func), pointer :: myFunc', &
'         cfunptr = getIterFunc()', &
'         call c_f_procpointer(cfunptr, myFunc)', &
'      end program demo_c_f_procpointer', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  C_LOC(3), C_F_POINTER(3), ISO_C_BINDING(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022     c_f_procpointer(3fortran)', &
'']

shortname="c_f_procpointer"
call process()


case('46','c_funloc')

textblock=[character(len=256) :: &
'', &
'c_funloc(3fortran)                                          c_funloc(3fortran)', &
'', &
'NAME', &
'  C_FUNLOC(3) - [ISO_C_BINDING] Obtain the C address of a procedure', &
'', &
'SYNTAX', &
'  result = c_funloc(x)', &
'', &
'DESCRIPTION', &
'  C_FUNLOC(X) determines the C address of the argument.', &
'', &
'ARGUMENTS', &
'  o  X : Interoperable function or pointer to such function.', &
'', &
'RETURNS', &
'  The return value is of type c_funptr and contains the C address of the', &
'  argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      ! program demo_c_funloc and module', &
'      module x', &
'      use iso_c_binding', &
'      implicit none', &
'      contains', &
'      subroutine sub(a) bind(c)', &
'      real(c_float) :: a', &
'         a = sqrt(a)+5.0', &
'      end subroutine sub', &
'      end module x', &
'      !', &
'      program demo_c_funloc', &
'      use iso_c_binding', &
'      use x', &
'      implicit none', &
'      interface', &
'         subroutine my_routine(p) bind(c,name=''myC_func'')', &
'           import :: c_funptr', &
'           type(c_funptr), intent(in) :: p', &
'         end subroutine', &
'      end interface', &
'         call my_routine(c_funloc(sub))', &
'      !', &
'      end program demo_c_funloc', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  C_ASSOCIATED(3), C_LOC(3), C_F_POINTER(3),', &
'', &
'  C_F_PROCPOINTER(3), ISO_C_BINDING(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022            c_funloc(3fortran)', &
'']

shortname="c_funloc"
call process()


case('47','char')

textblock=[character(len=256) :: &
'', &
'char(3fortran)                                                  char(3fortran)', &
'', &
'NAME', &
'  CHAR(3) - [CHARACTER] Character conversion function', &
'', &
'SYNTAX', &
'  result = char(i, kind) elemental integer function char(i,kind)', &
'', &
'          integer(kind=KIND),intent(in) :: c', &
'          integer,intent(in),optional :: KIND', &
'', &
'DESCRIPTION', &
'  CHAR(I, KIND) returns the character represented by the integer I.', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type character', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_char', &
'      implicit none', &
'      integer :: i = 74', &
'      character(1) :: c', &
'          c = char(i)', &
'          print *, i, c ! returns ''J''', &
'      end program demo_char', &
'', &
'  Results:', &
'', &
'                   74 J', &
'', &
'NOTE', &
'  See ICHAR(3) for a discussion of converting between numerical values and', &
'  formatted string representations.', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  ACHAR(3), IACHAR(3), ICHAR(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                char(3fortran)', &
'']

shortname="char"
call process()


case('48','c_loc')

textblock=[character(len=256) :: &
'', &
'c_loc(3fortran)                                                c_loc(3fortran)', &
'', &
'NAME', &
'  C_LOC(3) - [ISO_C_BINDING] Obtain the C address of an object', &
'', &
'SYNTAX', &
'  result = c_loc(x)', &
'', &
'DESCRIPTION', &
'  C_LOC(X) determines the C address of the argument.', &
'', &
'ARGUMENTS', &
'  o  X : Shall have either the pointer or target attribute. It shall not be a', &
'     coindexed object. It shall either be a variable with interoperable type', &
'     and kind type parameters, or be a scalar, nonpolymorphic variable with no', &
'     length type parameters.', &
'', &
'RETURNS', &
'  The return value is of type c_ptr and contains the C address of the', &
'  argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'         subroutine association_test(a,b)', &
'         use iso_c_binding, only: c_associated, c_loc, c_ptr', &
'         implicit none', &
'         real, pointer :: a', &
'         type(c_ptr) :: b', &
'           if(c_associated(b, c_loc(a))) &', &
'              stop ''b and a do not point to same target''', &
'         end subroutine association_test', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  C_ASSOCIATED(3), C_FUNLOC(3), C_F_POINTER(3),', &
'', &
'  C_F_PROCPOINTER(3), ISO_C_BINDING(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               c_loc(3fortran)', &
'']

shortname="c_loc"
call process()


case('49','cmplx')

textblock=[character(len=256) :: &
'', &
'cmplx(3fortran)                                                cmplx(3fortran)', &
'', &
'NAME', &
'  CMPLX(3) - [TYPE:NUMERIC] Complex conversion function', &
'', &
'SYNTAX', &
'  result = cmplx(x, y, kind)', &
'', &
'         complex elemental function :: cmplx', &
'         TYPE(kind=KIND),intent(in), x', &
'         TYPE(kind=KIND),intent(in),optional, y', &
'         integer,intent(in),optional :: kind', &
'', &
'DESCRIPTION', &
'  To convert numeric variables to complex, use the CMPLX(3) function.', &
'  Constants can be used to define a complex variable using the syntax', &
'', &
'            z8 = (1.2345678901234567d0, 1.2345678901234567d0)', &
'', &
'  but this will not work for variables. You must use the CMPLX(3) function.', &
'', &
'  CMPLX(X [, Y [, KIND]]) returns a complex number where X is converted to the', &
'  real component. If X is complex then Y must not be present. If Y is present', &
'  it is converted to the imaginary component. If Y is not present then the', &
'  imaginary component is set to 0.0.', &
'', &
'  CMPLX(3) AND DOUBLE PRECISION', &
'', &
'  The Fortran 90 language defines CMPLX(3) as always returning a result that', &
'  is type COMPLEX(KIND=KIND(0.0)).', &
'', &
'  This means CMPLX(D1,D2), where D1 and D2 are doubleprecision, is treated as:', &
'', &
'            cmplx(sngl(d1), sngl(d2))', &
'', &
'  doubleprecision complex numbers require specifying a precision.', &
'', &
'  It was necessary for Fortran 90 to specify this behavior for doubleprecision', &
'  arguments, since that is the behavior mandated by FORTRAN 77.', &
'', &
'  So Fortran 90 extends the CMPLX(3) intrinsic by adding an extra argument', &
'  used to specify the desired kind of complex result.', &
'', &
'            integer,parameter :: dp=kind(0.0d0)', &
'            complex(kind=dp) :: z8', &
'            !', &
'            ! NO: result is just the precision of default real values', &
'            !     because KIND parameter is not specified', &
'            !', &
'            ! note this was stored with default real precision', &
'            z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0)', &
'            print *, ''NO, Z8='',z8,real(z8),aimag(z8)', &
'            z8 = cmplx(1.2345678901234567e0_dp, 1.2345678901234567e0_dp)', &
'            ! again, note components are just real', &
'            print *, ''NO, Z8='',z8,real(z8),aimag(z8)', &
'            !', &
'            ! YES', &
'            !', &
'            ! kind= makes it work', &
'            z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp)', &
'            print *, ''YES, Z8='',z8,real(z8),aimag(z8)', &
'', &
'  F2018 COMPONENT SYNTAX The real and imaginary parts of a complex entity can', &
'  be accessed independently with a component-like syntax in f2018:', &
'', &
'  A complex-part-designator is', &
'', &
'      designator % RE', &
'      or', &
'      designator % IM.', &
'', &
'  Where the designator is of complex type.', &
'', &
'  So designator%RE designates the real part of a complex value, designator%IM', &
'  designates the imaginary part of complex value. The type of a complex-part-', &
'  designator is real, and its kind and shape are those of the designator.', &
'', &
'  The following are examples of complex part designators:', &
'', &
'             impedance%re           !-- Same value as _real_(impedance)', &
'             fft%im                 !-- Same value as AIMAG(fft)', &
'             x%im = 0.0             !-- Sets the imaginary part of x to zero', &
'', &
'ARGUMENTS', &
'  o  X The type may be integer, real, or complex.', &
'', &
'  o  Y (Optional; only allowed if X is not complex.). May be integer or real.', &
'', &
'  o  KIND (Optional) An integer initialization expression indicating the kind', &
'     parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of complex type, with a kind equal to KIND if it is', &
'  specified. If KIND is not specified, the result is of the default complex', &
'  kind, regardless of the kinds of X and Y.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_aimag', &
'      implicit none', &
'      integer,parameter :: dp=kind(0.0d0)', &
'      complex          :: z4', &
'      complex(kind=dp) :: z8', &
'         z4 = cmplx(1.23456789, 1.23456789)', &
'         print *, ''Z4='',z4', &
'         ! using kind=dp makes it keep DOUBLEPRECISION precision', &
'         z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp)', &
'         print *, ''Z8='',z8', &
'         ! NOTE:', &
'         ! The following is intuitive and works without calling cmplx(3)', &
'         ! but does not work for variables just constants', &
'         z8 = (1.2345678901234567d0, 1.2345678901234567d0 )', &
'         print *, ''Z8 defined with constants='',z8', &
'      end program demo_aimag', &
'', &
'  Typical Results:', &
'', &
'          Z4= (1.23456788,1.23456788)', &
'          Z8= (1.2345678901234567,1.2345678901234567)', &
'          Z8 defined with constants= (1.2345678901234567,1.2345678901234567)', &
'', &
'SEE ALSO', &
'  o  AIMAG(3) - Imaginary part of complex number', &
'', &
'  o  CMPLX(3) - Complex conversion function', &
'', &
'  o  CONJG(3) - Complex conjugate function', &
'', &
'  o  REAL(3) - Convert to real type', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               cmplx(3fortran)', &
'']

shortname="cmplx"
call process()


case('50','co_broadcast')

textblock=[character(len=256) :: &
'', &
'co_broadcast(3fortran)                                  co_broadcast(3fortran)', &
'', &
'NAME', &
'  CO_BROADCAST(3) - [COLLECTIVE] Copy a value to all images the current set of', &
'  images', &
'', &
'SYNTAX', &
'  call co_broadcast(a, source_image, stat, errmsg)', &
'', &
'DESCRIPTION', &
'  CO_BROADCAST(3) copies the value of argument A on the image with image index', &
'  source_image to all images in the current team. A becomes defined as if by', &
'  intrinsic assignment. If the execution was successful and STAT is present,', &
'  it is assigned the value zero. If the execution failed, STAT gets assigned a', &
'  nonzero value and, if present, ERRMSG gets assigned a value describing the', &
'  occurred error.', &
'', &
'ARGUMENTS', &
'  o  A : INTENT(INOUT) argument; shall have the same dynamic type and type', &
'     parameters on all images of the current team. If it is an array, it shall', &
'     have the same shape on all images.', &
'', &
'  o  SOURCE_IMAGE : a scalar integer expression. It shall have the same the', &
'     same value on all images and refer to an image of the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_broadcast', &
'      implicit none', &
'      integer :: val(3)', &
'         if (this_image() == 1) then', &
'            val = [1, 5, 3]', &
'         endif', &
'         call co_broadcast (val, source_image=1)', &
'         print *, this_image(), ":", val', &
'      end program demo_co_broadcast', &
'', &
'SEE ALSO', &
'  CO_MAX(3), CO_MIN(3), CO_SUM(3), CO_REDUCE(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022        co_broadcast(3fortran)', &
'']

shortname="co_broadcast"
call process()


case('51','co_lbound')

textblock=[character(len=256) :: &
'', &
'co_lbound(3fortran)                                        co_lbound(3fortran)', &
'', &
'NAME', &
'  CO_LBOUND(3) - [COLLECTIVE] Lower codimension bounds of an array', &
'', &
'SYNTAX', &
'  result = co_lbound(coarray, dim, kind)', &
'', &
'DESCRIPTION', &
'  Returns the lower bounds of a coarray, or a single lower cobound along the', &
'  DIM codimension.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an coarray, of any type.', &
'', &
'  o  DIM : (Optional) Shall be a scalar integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is absent, the result is an', &
'  array of the lower cobounds of COARRAY. If DIM is present, the result is a', &
'  scalar corresponding to the lower cobound of the array along that', &
'  codimension.', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  CO_UBOUND(3), LBOUND(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           co_lbound(3fortran)', &
'']

shortname="co_lbound"
call process()


case('52','co_max')

textblock=[character(len=256) :: &
'', &
'co_max(3fortran)                                              co_max(3fortran)', &
'', &
'NAME', &
'  CO_MAX(3) - [COLLECTIVE] Maximal value on the current set of images', &
'', &
'SYNTAX', &
'  call co_max(a, result_image, stat, errmsg)', &
'', &
'DESCRIPTION', &
'  co_max determines element-wise the maximal value of A on all images of the', &
'  current team. If result_image is present, the maximum values are returned in', &
'  A on the specified image only and the value of A on the other images become', &
'  undefined. If result_image is not present, the value is returned on all', &
'  images. If the execution was successful and STAT is present, it is assigned', &
'  the value zero. If the execution failed, STAT gets assigned a nonzero value', &
'  and, if present, ERRMSG gets assigned a value describing the occurred error.', &
'', &
'ARGUMENTS', &
'  o  A : shall be an integer, real or character variable, which has the same', &
'     type and type parameters on all images of the team.', &
'', &
'  o  RESULT_IMAGE : (optional) a scalar integer expression; if present, it', &
'     shall have the same the same value on all images and refer to an image of', &
'     the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_max', &
'      implicit none', &
'      integer :: val', &
'         val = this_image()', &
'         call co_max(val, result_image=1)', &
'         if (this_image() == 1) then', &
'           write(*,*) "Maximal value", val  ! prints num_images()', &
'         endif', &
'      end program demo_co_max', &
'', &
'  Results:', &
'', &
'          Maximal value           2', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  CO_MIN(3), CO_SUM(3), CO_REDUCE(3), CO_BROADCAST(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              co_max(3fortran)', &
'']

shortname="co_max"
call process()


case('53','co_min')

textblock=[character(len=256) :: &
'', &
'co_min(3fortran)                                              co_min(3fortran)', &
'', &
'NAME', &
'  CO_MIN(3) - [COLLECTIVE] Minimal value on the current set of images', &
'', &
'SYNTAX', &
'  call co_min(a, result_image, stat, errmsg)', &
'', &
'DESCRIPTION', &
'  co_min determines element-wise the minimal value of A on all images of the', &
'  current team. If result_image is present, the minimal values are returned in', &
'  A on the specified image only and the value of A on the other images become', &
'  undefined. If result_image is not present, the value is returned on all', &
'  images. If the execution was successful and STAT is present, it is assigned', &
'  the value zero. If the execution failed, STAT gets assigned a nonzero value', &
'  and, if present, ERRMSG gets assigned a value describing the occurred error.', &
'', &
'ARGUMENTS', &
'  o  A : shall be an integer, real or character variable, which has the same', &
'     type and type parameters on all images of the team.', &
'', &
'  o  RESULT_IMAGE : (optional) a scalar integer expression; if present, it', &
'     shall have the same the same value on all images and refer to an image of', &
'     the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_min', &
'      implicit none', &
'      integer :: val', &
'         val = this_image()', &
'         call co_min(val, result_image=1)', &
'         if (this_image() == 1) then', &
'           write(*,*) "Minimal value", val  ! prints 1', &
'         endif', &
'      end program demo_co_min', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  CO_MAX(3), CO_SUM(3), CO_REDUCE(3), CO_BROADCAST(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              co_min(3fortran)', &
'']

shortname="co_min"
call process()


case('54','command_argument_count')

textblock=[character(len=256) :: &
'', &
'command_argument_count(3fortran)              command_argument_count(3fortran)', &
'', &
'NAME', &
'  COMMAND_ARGUMENT_COUNT(3) - [SYSTEM:COMMAND LINE] Get number of command line', &
'  arguments', &
'', &
'SYNTAX', &
'  result = command_argument_count()', &
'', &
'           integer function command_argument_count() result(count)', &
'           integer :: count', &
'', &
'DESCRIPTION', &
'  COMMAND_ARGUMENT_COUNT() returns the number of arguments passed on the', &
'  command line when the containing program was invoked.', &
'', &
'ARGUMENTS', &
'  None', &
'', &
'RETURNS', &
'  o  COUNT : The return value is of type default integer. It is the number of', &
'     arguments passed on the command line when the program was invoked.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_command_argument_count', &
'      implicit none', &
'      integer :: count', &
'         count = command_argument_count()', &
'         print *, count', &
'      end program demo_command_argument_count', &
'', &
'  Sample output:', &
'', &
'         # the command verb does not count', &
'         ./test_command_argument_count', &
'             0', &
'         # quoted strings may count as one argument', &
'         ./test_command_argument_count count arguments', &
'             2', &
'         ./test_command_argument_count ''count arguments''', &
'             1', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  GET_COMMAND(3), GET_COMMAND_ARGUMENT(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 20command_argument_count(3fortran)', &
'']

shortname="command_argument_count"
call process()


case('55','compiler_options')

textblock=[character(len=256) :: &
'', &
'compiler_options(3fortran)                          compiler_options(3fortran)', &
'', &
'NAME', &
'  COMPILER_OPTIONS(3) - [COMPILER INQUIRY] Options passed to the compiler', &
'', &
'SYNTAX', &
'  str = compiler_options()', &
'', &
'DESCRIPTION', &
'  compiler_options returns a string with the options used for compiling.', &
'', &
'ARGUMENTS', &
'  None.', &
'', &
'RETURNS', &
'  The return value is a default-kind string with system-dependent length.  It', &
'  contains the compiler flags used to compile the file, which called the', &
'  compiler_options intrinsic.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_options', &
'      implicit none', &
'         print ''(4a)'', &', &
'            ''This file was compiled by '', &', &
'            compiler_version(),           &', &
'            '' using the options '',        &', &
'            compiler_options()', &
'      end program demo_compiler_version', &
'', &
'  Results:', &
'', &
'         This file was compiled by GCC version 5.4.0 using the options', &
'         -I /usr/include/w32api -I /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN', &
'         -mtune=generic -march=x86-64 -g -Wunused -Wuninitialized -Wall', &
'         -std=f2008 -fbounds-check -fbacktrace -finit-real=nan', &
'         -fno-range-check -frecord-marker=4', &
'         -J /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  COMPILER_VERSION(3), ISO_FORTRAN_ENV(7)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022    compiler_options(3fortran)', &
'']

shortname="compiler_options"
call process()


case('56','compiler_version')

textblock=[character(len=256) :: &
'', &
'compiler_version(3fortran)                          compiler_version(3fortran)', &
'', &
'NAME', &
'  COMPILER_VERSION(3) - [COMPILER INQUIRY] Compiler version string', &
'', &
'SYNTAX', &
'  str = compiler_version()', &
'', &
'DESCRIPTION', &
'  COMPILER_VERSION(3) returns a string containing the name and version of the', &
'  compiler.', &
'', &
'ARGUMENTS', &
'  None.', &
'', &
'RETURNS', &
'  The return value is a default-kind string with system-dependent length.  It', &
'  contains the name of the compiler and its version number.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_options', &
'      implicit none', &
'         print ''(4a)'', &', &
'            ''This file was compiled by '', &', &
'            compiler_version(),           &', &
'            '' using the options '',        &', &
'            compiler_options()', &
'      end program demo_compiler_version', &
'', &
'  Results:', &
'', &
'         This file was compiled by GCC version 5.4.0 using the options', &
'         -I /usr/include/w32api -I /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN', &
'         -mtune=generic -march=x86-64 -g -Wunused -Wuninitialized -Wall', &
'         -std=f2008 -fbounds-check -fbacktrace -finit-real=nan', &
'         -fno-range-check -frecord-marker=4', &
'         -J /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  COMPILER_OPTIONS(3), ISO_FORTRAN_ENV(7)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022    compiler_version(3fortran)', &
'']

shortname="compiler_version"
call process()


case('57','conjg')

textblock=[character(len=256) :: &
'', &
'conjg(3fortran)                                                conjg(3fortran)', &
'', &
'NAME', &
'  CONJG(3) - [NUMERIC] Complex conjugate of a complex value', &
'', &
'SYNTAX', &
'  z = conjg(z)', &
'', &
'         complex(kind=K) elemental function conjg(z)', &
'         complex(kind=K),intent(in) :: z', &
'', &
'  where K is the kind of the parameter Z', &
'', &
'DESCRIPTION', &
'  CONJG(Z) returns the complex conjugate of the complex value Z.', &
'', &
'  In mathematics, the complex conjugate of a complex_ number is the number', &
'  with an equal real part and an imaginary part equal in magnitude but', &
'  opposite in sign.', &
'', &
'  That is, If Z is (X, Y) then the result is (X, -Y).', &
'', &
'  For matrices of complex numbers, CONJG(ARRAY) represents the element-by-', &
'  element conjugation of ARRAY; not the conjugate transpose of ARRAY .', &
'', &
'ARGUMENTS', &
'  o  Z : The type shall be complex.', &
'', &
'RETURNS', &
'  The return value is of type complex.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_conjg', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'      implicit none', &
'      complex :: z = (2.0, 3.0)', &
'      complex(kind=real64) :: dz = (   &', &
'         &  1.2345678901234567_real64, &', &
'         & -1.2345678901234567_real64)', &
'      complex :: arr(3,3)', &
'      integer :: i', &
'', &
'          print *, z', &
'          z= conjg(z)', &
'          print *, z', &
'          print *', &
'', &
'          print *, dz', &
'          dz = conjg(dz)', &
'          print *, dz', &
'          print *', &
'', &
'          ! the function is elemental so it can take arrays', &
'          arr(1,:)=[(-1.0, 2.0),( 3.0, 4.0),( 5.0,-6.0)]', &
'          arr(2,:)=[( 7.0,-8.0),( 8.0, 9.0),( 9.0, 9.0)]', &
'          arr(3,:)=[( 1.0, 9.0),( 2.0, 0.0),(-3.0,-7.0)]', &
'', &
'          write(*,*)''original''', &
'          write(*,''(3("(",g8.2,",",g8.2,")",1x))'')(arr(i,:),i=1,3)', &
'          arr = conjg(arr)', &
'          write(*,*)''conjugate''', &
'          write(*,''(3("(",g8.2,",",g8.2,")",1x))'')(arr(i,:),i=1,3)', &
'', &
'      end program demo_conjg', &
'', &
'  Results:', &
'', &
'       (2.000000,3.000000)', &
'       (2.000000,-3.000000)', &
'', &
'       (1.23456789012346,-1.23456789012346)', &
'       (1.23456789012346,1.23456789012346)', &
'', &
'       original', &
'', &
'    (-1.0', &
'      , 2.0    ) ( 3.0    , 4.0    ) ( 5.0    ,-6.0    )', &
'', &
'    ( 7.0', &
'      ,-8.0    ) ( 8.0    , 9.0    ) ( 9.0    , 9.0    )', &
'', &
'    ( 1.0', &
'      , 9.0    ) ( 2.0    , 0.0    ) (-3.0    ,-7.0    )', &
'', &
'         conjugate', &
'', &
'    (-1.0', &
'      ,-2.0    ) ( 3.0    ,-4.0    ) ( 5.0    , 6.0    )', &
'', &
'    ( 7.0', &
'      , 8.0    ) ( 8.0    ,-9.0    ) ( 9.0    ,-9.0    )', &
'', &
'    ( 1.0', &
'      ,-9.0    ) ( 2.0    , 0.0    ) (-3.0    , 7.0    )', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               conjg(3fortran)', &
'']

shortname="conjg"
call process()


case('58','co_reduce')

textblock=[character(len=256) :: &
'', &
'co_reduce(3fortran)                                        co_reduce(3fortran)', &
'', &
'NAME', &
'  CO_REDUCE(3) - [COLLECTIVE] Reduction of values on the current set of images', &
'', &
'SYNTAX', &
'  call co_reduce(a, operation, result_image, stat, errmsg)', &
'', &
'DESCRIPTION', &
'  co_reduce determines element-wise the reduction of the value of A on all', &
'  images of the current team. The pure function passed as OPERATION is used to', &
'  pairwise reduce the values of A by passing either the value of A of', &
'  different images or the result values of such a reduction as argument. If A', &
'  is an array, the reduction is done element wise. If result_image is present,', &
'  the result values are returned in A on the specified image only and the', &
'  value of A on the other images become undefined. If result_image is not', &
'  present, the value is returned on all images. If the execution was', &
'  successful and STAT is present, it is assigned the value zero. If the', &
'  execution failed, STAT gets assigned a nonzero value and, if present, ERRMSG', &
'  gets assigned a value describing the occurred error.', &
'', &
'ARGUMENTS', &
'  o  A : is an INTENT(INOUT) argument and shall be nonpolymorphic. If it is', &
'     allocatable, it shall be allocated; if it is a pointer, it shall be', &
'     associated. A shall have the same type and type parameters on all images', &
'     of the team; if it is an array, it shall have the same shape on all', &
'     images.', &
'', &
'  o  OPERATION : pure function with two scalar nonallocatable arguments, which', &
'     shall be nonpolymorphic and have the same type and type parameters as A.', &
'     The function shall return a nonallocatable scalar of the same type and', &
'     type parameters as A. The function shall be the same on all images and', &
'     with regards to the arguments mathematically commutative and associative.', &
'     Note that OPERATION may not be an elemental unless it is an intrinsic', &
'     function.', &
'', &
'  o  RESULT_IMAGE', &
'', &
'      : (optional) a scalar integer expression; if present, it shall have', &
'      the same the same value on all images and refer to an image of the', &
'      current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_reduce', &
'      implicit none', &
'      integer :: val', &
'', &
'         val = this_image()', &
'         call co_reduce(val, myprod, 1)', &
'         if (this_image() == 1) then', &
'            write(*,*) "Product value", val  ! prints num_images() factorial', &
'         endif', &
'', &
'      contains', &
'', &
'      pure function myprod(a, b)', &
'         integer, value :: a, b', &
'         integer :: myprod', &
'         myprod = a * b', &
'      end function myprod', &
'', &
'      end program demo_co_reduce', &
'', &
'NOTE', &
'  While the rules permit in principle an intrinsic function, none of the', &
'  intrinsics in the standard fulfill the criteria of having a specific', &
'  function, which takes two arguments of the same type and returning that type', &
'  as a result.', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  CO_MIN(3), CO_MAX(3), CO_SUM(3), CO_BROADCAST(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           co_reduce(3fortran)', &
'']

shortname="co_reduce"
call process()


case('59','cos')

textblock=[character(len=256) :: &
'', &
'cos(3fortran)                                                    cos(3fortran)', &
'', &
'NAME', &
'  COS(3) - [MATHEMATICS:TRIGONOMETRIC] Cosine function', &
'', &
'SYNTAX', &
'  result = cos(x)', &
'', &
'         TYPE(kind=KIND),elemental :: cos', &
'         TYPE(kind=KIND,intent(in) :: x', &
'', &
'  where TYPE may be real or complex and KIND may be any KIND supported by the', &
'  associated type.', &
'', &
'DESCRIPTION', &
'  COS(X) computes the cosine of an angle X given the size of the angle in', &
'  radians.', &
'', &
'  The cosine of a real value is the ratio of the adjacent side to the', &
'  hypotenuse of a right-angled triangle.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex. X is assumed to be in radians.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as X.', &
'', &
'  If X is of the type real, the return value lies in the range -1 <= COS(X) <=', &
'  1 .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cos', &
'      implicit none', &
'      doubleprecision,parameter :: PI=atan(1.0d0)*4.0d0', &
'         write(*,*)''COS(0.0)='',cos(0.0)', &
'         write(*,*)''COS(PI)='',cos(PI)', &
'         write(*,*)''COS(PI/2.0d0)='',cos(PI/2.0d0),'' EPSILON='',epsilon(PI)', &
'         write(*,*)''COS(2*PI)='',cos(2*PI)', &
'         write(*,*)''COS(-2*PI)='',cos(-2*PI)', &
'         write(*,*)''COS(-2000*PI)='',cos(-2000*PI)', &
'         write(*,*)''COS(3000*PI)='',cos(3000*PI)', &
'      end program demo_cos', &
'', &
'  Results:', &
'', &
'         COS(0.0)=        1.00000000', &
'         COS(PI)=        -1.0000000000000000', &
'         COS(PI/2.0d0)=   6.1232339957367660E-017', &
'         EPSILON=         2.2204460492503131E-016', &
'         COS(2*PI)=       1.0000000000000000', &
'         COS(-2*PI)=      1.0000000000000000', &
'         COS(-2000*PI)=   1.0000000000000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:sine and cosine', &
'', &
'  ACOS(3), SIN(3), TAN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 cos(3fortran)', &
'']

shortname="cos"
call process()


case('60','cosh')

textblock=[character(len=256) :: &
'', &
'cosh(3fortran)                                                  cosh(3fortran)', &
'', &
'NAME', &
'  COSH(3) - [MATHEMATICS:TRIGONOMETRIC] Hyperbolic cosine function', &
'', &
'SYNTAX', &
'  result = cosh(x)', &
'', &
'           TYPE(kind=KIND) elemental function cosh(x)', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'  where TYPE may be real or complex and KIND may be any supported kind for the', &
'  associated type. The returned VALUE will be the same type and kind as the', &
'  input value X.', &
'', &
'DESCRIPTION', &
'  COSH(X) computes the hyperbolic cosine of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value has same type and kind as X. If X is complex, the imaginary', &
'  part of the result is in radians.', &
'', &
'  If X is real, the return value has a lower bound of one, COSH(X) >= 1.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cosh', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'       & real_kinds, real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'          x = cosh(x)', &
'      end program demo_cosh', &
'', &
'STANDARD', &
'  FORTRAN 77 and later, for a complex argument - Fortran 2008 or later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Inverse function: ACOSH(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                cosh(3fortran)', &
'']

shortname="cosh"
call process()


case('61','co_sum')

textblock=[character(len=256) :: &
'', &
'co_sum(3fortran)                                              co_sum(3fortran)', &
'', &
'NAME', &
'  CO_SUM(3) - [COLLECTIVE] Sum of values on the current set of images', &
'', &
'SYNTAX', &
'  call co_sum(a, result_image, stat, errmsg)', &
'', &
'DESCRIPTION', &
'  co_sum sums up the values of each element of A on all images of the current', &
'  team. If result_image is present, the summed-up values are returned in A on', &
'  the specified image only and the value of A on the other images become', &
'  undefined. If result_image is not present, the value is returned on all', &
'  images. If the execution was successful and STAT is present, it is assigned', &
'  the value zero. If the execution failed, STAT gets assigned a nonzero value', &
'  and, if present, ERRMSG gets assigned a value describing the occurred error.', &
'', &
'ARGUMENTS', &
'  o  A : shall be an integer, real or complex variable, which has the same', &
'     type and type parameters on all images of the team.', &
'', &
'  o  RESULT_IMAGE : (optional) a scalar integer expression; if present, it', &
'     shall have the same the same value on all images and refer to an image of', &
'     the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_sum', &
'      implicit none', &
'      integer :: val', &
'         val = this_image()', &
'         call co_sum(val, result_image=1)', &
'         if (this_image() == 1) then', &
'            ! prints (n**2 + n)/2, with n = num_images()', &
'            write(*,*) "The sum is ", val', &
'         endif', &
'      end program demo_co_sum', &
'', &
'  Results:', &
'', &
'          The sum is            1', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'SEE ALSO', &
'  CO_MAX(3), CO_MIN(3), CO_REDUCE(3), CO_BROADCAST(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              co_sum(3fortran)', &
'']

shortname="co_sum"
call process()


case('62','co_ubound')

textblock=[character(len=256) :: &
'', &
'co_ubound(3fortran)                                        co_ubound(3fortran)', &
'', &
'NAME', &
'  CO_UBOUND(3) - [COLLECTIVE] Upper codimension bounds of an array', &
'', &
'SYNTAX', &
'  result = co_ubound(coarray, dim, kind)', &
'', &
'DESCRIPTION', &
'  Returns the upper cobounds of a coarray, or a single upper cobound along the', &
'  DIM codimension.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an coarray, of any type.', &
'', &
'  o  DIM : (Optional) Shall be a scalar integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is absent, the result is an', &
'  array of the lower cobounds of COARRAY. If DIM is present, the result is a', &
'  scalar corresponding to the lower cobound of the array along that', &
'  codimension.', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  CO_LBOUND(3), LBOUND(3), UBOUND(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           co_ubound(3fortran)', &
'']

shortname="co_ubound"
call process()


case('63','count')

textblock=[character(len=256) :: &
'', &
'count(3fortran)                                                count(3fortran)', &
'', &
'NAME', &
'  COUNT(3) - [ARRAY REDUCTION] Count function', &
'', &
'SYNTAX', &
'  result = count(mask, dim, kind)', &
'', &
'DESCRIPTION', &
'  Counts the number of .true. elements in a logical MASK, or, if the DIM', &
'  argument is supplied, counts the number of elements along each row of the', &
'  array in the DIM direction. If the array has zero size, or all of the', &
'  elements of MASK are false, then the result is 0.', &
'', &
'ARGUMENTS', &
'  o  MASK : The type shall be logical.', &
'', &
'  o  DIM : (Optional) The type shall be integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is present, the result is an', &
'  array with a rank one less than the rank of ARRAY, and a size corresponding', &
'  to the shape of ARRAY with the DIM dimension removed.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_count', &
'      implicit none', &
'      integer, dimension(2,3) :: a, b', &
'      logical, dimension(2,3) :: mymask', &
'            a = reshape( [ 1, 2, 3, 4, 5, 6 ], [ 2, 3 ])', &
'            b = reshape( [ 0, 7, 3, 4, 5, 8 ], [ 2, 3 ])', &
'            print ''(3i3)'', a(1,:)', &
'            print ''(3i3)'', a(2,:)', &
'            print *', &
'            print ''(3i3)'', b(1,:)', &
'            print ''(3i3)'', b(2,:)', &
'            print *', &
'            mymask = a.ne.b', &
'            print ''(3l3)'', mymask(1,:)', &
'            print ''(3l3)'', mymask(2,:)', &
'            print *', &
'            print ''(3i3)'', count(mymask)', &
'            print *', &
'            print ''(3i3)'', count(mymask, 1)', &
'            print *', &
'            print ''(3i3)'', count(mymask, 2)', &
'      end program demo_count', &
'', &
'  Expected Results:', &
'', &
'    1 3  5', &
'', &
'    2 4  6', &
'', &
'    0 3  5', &
'', &
'    7 4  8', &
'', &
'   T F F', &
'   T F T', &
'  3', &
'', &
'  2 0  1', &
'', &
'  1', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument - Fortran 2003 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               count(3fortran)', &
'']

shortname="count"
call process()


case('64','cpu_time')

textblock=[character(len=256) :: &
'', &
'cpu_time(3fortran)                                          cpu_time(3fortran)', &
'', &
'NAME', &
'  CPU_TIME(3) - [SYSTEM:TIME] return CPU processor time in seconds', &
'', &
'SYNTAX', &
'  call cpu_time(time) real,intent(out) :: time', &
'', &
'DESCRIPTION', &
'  Returns a real value representing the elapsed CPU time in seconds. This is', &
'  useful for testing segments of code to determine execution time.', &
'', &
'  The exact definition of time is left imprecise because of the variability in', &
'  what different processors are able to provide.', &
'', &
'  If no time source is available, TIME is set to a negative value.', &
'', &
'  Note that TIME may contain a system dependent, arbitrary offset and may not', &
'  start with 0.0. For cpu_time the absolute value is meaningless. Only', &
'  differences between subsequent calls, as shown in the example below, should', &
'  be used.', &
'', &
'  A processor for which a single result is inadequate (for example, a parallel', &
'  processor) might choose to provide an additional version for which time is', &
'  an array.', &
'', &
'RETURNS', &
'  o  TIME : The type shall be real with INTENT(OUT). It is assigned a', &
'     processor-dependent approximation to the processor time in seconds.  If', &
'     the processor cannot return a meaningful time, a processor-dependent', &
'     negative value is returned.', &
'', &
'     : The start time is left imprecise because the purpose is to time', &
'     sections of code, as in the example. This might or might not include', &
'     system overhead time.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cpu_time', &
'      implicit none', &
'      real :: start, finish', &
'         !', &
'         call cpu_time(start)', &
'         ! put code to test here', &
'         call cpu_time(finish)', &
'         !', &
'         ! writes processor time taken by the piece of code.', &
'         print ''("Processor Time = ",f6.3," seconds.")'',finish-start', &
'      end program demo_cpu_time', &
'', &
'  Results:', &
'', &
'         Processor Time =  0.000 seconds.', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  SYSTEM_CLOCK(3), DATE_AND_TIME(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022            cpu_time(3fortran)', &
'']

shortname="cpu_time"
call process()


case('65','cshift')

textblock=[character(len=256) :: &
'', &
'cshift(3fortran)                                              cshift(3fortran)', &
'', &
'NAME', &
'  CSHIFT(3) - [TRANSFORMATIONAL] Circular shift elements of an array', &
'', &
'SYNTAX', &
'  type(TYPE, kind=KIND) function cshift(array, shift, dim )', &
'', &
'         type(TYPE,kind=KIND),intent(in) :: array(..)', &
'         integer(kind=IKIND),intent(in)  :: shift', &
'         integer(kind=IKIND),intent(in)  :: dim', &
'', &
'  where ARRAY may be any type and rank (and the result will automatically be', &
'  of the same type, kind and rank as ARRAY).', &
'', &
'  The kind of SHIFT and DIM may differ and be any supported value.', &
'', &
'DESCRIPTION', &
'  CSHIFT(ARRAY, SHIFT [, DIM]) performs a circular shift on elements of ARRAY', &
'  along the dimension of DIM. If DIM is omitted it is taken to be 1.  DIM is a', &
'  scalar of type integer in the range of 1 <= DIM <= N, where "n" is the rank', &
'  of ARRAY.', &
'', &
'  If the rank of ARRAY is one, then all elements of ARRAY are shifted by SHIFT', &
'  places. If rank is greater than one, then all complete rank one sections of', &
'  ARRAY along the given dimension are shifted. Elements shifted out one end of', &
'  each rank one section are shifted back in the other end.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of any type.', &
'', &
'  o  SHIFT : The type shall be integer.', &
'', &
'  o  DIM : The type shall be integer.', &
'', &
'RETURNS', &
'  Returns an array of same type and rank as the ARRAY argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cshift', &
'      implicit none', &
'      integer, dimension(3,3) :: a', &
'          a = reshape( [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3, 3 ])', &
'          print ''(3i3)'', a(1,:)', &
'          print ''(3i3)'', a(2,:)', &
'          print ''(3i3)'', a(3,:)', &
'          a = cshift(a, SHIFT=[1, 2, -1], DIM=2)', &
'          print *', &
'          print ''(3i3)'', a(1,:)', &
'          print ''(3i3)'', a(2,:)', &
'          print ''(3i3)'', a(3,:)', &
'      end program demo_cshift', &
'', &
'  Results:', &
'', &
'    1 4  7', &
'', &
'    2 5  8', &
'', &
'    3 6  9', &
'', &
'    4 7  1', &
'', &
'    8 2  5', &
'', &
'    9 3  6', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              cshift(3fortran)', &
'']

shortname="cshift"
call process()


case('66','c_sizeof')

textblock=[character(len=256) :: &
'', &
'c_sizeof(3fortran)                                          c_sizeof(3fortran)', &
'', &
'NAME', &
'  C_SIZEOF(3) - [ISO_C_BINDING] Size in bytes of an expression', &
'', &
'SYNTAX', &
'  n = c_sizeof(x)', &
'', &
'DESCRIPTION', &
'  C_SIZEOF(X) calculates the number of bytes of storage the expression X', &
'  occupies.', &
'', &
'ARGUMENTS', &
'  o  X : The argument shall be an interoperable data entity.', &
'', &
'RETURNS', &
'  The return value is of type integer and of the system-dependent kind csize_t', &
'  (from the _iso_c_binding module). Its value is the number of bytes occupied', &
'  by the argument. If the argument has the pointer attribute, the number of', &
'  bytes of the storage area pointed to is returned. If the argument is of a', &
'  derived type with pointer or allocatable components, the return value does', &
'  not account for the sizes of the data pointed to by these components.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_sizeof', &
'      use iso_c_binding', &
'      implicit none', &
'      real(c_float) :: r, s(5)', &
'         print *, (c_sizeof(s)/c_sizeof(r) == 5)', &
'      end program demo_c_sizeof', &
'', &
'  Results:', &
'', &
'   T', &
'  The example will print .true. unless you are using a platform where default', &
'  real variables are unusually padded.', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  STORAGE_SIZE(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022            c_sizeof(3fortran)', &
'']

shortname="c_sizeof"
call process()


case('67','date_and_time')

textblock=[character(len=256) :: &
'', &
'date_and_time(3fortran)                                date_and_time(3fortran)', &
'', &
'NAME', &
'  DATE_AND_TIME(3) - [SYSTEM:TIME] gets current time', &
'', &
'SYNTAX', &
'  subroutine date_and_time(date, time, zone, values)', &
'', &
'           character(len=8),intent(out),optional :: date', &
'           character(len=10),intent(out),optional :: time', &
'           character(len=5),intent(out),optional :: zone', &
'           integer,intent(out),optional :: values(8)', &
'', &
'DESCRIPTION', &
'  DATE_AND_TIME(DATE, TIME, ZONE, VALUES) gets the corresponding date and time', &
'  information from the real-time system clock.', &
'', &
'  Unavailable time and date character parameters return blanks.', &
'', &
'ARGUMENTS', &
'  o  DATE : A character string of default kind of the form CCYYMMDD, of length', &
'     8 or larger.', &
'', &
'  o  TIME : A character string of default kind of the form HHMMSS.SSS, of', &
'     length 10 or larger.', &
'', &
'  o  ZONE : A character string of default kind of the form (+-)HHMM, of length', &
'     5 or larger, representing the difference with respect to Coordinated', &
'     Universal Time (UTC).', &
'', &
'  o  VALUES : An integer array of eight elements that contains:', &
'', &
'     o  VALUES(1) : The year', &
'', &
'     o  VALUES(2) : The month', &
'', &
'     o  VALUES(3) : The day of the month', &
'', &
'     o  VALUES(4) : Time difference with UTC in minutes', &
'', &
'     o  VALUES(5) : The hour of the day', &
'', &
'     o  VALUES(6) : The minutes of the hour', &
'', &
'     o  VALUES(7) : The seconds of the minute', &
'', &
'     o  VALUES(8) : The milliseconds of the second', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_date_and_time', &
'      implicit none', &
'      character(len=8)     :: date', &
'      character(len=10)    :: time', &
'      character(len=5)     :: zone', &
'      integer,dimension(8) :: values', &
'', &
'          call date_and_time(date,time,zone,values)', &
'', &
'          ! using keyword arguments', &
'          call date_and_time(DATE=date,TIME=time,ZONE=zone)', &
'          print ''(*(g0))'',''DATE="'',date,''" TIME="'',time,''" ZONE="'',zone,''"''', &
'', &
'          call date_and_time(VALUES=values)', &
'          write(*,''(i5,a)'') &', &
'           & values(1),'' - The year'', &', &
'           & values(2),'' - The month'', &', &
'           & values(3),'' - The day of the month'', &', &
'           & values(4),'' - Time difference with UTC in minutes'', &', &
'           & values(5),'' - The hour of the day'', &', &
'           & values(6),'' - The minutes of the hour'', &', &
'           & values(7),'' - The seconds of the minute'', &', &
'           & values(8),'' - The milliseconds of the second''', &
'      end program demo_date_and_time', &
'', &
'  Results:', &
'', &
'         DATE="20201222" TIME="165738.779" ZONE="-0500"', &
'          2020 - The year', &
'            12 - The month', &
'            22 - The day of the month', &
'          -300 - Time difference with UTC in minutes', &
'            16 - The hour of the day', &
'            57 - The minutes of the hour', &
'            38 - The seconds of the minute', &
'           779 - The milliseconds of the second', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  CPU_TIME(3), SYSTEM_CLOCK(3)', &
'', &
'RESOURCES', &
'  date and time conversion, formatting and computation', &
'', &
'  o  M_time', &
'', &
'  o  datetime', &
'', &
'  o  datetime-fortran', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022       date_and_time(3fortran)', &
'']

shortname="date_and_time"
call process()


case('68','dble')

textblock=[character(len=256) :: &
'', &
'dble(3fortran)                                                  dble(3fortran)', &
'', &
'NAME', &
'  DBLE(3) - [TYPE:NUMERIC] Double conversion function', &
'', &
'SYNTAX', &
'  result = dble(a)', &
'', &
'          elemental function dble(a)', &
'          type(real(kind=kind(0.0d0)))     :: dble', &
'          type(TYPE(kind=KIND)),intent(in) :: a', &
'', &
'  where TYPE may be integer, real, or complex and KIND any kind supported by', &
'  the TYPE.', &
'', &
'DESCRIPTION', &
'  DBLE(A) Converts A to double precision real type.', &
'', &
'ARGUMENTS', &
'  o  A : The type shall be integer, real, or complex.', &
'', &
'RETURNS', &
'  The return value is of type doubleprecision. For complex input, the returned', &
'  value has the magnitude and sign of the real component of the input value.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dble', &
'      implicit none', &
'      real:: x = 2.18', &
'      integer :: i = 5', &
'      complex :: z = (2.3,1.14)', &
'         print *, dble(x), dble(i), dble(z)', &
'      end program demo_dble', &
'', &
'  Results:', &
'', &
'        2.1800000667572021  5.0000000000000000   2.2999999523162842', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  FLOAT(3), REAL(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                dble(3fortran)', &
'']

shortname="dble"
call process()


case('69','digits')

textblock=[character(len=256) :: &
'', &
'digits(3fortran)                                              digits(3fortran)', &
'', &
'NAME', &
'  DIGITS(3) - [NUMERIC MODEL] Significant digits function', &
'', &
'SYNTAX', &
'  result = digits(x) function digits(x)', &
'', &
'    type(integer(kind=kind(0)))', &
'      :: digits type(TYPE(kind=KIND)),intent(in) :: x(..)', &
'', &
'  where TYPE may be integer or real and KIND is any kind supported by TYPE.', &
'', &
'DESCRIPTION', &
'  DIGITS(X) returns the number of significant digits of the internal model', &
'  representation of X. For example, on a system using a 32-bit floating point', &
'  representation, a default real number would likely return 24.', &
'', &
'ARGUMENTS', &
'  o  X : The type may be a scalar or array of type integer or real.', &
'', &
'RETURNS', &
'  The return value is of type integer of default kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_digits', &
'      implicit none', &
'      integer :: i = 12345', &
'      real :: x = 3.143', &
'      doubleprecision :: y = 2.33d0', &
'         print *,''default integer:'', digits(i)', &
'         print *,''default real:   '', digits(x)', &
'         print *,''default doubleprecision:'', digits(y)', &
'      end program demo_digits', &
'', &
'  Typical Results:', &
'', &
'          default integer:                  31', &
'          default real:                     24', &
'          default doubleprecision:          53', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              digits(3fortran)', &
'']

shortname="digits"
call process()


case('70','dim')

textblock=[character(len=256) :: &
'', &
'dim(3fortran)                                                    dim(3fortran)', &
'', &
'NAME', &
'  DIM(3) - [NUMERIC] Positive difference', &
'', &
'SYNTAX', &
'  result = dim(x, y)', &
'', &
'          elemental function dim(x, y)', &
'          type(TYPE(kind=KIND))            :: dim', &
'          type(TYPE(kind=KIND)),intent(in) :: x, y', &
'', &
'  where TYPE may be real or integer and KIND is any supported kind for the', &
'  type.', &
'', &
'DESCRIPTION', &
'  DIM(X,Y) returns the difference X - Y if the result is positive; otherwise', &
'  it returns zero.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be integer or real', &
'', &
'  o  Y : The type shall be the same type and kind as X.', &
'', &
'RETURNS', &
'  The return value is the same type and kind as the input arguments X and Y.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dim', &
'      use, intrinsic :: iso_fortran_env, only : real64', &
'      implicit none', &
'      integer           :: i', &
'      real(kind=real64) :: x', &
'          i = dim(4, 15)', &
'          x = dim(4.321_real64, 1.111_real64)', &
'          print *, i', &
'          print *, x', &
'          ! elemental', &
'          print *, dim([1,2,3],2)', &
'          print *, dim([1,2,3],[3,2,1])', &
'          print *, dim(-10,[0,-10,-20])', &
'      end program demo_dim', &
'', &
'  Results:', &
'', &
'    0 3.21000000000000', &
'', &
'    0 0           1', &
'', &
'    0 0           2', &
'', &
'    0 0          10', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 dim(3fortran)', &
'']

shortname="dim"
call process()


case('71','dot_product')

textblock=[character(len=256) :: &
'', &
'dot_product(3fortran)                                    dot_product(3fortran)', &
'', &
'NAME', &
'  DOT_PRODUCT(3) - [TRANSFORMATIONAL] Dot product function', &
'', &
'SYNTAX', &
'  result = dot_product(vector_a, vector_b)', &
'', &
'DESCRIPTION', &
'  DOT_PRODUCT(VECTOR_A, VECTOR_B) computes the dot product multiplication of', &
'  two vectors vectora and vector_b. The two vectors may be either numeric or', &
'  logical and must be arrays of rank one and of equal size. If the vectors are', &
'  _integer or real, the result is SUM(VECTOR_A*VECTOR_B).  If the vectors are', &
'  complex, the result is SUM(CONJG(VECTOR_A)*VECTOR_B).  If the vectors are', &
'  logical, the result is ANY(VECTOR_A .AND. VECTOR_B).', &
'', &
'ARGUMENTS', &
'  o  VECTOR_A : The type shall be numeric or logical, rank 1.', &
'', &
'  o  VECTOR_B : The type shall be numeric if vectora is of numeric type or', &
'     _logical if vectora is of type _logical. vector_b shall be a rank-one', &
'     array.', &
'', &
'RETURNS', &
'  If the arguments are numeric, the return value is a scalar of numeric type,', &
'  integer, real, or complex. If the arguments are logical, the return value is', &
'  .true. or .false..', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dot_prod', &
'      implicit none', &
'          integer, dimension(3) :: a, b', &
'          a = [ 1, 2, 3 ]', &
'          b = [ 4, 5, 6 ]', &
'          print ''(3i3)'', a', &
'          print *', &
'          print ''(3i3)'', b', &
'          print *', &
'          print *, dot_product(a,b)', &
'      end program demo_dot_prod', &
'', &
'  Results:', &
'', &
'    1 2  3', &
'', &
'    4 5  6', &
'', &
'                     32', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         dot_product(3fortran)', &
'']

shortname="dot_product"
call process()


case('72','dprod')

textblock=[character(len=256) :: &
'', &
'dprod(3fortran)                                                dprod(3fortran)', &
'', &
'NAME', &
'  DPROD(3) - [NUMERIC] Double precision real product', &
'', &
'SYNTAX', &
'  elemental function dprod(x,y)', &
'', &
'          real,intent(in) :: x', &
'          real,intent(in) :: y', &
'          doubleprecision :: dprod', &
'', &
'DESCRIPTION', &
'  DPROD(X,Y) produces a doubleprecision product of default real values X and', &
'  Y.', &
'', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  product of X and Y. It is recommended that the processor compute the product', &
'  in double precision, rather than in single precision then converted to', &
'  double precision.', &
'', &
'ARGUMENTS', &
'  o  X : the multiplier, a real value of default kind', &
'', &
'  o  Y : the multiplicand, a real value of default kind. Y Must have the same', &
'     type and kind parameters as X', &
'', &
'  The setting of compiler options specifying the size of a default real can', &
'  affect this function.', &
'', &
'RETURNS', &
'  The return value is doubleprecision (ie. real(kind=kind(0.0d0))). It should', &
'  have the same value as DBLE(X)*DBLE(Y).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dprod', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'      implicit none', &
'      integer,parameter :: dp=kind(0.0d0)', &
'      real :: x = 5.2', &
'      real :: y = 2.3', &
'      real(kind=dp) :: dd', &
'', &
'         ! basic usage', &
'         dd = dprod(x,y)', &
'         print *, ''compare dprod(xy)='',dd, &', &
'         & ''to x*y='',x*y, &', &
'         & ''to dble(x)*dble(y)='',dble(x)*dble(y)', &
'', &
'         ! elemental', &
'         print *, dprod( [2.3,3.4,4.5], 10.0 )', &
'         print *, dprod( [2.3,3.4,4.5], [9.8,7.6,5.4] )', &
'', &
'         ! other interesting comparisons', &
'         print *, ''integer multiplication of digits='',52*23', &
'         print *, 52*23/100.0', &
'         print *, 52*23/100.0d0', &
'', &
'      !> !! A common extension is to take doubleprecision arguments', &
'      !> !! and return higher precision when available', &
'      !> bigger: block', &
'      !> doubleprecision :: xx = 5.2_dp', &
'      !> doubleprecision :: yy = 2.3_dp', &
'      !> print *, ''dprop==>'',dprod(xx,yy)', &
'      !> print *, ''multiply==>'',xx*yy', &
'      !> print *, ''using dble==>'',dble(xx)*dble(yy)', &
'      !> print *, ''kind of arguments is'',kind(xx)', &
'      !> print *, ''kind of result is'',kind(dprod(xx,yy))', &
'      !> endblock bigger', &
'', &
'      end program demo_dprod', &
'', &
'  Results: (this can vary between programming environments):', &
'', &
'          compare dprod(xy)= 11.9599993133545 to x*y= 11.96000', &
'          to dble(x)*dble(y)= 11.9599993133545', &
'            22.9999995231628  34.0000009536743  45.0000000000000', &
'            22.5399999713898  25.8400004005432  24.3000004291534', &
'          integer multiplication of digits=        1196', &
'            11.96000', &
'            11.9600000000000', &
'          dprop==>   11.9599999999999994848565165739273', &
'          multiply==>   11.9600000000000', &
'          using dble==>   11.9600000000000', &
'          kind of arguments is           8', &
'          kind of result is          16', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               dprod(3fortran)', &
'']

shortname="dprod"
call process()


case('73','dshiftl')

textblock=[character(len=256) :: &
'', &
'dshiftl(3fortran)                                            dshiftl(3fortran)', &
'', &
'NAME', &
'  DSHIFTL(3) - [BIT:COPY] combined left shift of the bits of two integers', &
'', &
'SYNTAX', &
'  elemental integer(kind=KIND) function dshiftl(i, j, shift)', &
'', &
'       integer(kind=KIND),intent(in) :: i', &
'       integer(kind=KIND),intent(in) :: j', &
'       integer(kind=KIND2),intent(in) :: shift', &
'', &
'  Where the kind of I, J, and DSHIFTL are the same. An exception is that one', &
'  of I and J may be a BOZ literal constant.', &
'', &
'DESCRIPTION', &
'  DSHIFTL(I, J, SHIFT) combines bits of I and J. Per the standard the', &
'  rightmost SHIFT bits of the result are the leftmost SHIFT bits of J, and the', &
'  remaining bits are the rightmost bits of I.', &
'', &
'  For example, for 32-bit values if SHIFT=6 designating ignored bits with "-"', &
'  and labeling the used bits of I with uppercase letters and used bits of J', &
'  with lowercase letters the result would be ...', &
'', &
'            SHIFT=6', &
'            I =      ------ABCDEFGHIJKLMNOPQRSTUVWXYZ', &
'            J =      abcdef--------------------------', &
'            RESULT = ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef', &
'', &
'  So reading from left to right we skip the first N values of I and use the', &
'  first N values of J and append them together.', &
'', &
'  This is equivalent to', &
'', &
'           ior( shiftl(i, shift), shiftr(j, bit_size(j)-shift) )', &
'', &
'  hence DSHIFTL is designated as a "combined left shift", because it is like', &
'  we appended I and J together, shifted it SHIFT bits to the left, and then', &
'  kept the same number of bits as I or J had. Using the above strings:', &
'', &
'         Combine them together', &
'            ------ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef--------------------------', &
'         Shift 6 to the left', &
'            ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef--------------------------', &
'         keep 32 bits', &
'            ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef', &
'', &
'  Note:', &
'', &
'  Using the last representation of the operation is should be seen that when', &
'  both I and J have the same value as in', &
'', &
'            dshiftl(i, i, shift)', &
'', &
'  the result has the same value as a circular shift:', &
'', &
'            ishftc(i, shift)', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer.', &
'', &
'  o  J : Shall be of type integer, and of the same kind as I.', &
'', &
'      If either I or J is a BOZ-literal-constant, it is rst converted as', &
'      if by the intrinsic function INT() to integer with the kind type', &
'      parameter of the other.', &
'', &
'  o  SHIFT : Shall be of type integer. It shall be nonnegative and less than', &
'     or equal to BIT_SIZE(K) where K is any I or J variable that is type', &
'     integer (ie. the size of either one that is not a BOZ literal constant).', &
'', &
'RETURNS', &
'  The return value has same type and kind as I and/or J.', &
'', &
'  The leftmost SHIFT bits of J are copied to the rightmost bits of the result,', &
'  and the remaining bits are the rightmost bits of I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dshiftl', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: i, j', &
'      integer             :: shift', &
'', &
'        ! basic usage', &
'         write(*,*) dshiftl (1, 2**30, 2) ! int32 values on little-endian => 5', &
'', &
'        ! print some simple calls as binary to better visual the results', &
'         i=-1', &
'         j=0', &
'         shift=5', &
'         call printit()', &
'', &
'         ! the leftmost SHIFT bits of J are copied to the rightmost result bits', &
'         j=b"11111000000000000000000000000000"', &
'         ! and the other bits are the rightmost bits of I', &
'         i=b"00000000000000000000000000000000"', &
'         call printit()', &
'', &
'         j=b"11111000000000000000000000000000"', &
'         i=b"00000111111111111111111111111111"', &
'         ! result should be all 1s', &
'         call printit()', &
'', &
'      contains', &
'      subroutine printit()', &
'         ! print i,j,shift and then i,j, and the result as binary values', &
'          write(*,''(*(g0))'')''I='',i,'' J='',j,'' SHIFT='',shift', &
'          write(*,''(b32.32)'') i,j, dshiftl (i, j, shift)', &
'      end subroutine printit', &
'', &
'      end program demo_dshiftl', &
'', &
'  Results:', &
'', &
'         > I=-1 J=0 SHIFT=5', &
'         > 11111111111111111111111111111111', &
'         > 00000000000000000000000000000000', &
'         > 11111111111111111111111111100000', &
'         > I=0 J=-134217728 SHIFT=5', &
'         > 00000000000000000000000000000000', &
'         > 11111000000000000000000000000000', &
'         > 00000000000000000000000000011111', &
'         > I=134217727 J=-134217728 SHIFT=5', &
'         > 00000111111111111111111111111111', &
'         > 11111000000000000000000000000000', &
'         > 11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  DSHIFTR(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022             dshiftl(3fortran)', &
'']

shortname="dshiftl"
call process()


case('74','dshiftr')

textblock=[character(len=256) :: &
'', &
'dshiftr(3fortran)                                            dshiftr(3fortran)', &
'', &
'NAME', &
'  DSHIFTR(3) - [BIT:COPY] combined right shift of the bits of two integers', &
'', &
'SYNTAX', &
'  elemental integer(kind=KIND) function dshiftr(i, j, shift)', &
'', &
'       integer(kind=KIND),intent(in) :: i', &
'       integer(kind=KIND),intent(in) :: j', &
'       integer(kind=KIND2),intent(in) :: shift', &
'', &
'  Where the kind of I, J, and DSHIFTR are the same. An exception is that one', &
'  of I and J may be a BOZ literal constant.', &
'', &
'DESCRIPTION', &
'  DSHIFTR(I, J, SHIFT) combines bits of I and J. The leftmost SHIFT bits of', &
'  the result are the rightmost SHIFT bits of I, and the remaining bits are the', &
'  leftmost bits of J.', &
'', &
'  This is equivalent to', &
'', &
'           ior(shiftl (i, bit_size(i)-shift), shiftr(j, shift) )', &
'', &
'  It may be thought of as appending the bits of I and J, dropping off the', &
'  SHIFT rightmost bits, and then retaining the same number of rightmost bits', &
'  as an input value, hence the name "combined right shift"...', &
'', &
'      GIven two 16-bit values labeled alphabetically ...', &
'', &
'         i=ABCDEFGHIJKLMNOP', &
'         j=abcdefghijklmnop', &
'', &
'      Append them together', &
'', &
'         ABCDEFGHIJKLMNOPabcdefghijklmnop', &
'', &
'      Shift them N=6 bits to the right dropping off bits', &
'', &
'         ......ABCDEFGHIJKLMNOPabcdefghij', &
'', &
'      Keep the 16 right-most bits', &
'', &
'         KLMNOPabcdefghij', &
'', &
'  Pictured this way it can be seen that if I and J have the same value', &
'', &
'           dshiftr( i, i, shift )', &
'', &
'  this has the same result as a negative circular shift', &
'', &
'           ishftc( i, -shift ).', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer.', &
'', &
'  o  J : Shall be of type integer, and of the same kind as I.', &
'', &
'  o  SHIFT : Shall be of type integer. It shall be nonnegative and less than', &
'     or equal to BIT_SIZE(RESULT) where "result" is the integer kind of the', &
'     returned value/input integers.', &
'', &
'RETURNS', &
'  The return value has same type and kind as I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dshiftr', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: i, j', &
'      integer             :: shift', &
'', &
'        ! basic usage', &
'         write(*,*) dshiftr (1, 2**30, 2)', &
'', &
'        ! print some calls as binary to better visualize the results', &
'         i=-1', &
'         j=0', &
'         shift=5', &
'         call printit()', &
'', &
'        ! visualizing a "combined right shift" ...', &
'         i=b"00000000000000000000000000011111"', &
'         j=b"11111111111111111111111111100000"', &
'         ! appended together ( i//j )', &
'         ! 0000000000000000000000000001111111111111111111111111111111100000', &
'         ! shifted right SHIFT values dropping off shifted values', &
'         ! .....00000000000000000000000000011111111111111111111111111111111', &
'         ! keep enough rightmost bits to fill the kind', &
'         ! 11111111111111111111111111111111', &
'         ! so the result should be all 1s bits ...', &
'         call printit()', &
'', &
'      contains', &
'      subroutine printit()', &
'         ! print i,j,shift and then i,j, and the result as binary values', &
'          write(*,''(*(g0))'')''I='',i,'' J='',j,'' SHIFT='',shift', &
'          write(*,''(b32.32)'') i,j, dshiftr (i, j, shift)', &
'      end subroutine printit', &
'', &
'      end program demo_dshiftr', &
'', &
'  Results:', &
'', &
'         >   1342177280', &
'         > I=-1 J=0 SHIFT=5', &
'         > 11111111111111111111111111111111', &
'         > 00000000000000000000000000000000', &
'         > 11111000000000000000000000000000', &
'         > I=31 J=-32 SHIFT=5', &
'         > 00000000000000000000000000011111', &
'         > 11111111111111111111111111100000', &
'         > 11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  DSHIFTL(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022             dshiftr(3fortran)', &
'']

shortname="dshiftr"
call process()


case('75','eoshift')

textblock=[character(len=256) :: &
'', &
'eoshift(3fortran)                                            eoshift(3fortran)', &
'', &
'NAME', &
'  EOSHIFT(3) - [TRANSFORMATIONAL] End-off shift elements of an array', &
'', &
'SYNTAX', &
'  result = eoshift(array, shift, boundary, dim)', &
'', &
'DESCRIPTION', &
'  EOSHIFT(ARRAY, SHIFT[, BOUNDARY, DIM]) performs an end-off shift on elements', &
'  of ARRAY along the dimension of DIM. If DIM is omitted it is taken to be 1.', &
'  DIM is a scalar of type integer in the range of 1 <= DIM <= N where "N" is', &
'  the rank of ARRAY. If the rank of ARRAY is one, then all elements of ARRAY', &
'  are shifted by SHIFT places. If rank is greater than one, then all complete', &
'  rank one sections of ARRAY along the given dimension are shifted. Elements', &
'  shifted out one end of each rank one section are dropped. If BOUNDARY is', &
'  present then the corresponding value from BOUNDARY is copied back in the', &
'  other end. If BOUNDARY is not present then the following are copied in', &
'  depending on the type of ARRAY.', &
'', &
'      Array Type     | Boundary Value', &
'      -----------------------------------------------------', &
'      Numeric        | 0 of the type and kind of "array"', &
'      Logical        | .false.', &
'      Character(len) |  LEN blanks', &
'', &
'ARGUMENTS', &
'  o  ARRAY : May be any type, not scalar.', &
'', &
'  o  SHIFT : The type shall be integer.', &
'', &
'  o  BOUNDARY : Same type as ARRAY.', &
'', &
'  o  DIM : The type shall be integer.', &
'', &
'RETURNS', &
'  Returns an array of same type and rank as the ARRAY argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_eoshift', &
'      implicit none', &
'      integer, dimension(3,3) :: a', &
'      integer :: i', &
'', &
'          a = reshape( [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3, 3 ])', &
'          print ''(3i3)'', (a(i,:),i=1,3)', &
'', &
'          print *', &
'', &
'          ! shift it', &
'          a = eoshift(a, SHIFT=[1, 2, 1], BOUNDARY=-5, DIM=2)', &
'          print ''(3i3)'', (a(i,:),i=1,3)', &
'', &
'      end program demo_eoshift', &
'', &
'  Results:', &
'', &
'    1 4  7', &
'', &
'    2 5  8', &
'', &
'    3 6  9', &
'', &
'    4 7 -5 8 -5 -5', &
'', &
'    6 9 -5', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             eoshift(3fortran)', &
'']

shortname="eoshift"
call process()


case('76','epsilon')

textblock=[character(len=256) :: &
'', &
'epsilon(3fortran)                                            epsilon(3fortran)', &
'', &
'NAME', &
'  EPSILON(3) - [NUMERIC MODEL] Epsilon function', &
'', &
'SYNTAX', &
'  result = epsilon(x)', &
'', &
'DESCRIPTION', &
'  EPSILON(X) returns the floating point relative accuracy. It is the nearly', &
'  negligible number relative to 1 such that 1+ LITTLE_NUMBER is not equal to', &
'  1; or more precisely', &
'', &
'         real( 1.0, kind(x)) + epsilon(x) /=  real( 1.0, kind(x))', &
'', &
'  It may be thought of as the distance from 1.0 to the next largest floating', &
'  point number.', &
'', &
'  One use of EPSILON(3) is to select a delta value for algorithms that search', &
'  until the calculation is within delta of an estimate.', &
'', &
'  If delta is too small the algorithm might never halt, as a computation', &
'  summing values smaller than the decimal resolution of the data type does not', &
'  change.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of the same type as the argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_epsilon', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp) :: x = 3.143', &
'      real(kind=dp) :: y = 2.33d0', &
'', &
'         ! so if x is of type real32, epsilon(x) has the value 2**-23', &
'         print *, epsilon(x)', &
'         ! note just the type and kind of x matter, not the value', &
'         print *, epsilon(huge(x))', &
'         print *, epsilon(tiny(x))', &
'', &
'         ! the value changes with the kind of the real value though', &
'         print *, epsilon(y)', &
'', &
'         ! adding and subtracting epsilon(x) changes x', &
'         write(*,*)x == x + epsilon(x)', &
'         write(*,*)x == x - epsilon(x)', &
'', &
'         ! these next two comparisons will be .true. !', &
'         write(*,*)x == x + epsilon(x) * 0.999999', &
'         write(*,*)x == x - epsilon(x) * 0.999999', &
'', &
'         ! you can calculate epsilon(1.0d0)', &
'         write(*,*)my_dp_eps()', &
'', &
'      contains', &
'', &
'         function my_dp_eps()', &
'         ! calculate the epsilon value of a machine the hard way', &
'         real(kind=dp) :: t', &
'         real(kind=dp) :: my_dp_eps', &
'', &
'            ! starting with a value of 1, keep dividing the value', &
'            ! by 2 until no change is detected. Note that with', &
'            ! infinite precision this would be an infinite loop,', &
'            ! but floating point values in Fortran have a defined', &
'            ! and limited precision.', &
'            my_dp_eps = 1.0d0', &
'            SET_ST: do', &
'               my_dp_eps = my_dp_eps/2.0d0', &
'               t = 1.0d0 + my_dp_eps', &
'               if (t <= 1.0d0) exit', &
'            enddo SET_ST', &
'            my_dp_eps = 2.0d0*my_dp_eps', &
'', &
'         end function my_dp_eps', &
'      end program demo_epsilon', &
'', &
'  Results:', &
'', &
'        1.1920929E-07', &
'        1.1920929E-07', &
'        1.1920929E-07', &
'        2.220446049250313E-016', &
'', &
'   F', &
'   F', &
'   T', &
'   T', &
'  2.220446049250313E-016', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022             epsilon(3fortran)', &
'']

shortname="epsilon"
call process()


case('77','erf')

textblock=[character(len=256) :: &
'', &
'erf(3fortran)                                                    erf(3fortran)', &
'', &
'NAME', &
'  ERF(3) - [MATHEMATICS] Error function', &
'', &
'SYNTAX', &
'  result = erf(x)', &
'', &
'DESCRIPTION', &
'  ERF(x) computes the error function of X, defined as', &
'', &
'  $$ \text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-T^2} dt. $$', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of type real, of the same kind as X and lies in the', &
'  range -1 <= ERF(x) <= 1 .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_erf', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'       & real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 0.17_real64', &
'          write(*,*)x, erf(x)', &
'      end program demo_erf', &
'', &
'  Results:', &
'', &
'           0.17000000000000001       0.18999246120180879', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  See also', &
'', &
'  ERFC(3)', &
'', &
'  o  Wikipedia:error function', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 erf(3fortran)', &
'']

shortname="erf"
call process()


case('78','erfc')

textblock=[character(len=256) :: &
'', &
'erfc(3fortran)                                                  erfc(3fortran)', &
'', &
'NAME', &
'  ERFC(3) - [MATHEMATICS] Complementary error function', &
'', &
'SYNTAX', &
'  result = erfc(x)', &
'', &
'         elemental function erfc(x)', &
'         real(kind=KIND) :: erfc', &
'         real(kind=KIND),intent(in) :: x', &
'', &
'DESCRIPTION', &
'  ERFC(x) computes the complementary error function of X. Simply put this is', &
'  equivalent to 1 - ERF(X), but ERFC is provided because of the extreme loss', &
'  of relative accuracy if ERF(X) is called for large X and the result is', &
'  subtracted from 1.', &
'', &
'  ERFC(X) is defined as', &
'', &
'  $$ \text{erfc}(x) = 1 - \text{erf}(x) = 1 - \frac{2}{\sqrt{\pi}}', &
'  \int_x^{\infty} e^{-t^2} dt. $$', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of type real and of the same kind as X. It lies in the', &
'  range', &
'', &
'    0 <= ERFC(x) <= 2.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_erfc', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'       & real_kinds, real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 0.17_real64', &
'          write(*,*)x, erfc(x)', &
'      end program demo_erfc', &
'', &
'  Results:', &
'', &
'           0.17000000000000001       0.81000753879819121', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  See also', &
'', &
'  ERF(3)', &
'', &
'  o  Wikipedia:error function', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                erfc(3fortran)', &
'']

shortname="erfc"
call process()


case('79','erfc_scaled')

textblock=[character(len=256) :: &
'', &
'erfc_scaled(3fortran)                                    erfc_scaled(3fortran)', &
'', &
'NAME', &
'  ERFC_SCALED(3) - [MATHEMATICS] Error function', &
'', &
'SYNTAX', &
'  result = erfc_scaled(x)', &
'', &
'DESCRIPTION', &
'  ERFC_SCALED(x) computes the exponentially-scaled complementary error', &
'  function of X:', &
'', &
'  $$ e^{x^2} \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt. $$', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of type real and of the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_erfc_scaled', &
'      implicit none', &
'      real(kind(0.0d0)) :: x = 0.17d0', &
'         x = erfc_scaled(x)', &
'         print *, x', &
'      end program demo_erfc_scaled', &
'', &
'  Results:', &
'', &
'           0.83375830214998126', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         erfc_scaled(3fortran)', &
'']

shortname="erfc_scaled"
call process()


case('80','event_query')

textblock=[character(len=256) :: &
'', &
'event_query(3fortran)                                    event_query(3fortran)', &
'', &
'NAME', &
'  EVENT_QUERY(3) - [COLLECTIVE] Query whether a coarray event has occurred', &
'', &
'SYNTAX', &
'  call event_query(event, count, stat)', &
'', &
'DESCRIPTION', &
'  EVENT_QUERY assigns the number of events to COUNT which have been posted to', &
'  the EVENT variable and not yet been removed by calling EVENT_WAIT.  When', &
'  STAT is present and the invocation was successful, it is assigned the value', &
'  0. If it is present and the invocation has failed, it is assigned a positive', &
'  value and COUNT is assigned the value -1.', &
'', &
'ARGUMENTS', &
'  o  EVENT : (intent(in)) Scalar of type event_type, defined in', &
'     iso_fortran_env; shall not be coindexed.', &
'', &
'  o  COUNT : (intent(out))Scalar integer with at least the precision of', &
'     default integer.', &
'', &
'  o  STAT : (OPTIONAL) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_event_query', &
'      use iso_fortran_env', &
'      implicit none', &
'      type(event_type) :: event_value_has_been_set[*]', &
'      integer :: cnt', &
'         if (this_image() == 1) then', &
'            call event_query(event_value_has_been_set, cnt)', &
'            if (cnt > 0) write(*,*) "Value has been set"', &
'         elseif (this_image() == 2) then', &
'            event post(event_value_has_been_set[1])', &
'         endif', &
'      end program demo_event_query', &
'', &
'STANDARD', &
'  TS 18508 or later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         event_query(3fortran)', &
'']

shortname="event_query"
call process()


case('81','execute_command_line')

textblock=[character(len=256) :: &
'', &
'execute_command_line(3fortran)                  execute_command_line(3fortran)', &
'', &
'NAME', &
'  EXECUTE_COMMAND_LINE(3) - [SYSTEM:PROCESSES] Execute a shell command', &
'', &
'SYNTAX', &
'  subroutine execute_command_line(command, wait, exitstat, cmdstat, cmdmsg)', &
'', &
'          character(len=*),intent(in)  :: command', &
'          logical,intent(in),optional  :: wait', &
'          integer,intent(out),optional :: exitstat', &
'          integer,intent(out),optional :: cmdstat', &
'          character(len=*),intent(out),optional :: cmdmsg', &
'', &
'DESCRIPTION', &
'  The COMMAND argument is passed to the shell and executed. (The shell is', &
'  generally SH(1) on Unix systems, and cmd.exe on Windows.) If WAIT is present', &
'  and has the value .false., the execution of the command is asynchronous if', &
'  the system supports it; otherwise, the command is executed synchronously.', &
'', &
'  The three last arguments allow the user to get status information. After', &
'  synchronous execution, EXITSTAT contains the integer exit code of the', &
'  command, as returned by SYSTEM. CMDSTAT is set to zero if the command line', &
'  was executed (whatever its exit status was). CMDMSG is assigned an error', &
'  message if an error has occurred.', &
'', &
'  Note that the system call need not be thread-safe. It is the responsibility', &
'  of the user to ensure that the system is not called concurrently if', &
'  required.', &
'', &
'  When the command is executed synchronously, EXECUTE_COMMAND_LINE returns', &
'  after the command line has completed execution. Otherwise,', &
'  EXECUTE_COMMAND_LINE returns without waiting.', &
'', &
'ARGUMENTS', &
'  o  COMMAND : a default character scalar containing the command line to be', &
'     executed. The interpretation is programming-environment dependent.', &
'', &
'  o  WAIT : (Optional) a default logical scalar. If WAIT is present with the', &
'     value .false., and the processor supports asynchronous execution of the', &
'     command, the command is executed asynchronously; otherwise it is executed', &
'     synchronously.', &
'', &
'  o  EXITSTAT : (Optional) an integer of the default kind with INTENT(INOUT).', &
'     If the command is executed synchronously, it is assigned the value of the', &
'     processor-dependent exit status.  Otherwise, the value of EXITSTAT is', &
'     unchanged.', &
'', &
'  o  CMDSTAT : (Optional) an integer of default kind with INTENT(INOUT).  If', &
'     an error condition occurs and CMDSTAT is not present, error termination', &
'     of execution of the image is initiated.', &
'', &
'     It is assigned the value -1 if the processor does not support command', &
'     line execution, a processor-dependent positive value if an error', &
'     condition occurs, or the value -2 if no error condition occurs but WAIT', &
'     is present with the value false and the processor does not support', &
'     asynchronous execution. Otherwise it is assigned the value 0.', &
'', &
'  o  CMDMSG : (Optional) a character scalar of the default kind. It is an', &
'     INTENT (INOUT) argument.If an error condition occurs, it is assigned a', &
'     processor-dependent explanatory message.Otherwise, it is unchanged.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_exec', &
'      implicit none', &
'         integer :: i', &
'', &
'         call execute_command_line("external_prog.exe", exitstat=i)', &
'         print *, "Exit status of external_prog.exe was ", i', &
'', &
'         call execute_command_line("reindex_files.exe", wait=.false.)', &
'         print *, "Now reindexing files in the background"', &
'      end program demo_exec', &
'', &
'NOTE', &
'  Because this intrinsic is making a system call, it is very system dependent.', &
'  Its behavior with respect to signaling is processor dependent. In', &
'  particular, on POSIX-compliant systems, the SIGINT and SIGQUIT signals will', &
'  be ignored, and the SIGCHLD will be blocked. As such, if the parent process', &
'  is terminated, the child process might not be terminated alongside.', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022execute_command_line(3fortran)', &
'']

shortname="execute_command_line"
call process()


case('82','exp')

textblock=[character(len=256) :: &
'', &
'exp(3fortran)                                                    exp(3fortran)', &
'', &
'NAME', &
'  EXP(3) - [MATHEMATICS] Exponential function', &
'', &
'SYNTAX', &
'  result = exp(x)', &
'', &
'DESCRIPTION', &
'  EXP(x) computes the base "e" exponential of X where "e" is Euler''s constant.', &
'', &
'  If X is of type complex, its imaginary part is regarded as a value in', &
'  radians such that (see Euler''s formula):', &
'', &
'  if CX=(RE,IM) then EXP(CX)=EXP(RE)*CMPLX(COS(IM),SIN(IM),KIND=KIND(CX))', &
'', &
'  Since EXP(3) is the inverse function of LOG(3) the maximum valid magnitude', &
'  of the real component of X is LOG(HUGE(X)).', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The value of the result is E**X where E is Euler''s constant.', &
'', &
'  The return value has the same type and kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_exp', &
'      implicit none', &
'      real :: x, re, im', &
'      complex :: cx', &
'', &
'         x = 1.0', &
'         write(*,*)"Euler''s constant is approximately",exp(x)', &
'', &
'         !! complex values', &
'         ! given', &
'         re=3.0', &
'         im=4.0', &
'         cx=cmplx(re,im)', &
'', &
'         ! complex results from complex arguments are Related to Euler''s formula', &
'         write(*,*)''given the complex value '',cx', &
'         write(*,*)''exp(x) is'',exp(cx)', &
'         write(*,*)''is the same as'',exp(re)*cmplx(cos(im),sin(im),kind=kind(cx))', &
'', &
'         ! exp(3) is the inverse function of log(3) so', &
'         ! the real component of the input must be less than or equal to', &
'         write(*,*)''maximum real component'',log(huge(0.0))', &
'         ! or for double precision', &
'         write(*,*)''maximum doubleprecision component'',log(huge(0.0d0))', &
'', &
'         ! but since the imaginary component is passed to the cos(3) and sin(3)', &
'         ! functions the imaginary component can be any real value', &
'', &
'      end program demo_exp', &
'', &
'  Results:', &
'', &
'       Euler''s constant is approximately   2.718282', &
'       given the complex value  (3.000000,4.000000)', &
'       exp(x) is (-13.12878,-15.20078)', &
'       is the same as (-13.12878,-15.20078)', &
'       maximum real component   88.72284', &
'       maximum doubleprecision component   709.782712893384', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  o  LOG(3)', &
'', &
'  o  Wikipedia:Exponential function', &
'', &
'  o  Wikipedia:Euler''s formula', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 exp(3fortran)', &
'']

shortname="exp"
call process()


case('83','exponent')

textblock=[character(len=256) :: &
'', &
'exponent(3fortran)                                          exponent(3fortran)', &
'', &
'NAME', &
'  EXPONENT(3) - [MODEL_COMPONENTS] Exponent function', &
'', &
'SYNTAX', &
'  result = exponent(x)', &
'', &
'DESCRIPTION', &
'  EXPONENT(x) returns the value of the exponent part of X. If X is zero the', &
'  value returned is zero.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'RETURNS', &
'  The return value is of type default integer.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_exponent', &
'      implicit none', &
'      real :: x = 1.0', &
'      integer :: i', &
'         i = exponent(x)', &
'         print *, i', &
'         print *, exponent(0.0)', &
'      end program demo_exponent', &
'', &
'  Results:', &
'', &
'    1 0', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), FRACTION(3), HUGE(3), MAXEXPONENT(3), MINEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022            exponent(3fortran)', &
'']

shortname="exponent"
call process()


case('84','extends_type_of')

textblock=[character(len=256) :: &
'', &
'extends_type_of(3fortran)                            extends_type_of(3fortran)', &
'', &
'NAME', &
'  EXTENDS_TYPE_OF(3) - [STATE] determine if the dynamic type of A is an', &
'  extension of the dynamic type of MOLD.', &
'', &
'SYNTAX', &
'  result=extends_type_of(a, mold)', &
'', &
'DESCRIPTION', &
'  EXTENDS_TYPE_OF(3) is .true. if and only if the dynamic type of A is an', &
'  extension of the dynamic type of MOLD.', &
'', &
'OPTIONS', &
'  o  A : shall be an object of extensible type. If it is a pointer, it shall', &
'     not have an undefined association status.', &
'', &
'  o  MOLD : shall be an object of extensible type. If it is a pointer, it', &
'     shall not have an undefined association status.', &
'', &
'RETURNS', &
'  o  RESULT : Default logical scalar.', &
'', &
'  o  VALUE : If MOLD is unlimited polymorphic and is either a disassociated', &
'     pointer or unallocated allocatable variable, the result is true;', &
'     otherwise if A is unlimited polymorphic and is either a disassociated', &
'     pointer or unallocated allocatable variable, the result is false;', &
'     otherwise the result is true if and only if the dynamic type of A is an', &
'     extension type of the dynamic type of MOLD.', &
'', &
'     The dynamic type of a disassociated pointer or unallocated allocatable', &
'     variable is its declared type.', &
'', &
'EXAMPLES', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022     extends_type_of(3fortran)', &
'']

shortname="extends_type_of"
call process()


case('85','findloc')

textblock=[character(len=256) :: &
'', &
'findloc(3fortran)                                            findloc(3fortran)', &
'', &
'NAME', &
'  FINDLOC(3) - [ARRAY:LOCATION] Location of first element of ARRAY identified', &
'  by MASK along dimension DIM matching a target value', &
'', &
'SYNTAX', &
'  findloc (array, value, dim, mask, kind, back)', &
'', &
'  or', &
'', &
'  findloc(array, value, mask, kind, back)', &
'', &
'DESCRIPTION', &
'  Location of the first element of ARRAY identified by MASK along dimension', &
'  DIM having a value equal to VALUE.', &
'', &
'  If both ARRAY and VALUE are of type logical, the comparison is performed', &
'  with the .EQV. operator; otherwise, the comparison is performed with the ==', &
'  operator. If the value of the comparison is .true., that element of ARRAY', &
'  matches VALUE.', &
'', &
'  If only one element matches VALUE, that element''s subscripts are returned.', &
'  Otherwise, if more than one element matches VALUE and BACK is absent or', &
'  present with the value .false., the element whose subscripts are returned is', &
'  the first such element, taken in array element order. If BACK is present', &
'  with the value .true., the element whose subscripts are returned is the last', &
'  such element, taken in array element order.', &
'', &
'OPTIONS', &
'  o  ARRAY : shall be an array of intrinsic type.', &
'', &
'  o  VALUE : shall be scalar and in type conformance with ARRAY, as specified', &
'     in Table 7.3 for relational intrinsic operations 7.1.5.5.2).', &
'', &
'  o  DIM : shall be an integer scalar with a value in the range 1 DIM n, where', &
'     n is the rank of ARRAY. The corresponding actual argument shall not be an', &
'     optional dummy argument.', &
'', &
'  o  MASK : (optional) shall be of type logical and shall be conformable with', &
'     ARRAY.', &
'', &
'  o  KIND : (optional) shall be a scalar integer initialization expression.', &
'', &
'  o  BACK : (optional) shall be a logical scalar.', &
'', &
'RETURNS', &
'  Result Characteristics. Integer. If KIND is present, the kind type parameter', &
'  is that specified by the value of KIND; otherwise the kind type parameter is', &
'  that of default integer type. If DIM does not appear, the result is an array', &
'  of rank one and of size equal to the rank of ARRAY; otherwise, the result is', &
'  of rank n - 1 and shape', &
'', &
'         [d1, d2, . . ., dDIM-1, dDIM+1, . . ., dn ]', &
'', &
'  where', &
'', &
'         [d1, d2, . . ., dn ]', &
'', &
'  is the shape of ARRAY.', &
'', &
'RETURNS', &
'  o  CASE (I): The result of FINDLOC (ARRAY, VALUE) is a rank-one array whose', &
'     element values are the values of the subscripts of an element of ARRAY', &
'     whose value matches VALUE. If there is such a value, the ith subscript', &
'     returned lies in the range 1 to ei, where ei is the extent of the ith', &
'     dimension of ARRAY. If no elements match VALUE or ARRAY has size zero,', &
'     all elements of the result are zero.', &
'', &
'  o  CASE (II): the result of FINDLOC (ARRAY, VALUE, MASK = MASK) is a rank-', &
'     one array whose element values are the values of the subscripts of an', &
'     element of ARRAY, corresponding to a true element of MASK, whose value', &
'     matches VALUE. If there is such a value, the ith subscript returned lies', &
'     in the range 1 to ei, where ei is the extent of the ith dimension of', &
'     ARRAY. If no elements match VALUE, ARRAY has size zero, or every element', &
'     of MASK has the value false, all elements of the result are zero.', &
'', &
'  o  CASE (III): If ARRAY has rank one, the result of', &
'', &
'            findloc (array, value, dim=dim [, mask = mask])', &
'', &
'  is a scalar whose value is equal to that of the first element of', &
'', &
'            findloc (array, value [, mask = mask])', &
'', &
'  Otherwise, the value of element', &
'', &
'            (s1, s2, . . ., sDIM-1, sDIM+1, . . ., sn )', &
'', &
'  of the result is equal to', &
'', &
'            findloc (array (s1, s2, ..., sdim-1, :, sdim+1, ..., sn ), &', &
'            value, dim=1 [, mask = mask (s1, s2, ..., sdim-1, :,', &
'                            sdim+1, ..., sn )]).', &
'', &
'EXAMPLES', &
'  o  CASE (I): The value of', &
'', &
'              findloc ([2, 6, 4, 6,], value = 6)', &
'', &
'  is [2], and the value of', &
'', &
'              findloc ([2, 6, 4, 6], value = 6, back = .true.)', &
'', &
'  is [4].', &
'', &
'  o  CASE (II): If A has the value', &
'', &
'     0 -5', &
'       7 7', &
'', &
'     3 4 -1 2', &
'', &
'     1 5  6 7', &
'', &
'  and M has the value', &
'', &
'   T T F T', &
'   T T F T', &
'   T T F T', &
'  findloc (a, 7, mask = m)', &
'', &
'  has the value [1, 4] and', &
'', &
'            findloc (a, 7, mask = m, back = .true.)', &
'', &
'  has the value [3, 4]. This is independent of the declared lower bounds for A', &
'  .', &
'', &
'    o  CASE (III): The value of', &
'', &
'              findloc ([2, 6, 4], value = 6, dim = 1)', &
'', &
'    is 2. If B has the value', &
'', &
'      1 2 -9', &
'', &
'      2 2', &
'', &
'    findloc (b, VALUE = 2, dim = 1)', &
'', &
'    has the value [2, 1, 0] and', &
'', &
'              findloc (b, value = 2, dim = 2)', &
'', &
'    has the value [2, 1]. This is independent of the declared lower bounds for', &
'    B.', &
'', &
'    fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             findloc(3fortran)', &
'']

shortname="findloc"
call process()


case('86','floor')

textblock=[character(len=256) :: &
'', &
'floor(3fortran)                                                floor(3fortran)', &
'', &
'NAME', &
'  FLOOR(3) - [NUMERIC] function to return largest integral value not greater', &
'  than argument', &
'', &
'SYNTAX', &
'  result = floor(a, KIND)', &
'', &
'          elemental function floor(a,KIND)', &
'          integer(kind=KIND) :: floor', &
'          real(kind=kind(a)),intent(in) :: a', &
'          integer(kind=IKIND),intent(in),optional :: KIND', &
'', &
'  where KIND is any valid value for type integer.', &
'', &
'DESCRIPTION', &
'  FLOOR(A) returns the greatest integer less than or equal to A. That is, it', &
'  picks the whole number at or to the left of the value on the scale', &
'  -HUGE(INT(A,KIND=KIND))-1 to HUGE(INT(A),KIND=KIND).', &
'', &
'ARGUMENTS', &
'  o  A : The type shall be real.', &
'', &
'  o  KIND : (Optional) A scalar integer constant initialization expression', &
'     indicating the kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer(kind) if KIND is present and of default-', &
'  kind integer otherwise.', &
'', &
'  The result is undefined if it cannot be represented in the specified integer', &
'  type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_floor', &
'      implicit none', &
'      real :: x = 63.29', &
'      real :: y = -63.59', &
'          print *, x, floor(x)', &
'          print *, y, floor(y)', &
'         ! elemental', &
'         print *,floor([ &', &
'         &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'         &  0.0,   &', &
'         &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'', &
'         ! note even a small deviation from the whole number changes the result', &
'         print *,      [2.0,2.0-epsilon(0.0),2.0-2*epsilon(0.0)]', &
'         print *,floor([2.0,2.0-epsilon(0.0),2.0-2*epsilon(0.0)])', &
'', &
'         ! A=Nan, Infinity or  <huge(0_KIND)-1 < A > huge(0_KIND) is undefined', &
'      end program demo_floor', &
'', &
'  Results:', &
'', &
'            63.29000              63', &
'', &
'    -63.59000', &
'      -64', &
'', &
'      -3', &
'        -3          -3          -2          -2          -1', &
'', &
'      -1', &
'        0           0           1           1           2', &
'', &
'        2 2           2', &
'', &
'    2.000000', &
'      2.000000       2.000000', &
'', &
'      2 1           1', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  CEILING(3), NINT(3)', &
'', &
'  AINT(3), ANINT(3), INT(3), SELECTED_INT_KIND(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               floor(3fortran)', &
'']

shortname="floor"
call process()


case('87','fraction')

textblock=[character(len=256) :: &
'', &
'fraction(3fortran)                                          fraction(3fortran)', &
'', &
'NAME', &
'  FRACTION(3) - [MODEL_COMPONENTS] Fractional part of the model representation', &
'', &
'SYNTAX', &
'  y = fraction(x)', &
'', &
'DESCRIPTION', &
'  FRACTION(X) returns the fractional part of the model representation of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type of the argument shall be a real.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as the argument. The', &
'  fractional part of the model representation of X is returned; it is X *', &
'  RADIX(X)**(-EXPONENT(X)).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_fraction', &
'      implicit none', &
'      real :: x', &
'         x = 178.1387e-4', &
'         print *, fraction(x), x * radix(x)**(-exponent(x))', &
'      end program demo_fraction', &
'', &
'  Results:', &
'', &
'           0.570043862      0.570043862', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), HUGE(3), MAXEXPONENT(3), MINEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022            fraction(3fortran)', &
'']

shortname="fraction"
call process()


case('88','gamma')

textblock=[character(len=256) :: &
'', &
'gamma(3fortran)                                                gamma(3fortran)', &
'', &
'NAME', &
'  GAMMA(3) - [MATHEMATICS] Gamma function, which yields factorials for', &
'  positive whole numbers', &
'', &
'SYNTAX', &
'  x = gamma(x)', &
'', &
'DESCRIPTION', &
'  GAMMA(X) computes Gamma of X. For positive whole number values of N the', &
'  Gamma function can be used to calculate factorials, as (N-1)! ==', &
'  GAMMA(REAL(N)). That is', &
'', &
'      n! == gamma(real(n+1))', &
'', &
'  $$ \GAMMA(x) = \int_0**\infty t**{x-1}{\mathrm{e}}**{-T}\,{\mathrm{d}}t $$', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real and neither zero nor a negative integer.', &
'', &
'RETURNS', &
'  The return value is of type real of the same kind as x.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_gamma', &
'      use, intrinsic :: iso_fortran_env, only : wp=>real64', &
'      implicit none', &
'      real :: x, xa(4)', &
'      integer :: i', &
'', &
'         x = gamma(1.0)', &
'         write(*,*)''gamma(1.0)='',x', &
'', &
'         ! elemental', &
'         xa=gamma([1.0,2.0,3.0,4.0])', &
'         write(*,*)xa', &
'         write(*,*)', &
'', &
'         ! gamma(3) is related to the factorial function', &
'         do i=1,20', &
'            ! check value is not too big for default integer type', &
'            if(factorial(i).gt.huge(0))then', &
'               write(*,*)i,factorial(i)', &
'            else', &
'               write(*,*)i,factorial(i),int(factorial(i))', &
'            endif', &
'         enddo', &
'         ! more factorials', &
'         FAC: block', &
'         integer,parameter :: n(*)=[0,1,5,11,170]', &
'         integer :: j', &
'            do j=1,size(n)', &
'               write(*,''(*(g0,1x))'')''factorial of'', n(j),'' is '', &', &
'                & product([(real(i,kind=wp),i=1,n(j))]),  &', &
'                & gamma(real(n(j)+1,kind=wp))', &
'            enddo', &
'         endblock FAC', &
'', &
'         contains', &
'         function factorial(i) result(f)', &
'         integer,parameter :: dp=kind(0d0)', &
'         integer,intent(in) :: i', &
'         real :: f', &
'            if(i.le.0)then', &
'               write(*,''(*(g0))'')''<ERROR> gamma(3) function value '',i,'' <= 0''', &
'               stop      ''<STOP> bad value in gamma function''', &
'            endif', &
'            f=gamma(real(i+1))', &
'         end function factorial', &
'      end program demo_gamma', &
'', &
'  Results:', &
'', &
'          gamma(1.0)=   1.000000', &
'            1.000000       1.000000       2.000000       6.000000', &
'', &
'                    1   1.000000               1', &
'                    2   2.000000               2', &
'                    3   6.000000               6', &
'                    4   24.00000              24', &
'                    5   120.0000             120', &
'                    6   720.0000             720', &
'                    7   5040.000            5040', &
'                    8   40320.00           40320', &
'                    9   362880.0          362880', &
'                   10   3628800.         3628800', &
'                   11  3.9916800E+07    39916800', &
'                   12  4.7900160E+08   479001600', &
'                   13  6.2270208E+09', &
'                   14  8.7178289E+10', &
'                   15  1.3076744E+12', &
'                   16  2.0922791E+13', &
'                   17  3.5568741E+14', &
'                   18  6.4023735E+15', &
'                   19  1.2164510E+17', &
'                   20  2.4329020E+18', &
'', &
'    factorial of 0', &
'      is  1.000000000000000 1.000000000000000', &
'', &
'    factorial of 1', &
'      is  1.000000000000000 1.000000000000000', &
'', &
'    factorial of 5', &
'      is  120.0000000000000 120.0000000000000', &
'', &
'    factorial of 11', &
'      is  39916800.00000000 39916800.00000000', &
'', &
'    factorial of 170', &
'      is  .7257415615307994E+307 .7257415615307999E+307', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  Logarithm of the Gamma function: LOG_GAMMA(3)', &
'', &
'  Wikipedia: Gamma_function', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               gamma(3fortran)', &
'']

shortname="gamma"
call process()


case('89','get_command')

textblock=[character(len=256) :: &
'', &
'get_command(3fortran)                                    get_command(3fortran)', &
'', &
'NAME', &
'  GET_COMMAND(3) - [SYSTEM:COMMAND LINE] Get the entire command line', &
'', &
'SYNTAX', &
'  call get_command(command, length, status)', &
'', &
'          subroutine get_command(command,length,status)', &
'          character(len=*),intent(out),optional :: command', &
'          integer,intent(out),optional :: length', &
'          integer,intent(out),optional :: status', &
'', &
'DESCRIPTION', &
'  Retrieve the entire command line that was used to invoke the program.', &
'', &
'  Note that what is typed on the command line is often processed by a shell.', &
'  The shell typically processes special characters and white space before', &
'  passing it to the program. The processing can typically be turned off by', &
'  turning off globbing or quoting the command line arguments and/or changing', &
'  the default field separators, but this should rarely be necessary.', &
'', &
'RETURNS', &
'  o  COMMAND : Shall be of type character and of default kind. If COMMAND is', &
'     present, stores the entire command line that was used to invoke the', &
'     program in COMMAND.', &
'', &
'  o  LENGTH : Shall be of type integer and of default kind. If LENGTH is', &
'     present, it is assigned the length of the command line.', &
'', &
'  o  STATUS : Shall be of type integer and of default kind. If STATUS is', &
'     present, it is assigned 0 upon success of the command, -1 if COMMAND is', &
'     too short to store the command line, or a positive value in case of an', &
'     error.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_get_command', &
'      implicit none', &
'      integer                      :: COMMAND_LINE_LENGTH', &
'      character(len=:),allocatable :: COMMAND_LINE', &
'         ! get command line length', &
'         call get_command(length=COMMAND_LINE_LENGTH)', &
'         ! allocate string big enough to hold command line', &
'         allocate(character(len=COMMAND_LINE_LENGTH) :: COMMAND_LINE)', &
'         ! get command line as a string', &
'         call get_command(command=COMMAND_LINE)', &
'         ! trim leading spaces just in case', &
'         COMMAND_LINE=adjustl(COMMAND_LINE)', &
'         write(*,''("OUTPUT:",a)'')COMMAND_LINE', &
'      end program demo_get_command', &
'', &
'  Results:', &
'', &
'           # note that shell expansion removes some of the whitespace', &
'           # without quotes', &
'           ./test_get_command  arguments    on command   line to   echo', &
'', &
'           OUTPUT:./test_get_command arguments on command line to echo', &
'', &
'           # using the bash shell with single quotes', &
'           ./test_get_command  ''arguments  *><`~[]!{}?"\''| ''', &
'', &
'           OUTPUT:./test_get_command arguments  *><`~[]!{}?"''|', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  GET_COMMAND_ARGUMENT(3), COMMAND_ARGUMENT_COUNT(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022         get_command(3fortran)', &
'']

shortname="get_command"
call process()


case('90','get_command_argument')

textblock=[character(len=256) :: &
'', &
'get_command_argument(3fortran)                  get_command_argument(3fortran)', &
'', &
'NAME', &
'  GET_COMMAND_ARGUMENT(3) - [SYSTEM:COMMAND LINE] Get command line arguments', &
'', &
'SYNTAX', &
'  call get_command_argument(number, value, length, status)', &
'', &
'  subroutine get_command_argument(number,value,length.status)', &
'', &
'  integer,intent(in)', &
'    :: number character(len=*),intent(out),optional :: value', &
'', &
'  integer,intent(out),optional', &
'    :: length', &
'', &
'  integer,intent(out),optional', &
'    :: status', &
'', &
'DESCRIPTION', &
'  Retrieve the NUMBER-th argument that was passed on the command line when the', &
'  containing program was invoked.', &
'', &
'  There is not anything specifically stated about what an argument is but in', &
'  practice the arguments are split on whitespace unless the arguments are', &
'  quoted and IFS values (Internal Field Separators) used by common shells are', &
'  ignored.', &
'', &
'OPTIONS', &
'  o  NUMBER : Shall be a scalar of type INTEGER, NUMBER >= 0. If NUMBER = 0,', &
'     VALUE is set to the name of the program (on systems that support this', &
'     feature).', &
'', &
'RETURNS', &
'  o  VALUE : Shall be a scalar of type character and of default kind.  After', &
'     get_command_argument returns, the VALUE argument holds the NUMBER-th', &
'     command line argument. If VALUE can not hold the argument, it is', &
'     truncated to fit the length of VALUE. If there are less than NUMBER', &
'     arguments specified at the command line, VALUE will be filled with', &
'     blanks.', &
'', &
'  o  LENGTH : (Optional) Shall be a scalar of type integer. The LENGTH', &
'     argument contains the length of the NUMBER-th command line argument.', &
'', &
'  o  STATUS : (Optional) Shall be a scalar of type integer. If the argument', &
'     retrieval fails, STATUS is a positive number; if VALUE contains a', &
'     truncated command line argument, STATUS is -1; and otherwise the STATUS', &
'     is zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_get_command_argument', &
'      implicit none', &
'      character(len=255)           :: progname', &
'      integer                      :: stat', &
'      integer                      :: count,i, longest, argument_length', &
'      integer,allocatable          :: istat(:), ilen(:)', &
'      character(len=:),allocatable :: args(:)', &
'        !', &
'        ! get number of arguments', &
'        count = command_argument_count()', &
'        write(*,*)''The number of arguments is '',count', &
'        !', &
'        ! simple usage', &
'        !', &
'        call get_command_argument (0, progname, status=stat)', &
'        if (stat == 0) then', &
'           print *, "The program''s name is " // trim (progname)', &
'        endif', &
'        !', &
'        ! showing how to make an array to hold any argument list', &
'        !', &
'        ! find longest argument', &
'        !', &
'        longest=0', &
'        do i=0,count', &
'           call get_command_argument(number=i,length=argument_length)', &
'           longest=max(longest,argument_length)', &
'        enddo', &
'        !', &
'        ! allocate string array big enough to hold command line', &
'        ! argument strings and related information', &
'        !', &
'        allocate(character(len=longest) :: args(0:count))', &
'        allocate(istat(0:count))', &
'        allocate(ilen(0:count))', &
'        !', &
'        ! read the arguments into the array', &
'        !', &
'        do i=0,count', &
'          call get_command_argument(i, args(i),status=istat(i),length=ilen(i))', &
'        enddo', &
'        !', &
'        ! show the results', &
'        !', &
'        write (*,''(i3.3,1x,i0.5,1x,i0.5,1x,"[",a,"]")'') &', &
'        & (i,istat(i),ilen(i),args(i)(:ilen(i)),i=0,count)', &
'      end program demo_get_command_argument', &
'', &
'  Results:', &
'', &
'      /demo_get_command_argument a  test  ''of getting   arguments '' "  leading"', &
'', &
'       The number of arguments is            5', &
'       The program''s name is xxx', &
'      000 00000 00003 [./test_get_command_argument]', &
'      001 00000 00001 [a]', &
'      003 00000 00004 [test]', &
'      004 00000 00024 [of getting   arguments ]', &
'      005 00000 00018 [  leading]', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  GET_COMMAND(3), COMMAND_ARGUMENT_COUNT(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022get_command_argument(3fortran)', &
'']

shortname="get_command_argument"
call process()


case('91','get_environment_variable')

textblock=[character(len=256) :: &
'', &
'get_environment_variable(3fortran)          get_environment_variable(3fortran)', &
'', &
'NAME', &
'  GET_ENVIRONMENT_VARIABLE(3) - [SYSTEM:ENVIRONMENT] Get an environmental', &
'  variable', &
'', &
'SYNTAX', &
'  call get_environment_variable(name, value, length, status, trim_name)', &
'', &
'         character(len=*),intent(in) :: name', &
'         character(len=*),intent(out),optional :: value', &
'         integer,intent(out),optional :: length', &
'         integer,intent(out),optional :: status', &
'         logical,intent(out),optional :: trim_name', &
'', &
'DESCRIPTION', &
'  Get the VALUE of the environmental variable NAME.', &
'', &
'  Note that GET_ENVIRONMENT_VARIABLE(3) need not be thread-safe. It is the', &
'  responsibility of the user to ensure that the environment is not being', &
'  updated concurrently.', &
'', &
'OPTIONS', &
'  o  NAME : The name of the environment variable to query.', &
'', &
'      Shall be a scalar of type character and of default kind.', &
'', &
'RETURNS', &
'  o  VALUE : The value of the environment variable being queried.', &
'', &
'      Shall be a scalar of type character and of default kind. The value', &
'      of NAME is stored in VALUE. If VALUE is not large enough to hold the', &
'      data, it is truncated. If NAME is not set, VALUE will be filled with', &
'      blanks.', &
'', &
'  o  LENGTH : Argument LENGTH contains the length needed for storing the', &
'     environment variable NAME or zero if it is not present.', &
'', &
'     Shall be a scalar of type integer and of default kind.', &
'', &
'  o  STATUS : STATUS is -1 if VALUE is present but too short for the', &
'     environment variable; it is 1 if the environment variable does not exist', &
'     and 2 if the processor does not support environment variables; in all', &
'     other cases STATUS is zero.', &
'', &
'     Shall be a scalar of type integer and of default kind.', &
'', &
'  o  TRIM_NAME : If TRIM_NAME is present with the value .false., the trailing', &
'     blanks in NAME are significant; otherwise they are not part of the', &
'     environment variable name.', &
'', &
'     Shall be a scalar of type logical and of default kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_getenv', &
'      implicit none', &
'      character(len=:),allocatable :: homedir', &
'      character(len=:),allocatable :: var', &
'           var=''HOME''', &
'           homedir=get_env(var)', &
'           write (*,''(a,"=""",a,"""")'')var,homedir', &
'', &
'      contains', &
'', &
'      function get_env(NAME,DEFAULT) result(VALUE)', &
'      ! a function that makes calling get_environment_variable(3) simple', &
'      implicit none', &
'      character(len=*),intent(in)          :: NAME', &
'      character(len=*),intent(in),optional :: DEFAULT', &
'      character(len=:),allocatable         :: VALUE', &
'      integer                              :: howbig', &
'      integer                              :: stat', &
'      integer                              :: length', &
'         ! get length required to hold value', &
'         length=0', &
'         VALUE=''''', &
'         if(NAME.ne.'''')then', &
'            call get_environment_variable( &', &
'            & NAME, length=howbig,status=stat,trim_name=.true.)', &
'            select case (stat)', &
'            case (1)', &
'             !*!print *, NAME, " is not defined in the environment. Strange..."', &
'             VALUE=''''', &
'            case (2)', &
'             !*!print *, &', &
'             !*!"This processor does not support environment variables. Boooh!"', &
'             VALUE=''''', &
'            case default', &
'             ! make string to hold value of sufficient size', &
'             if(allocated(VALUE))deallocate(VALUE)', &
'             allocate(character(len=max(howbig,1)) :: VALUE)', &
'             ! get value', &
'             call get_environment_variable( &', &
'             & NAME,VALUE,status=stat,trim_name=.true.)', &
'             if(stat.ne.0)VALUE=''''', &
'            end select', &
'         endif', &
'         if(VALUE.eq.''''.and.present(DEFAULT))VALUE=DEFAULT', &
'      end function get_env', &
'', &
'      end program demo_getenv', &
'', &
'  Typical Results:', &
'', &
'         HOME="/home/urbanjs"', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, get_environment_variable(3fortran)', &
'']

shortname="get_environment_variable"
call process()


case('92','gnu_free_documentation_license')

textblock=[character(len=256) :: &
'', &
'gnu_free_documentation_license(3fortragnu_free_documentation_license(3fortran)', &
'', &
'              Copyright (C) 2000,2001,2002', &
'                Free Software Foundation, Inc.', &
'', &
'              51 Franklin St, Fifth Floor, Boston, MA', &
'                02110-1301  USA Everyone is permitted to copy and distribute', &
'                verbatim copies of this license document, but changing it is', &
'                not allowed.', &
'', &
'       0.  PREAMBLE', &
'', &
'           The purpose of this License is to make a manual, textbook, or other', &
'           functional and useful document "free" in the sense of freedom: to', &
'           assure everyone the effective freedom to copy and redistribute it,', &
'           with or without modifying it, either commercially or', &
'           noncommercially.  Secondarily, this License preserves for the', &
'           author and publisher a way to get credit for their work, while not', &
'           being considered responsible for modifications made by others.', &
'', &
'           This License is a kind of "copyleft", which means that derivative', &
'           works of the document must themselves be free in the same sense. It', &
'           complements the GNU General Public License, which is a copyleft', &
'           license designed for free software.', &
'', &
'           We have designed this License in order to use it for manuals for', &
'           free software, because free software needs free documentation: a', &
'           free program should come with manuals providing the same freedoms', &
'           that the software does. But this License is not limited to software', &
'           manuals; it can be used for any textual work, regardless of subject', &
'           matter or whether it is published as a printed book. We recommend', &
'           this License principally for works whose purpose is instruction or', &
'           reference.', &
'', &
'           1.  APPLICABILITY AND DEFINITIONS', &
'', &
'           This License applies to any manual or other work, in any medium,', &
'           that contains a notice placed by the copyright holder saying it can', &
'           be distributed under the terms of this License. Such a notice', &
'           grants a world-wide, royalty-free license, unlimited in duration,', &
'           to use that work under the conditions stated herein. The', &
'           "Document", below, refers to any such manual or work. Any member of', &
'           the public is a licensee, and is addressed as "you". You accept the', &
'           license if you copy, modify or distribute the work in a way', &
'           requiring permission under copyright law.', &
'', &
'           A "Modified Version" of the Document means any work containing the', &
'           Document or a portion of it, either copied verbatim, or with', &
'           modifications and/or translated into another language.', &
'', &
'           A "Secondary Section" is a named appendix or a front-matter section', &
'           of the Document that deals exclusively with the relationship of the', &
'           publishers or authors of the Document to the Document''s overall', &
'           subject (or to related matters) and contains nothing that could', &
'           fall directly within that overall subject. (Thus, if the Document', &
'           is in part a textbook of mathematics, a Secondary Section may not', &
'           explain any mathematics.) The relationship could be a matter of', &
'           historical connection with the subject or with related matters, or', &
'           of legal, commercial, philosophical, ethical or political position', &
'           regarding them.', &
'', &
'           The "Invariant Sections" are certain Secondary Sections whose', &
'           titles are designated, as being those of Invariant Sections, in the', &
'           notice that says that the Document is released under this License.', &
'           If a section does not fit the above definition of Secondary then it', &
'           is not allowed to be designated as Invariant. The Document may', &
'           contain zero Invariant Sections. If the Document does not identify', &
'           any Invariant Sections then there are none.', &
'', &
'           The "Cover Texts" are certain short passages of text that are', &
'           listed, as Front-Cover Texts or Back-Cover Texts, in the notice', &
'           that says that the Document is released under this License. A', &
'           Front-Cover Text may be at most 5 words, and a Back-Cover Text may', &
'           be at most 25 words.', &
'', &
'           A "Transparent" copy of the Document means a machine-readable copy,', &
'           represented in a format whose specification is available to the', &
'           general public, that is suitable for revising the document', &
'           straightforwardly with generic text editors or (for images composed', &
'           of pixels) generic paint programs or (for drawings) some widely', &
'           available drawing editor, and that is suitable for input to text', &
'           formatters or for automatic translation to a variety of formats', &
'           suitable for input to text formatters. A copy made in an otherwise', &
'           Transparent file format whose markup, or absence of markup, has', &
'           been arranged to thwart or discourage subsequent modification by', &
'           readers is not Transparent. An image format is not Transparent if', &
'           used for any substantial amount of text. A copy that is not', &
'           "Transparent" is called "Opaque".', &
'', &
'           Examples of suitable formats for Transparent copies include plain', &
'           ASCII without markup, Texinfo input format, LaTeX input format,', &
'           SGML or XML using a publicly available DTD, and standard-conforming', &
'           simple HTML, PostScript or PDF designed for human modification.', &
'           Examples of transparent image formats include PNG, XCF and JPG.', &
'           Opaque formats include proprietary formats that can be read and', &
'           edited only by proprietary word processors, SGML or XML for which', &
'           the DTD and/or processing tools are not generally available, and', &
'           the machine-generated HTML, PostScript or PDF produced by some word', &
'           processors for output purposes only.', &
'', &
'           The "Title Page" means, for a printed book, the title page itself,', &
'           plus such following pages as are needed to hold, legibly, the', &
'           material this License requires to appear in the title page. For', &
'           works in formats which do not have any title page as such, "Title', &
'           Page" means the text near the most prominent appearance of the', &
'           work''s title, preceding the beginning of the body of the text.', &
'', &
'           A section "Entitled XYZ" means a named subunit of the Document', &
'           whose title either is precisely XYZ or contains XYZ in parentheses', &
'           following text that translates XYZ in another language. (Here XYZ', &
'           stands for a specific section name mentioned below, such as', &
'           "Acknowledgements", "Dedications", "Endorsements", or "History".)', &
'           To "Preserve the Title" of such a section when you modify the', &
'           Document means that it remains a section "Entitled XYZ" according', &
'           to this definition.', &
'', &
'           The Document may include Warranty Disclaimers next to the notice', &
'           which states that this License applies to the Document. These', &
'           Warranty Disclaimers are considered to be included by reference in', &
'           this License, but only as regards disclaiming warranties: any other', &
'           implication that these Warranty Disclaimers may have is void and', &
'           has no effect on the meaning of this License.', &
'', &
'           2.  VERBATIM COPYING', &
'', &
'           You may copy and distribute the Document in any medium, either', &
'           commercially or noncommercially, provided that this License, the', &
'           copyright notices, and the license notice saying this License', &
'           applies to the Document are reproduced in all copies, and that you', &
'           add no other conditions whatsoever to those of this License. You', &
'           may not use technical measures to obstruct or control the reading', &
'           or further copying of the copies you make or distribute. However,', &
'           you may accept compensation in exchange for copies. If you', &
'           distribute a large enough number of copies you must also follow the', &
'           conditions in section 3.', &
'', &
'           You may also lend copies, under the same conditions stated above,', &
'           and you may publicly display copies.', &
'', &
'           3.  COPYING IN QUANTITY', &
'', &
'           If you publish printed copies (or copies in media that commonly', &
'           have printed covers) of the Document, numbering more than 100, and', &
'           the Document''s license notice requires Cover Texts, you must', &
'           enclose the copies in covers that carry, clearly and legibly, all', &
'           these Cover Texts: Front-Cover Texts on the front cover, and Back-', &
'           Cover Texts on the back cover. Both covers must also clearly and', &
'           legibly identify you as the publisher of these copies. The front', &
'           cover must present the full title with all words of the title', &
'           equally prominent and visible. You may add other material on the', &
'           covers in addition. Copying with changes limited to the covers, as', &
'           long as they preserve the title of the Document and satisfy these', &
'           conditions, can be treated as verbatim copying in other respects.', &
'', &
'           If the required texts for either cover are too voluminous to fit', &
'           legibly, you should put the first ones listed (as many as fit', &
'           reasonably) on the actual cover, and continue the rest onto', &
'           adjacent pages.', &
'', &
'           If you publish or distribute Opaque copies of the Document', &
'           numbering more than 100, you must either include a machine-readable', &
'           Transparent copy along with each Opaque copy, or state in or with', &
'           each Opaque copy a computer-network location from which the general', &
'           network-using public has access to download using public-standard', &
'           network protocols a complete Transparent copy of the Document, free', &
'           of added material. If you use the latter option, you must take', &
'           reasonably prudent steps, when you begin distribution of Opaque', &
'           copies in quantity, to ensure that this Transparent copy will', &
'           remain thus accessible at the stated location until at least one', &
'           year after the last time you distribute an Opaque copy (directly or', &
'           through your agents or retailers) of that edition to the public.', &
'', &
'           It is requested, but not required, that you contact the authors of', &
'           the Document well before redistributing any large number of copies,', &
'           to give them a chance to provide you with an updated version of the', &
'           Document.', &
'', &
'           4.  MODIFICATIONS', &
'', &
'           You may copy and distribute a Modified Version of the Document', &
'           under the conditions of sections 2 and 3 above, provided that you', &
'           release the Modified Version under precisely this License, with the', &
'           Modified Version filling the role of the Document, thus licensing', &
'           distribution and modification of the Modified Version to whoever', &
'           possesses a copy of it.  In addition, you must do these things in', &
'           the Modified Version:', &
'', &
'           o  A. Use in the Title Page (and on the covers, if any) a title', &
'              distinct from that of the Document, and from those of previous', &
'              versions (which should, if there were any, be listed in the', &
'              History section of the Document). You may use the same title as', &
'              a previous version if the original publisher of that version', &
'              gives permission.', &
'', &
'           o  B. List on the Title Page, as authors, one or more persons or', &
'              entities responsible for authorship of the modifications in the', &
'              Modified Version, together with at least five of the principal', &
'              authors of the Document (all of its principal authors, if it has', &
'              fewer than five), unless they release you from this requirement.', &
'', &
'           o  C. State on the Title page the name of the publisher of the', &
'              Modified Version, as the publisher.', &
'', &
'           o  D. Preserve all the copyright notices of the Document.', &
'', &
'           o  E. Add an appropriate copyright notice for your modifications', &
'              adjacent to the other copyright notices.', &
'', &
'           o  F. Include, immediately after the copyright notices, a license', &
'              notice giving the public permission to use the Modified Version', &
'              under the terms of this License, in the form shown in the', &
'              Addendum below.', &
'', &
'           o  G. Preserve in that license notice the full lists of Invariant', &
'              Sections and required Cover Texts given in the Document''s', &
'              license notice.', &
'', &
'           o  H. Include an unaltered copy of this License.', &
'', &
'           o  I. Preserve the section Entitled "History", Preserve its Title,', &
'              and add to it an item stating at least the title, year, new', &
'              authors, and publisher of the Modified Version as given on the', &
'              Title Page. If there is no section Entitled "History" in the', &
'              Document, create one stating the title, year, authors, and', &
'              publisher of the Document as given on its Title Page, then add', &
'              an item describing the Modified Version as stated in the', &
'              previous sentence.', &
'', &
'           o  J. Preserve the network location, if any, given in the Document', &
'              for public access to a Transparent copy of the Document, and', &
'              likewise the network locations given in the Document for', &
'              previous versions it was based on. These may be placed in the', &
'              "History" section. You may omit a network location for a work', &
'              that was published at least four years before the Document', &
'              itself, or if the original publisher of the version it refers to', &
'              gives permission.', &
'', &
'           o  K. For any section Entitled "Acknowledgements" or "Dedications",', &
'              Preserve the Title of the section, and preserve in the section', &
'              all the substance and tone of each of the contributor', &
'              acknowledgements and/or dedications given therein.', &
'', &
'           o  L. Preserve all the Invariant Sections of the Document,', &
'              unaltered in their text and in their titles. Section numbers or', &
'              the equivalent are not considered part of the section titles.', &
'', &
'           o  M. Delete any section Entitled "Endorsements". Such a section', &
'              may not be included in the Modified Version.', &
'', &
'           o  N. Do not retitle any existing section to be Entitled', &
'              "Endorsements" or to conflict in title with any Invariant', &
'              Section.', &
'', &
'           o  O. Preserve any Warranty Disclaimers.', &
'', &
'           If the Modified Version includes new front-matter sections or', &
'           appendices that qualify as Secondary Sections and contain no', &
'           material copied from the Document, you may at your option designate', &
'           some or all of these sections as invariant. To do this, add their', &
'           titles to the list of Invariant Sections in the Modified Version''s', &
'           license notice. These titles must be distinct from any other', &
'           section titles.', &
'', &
'           You may add a section Entitled "Endorsements", provided it contains', &
'           nothing but endorsements of your Modified Version by various', &
'           parties--for example, statements of peer review or that the text', &
'           has been approved by an organization as the authoritative', &
'           definition of a standard.', &
'', &
'           You may add a passage of up to five words as a Front-Cover Text,', &
'           and a passage of up to 25 words as a Back-Cover Text, to the end of', &
'           the list of Cover Texts in the Modified Version. Only one passage', &
'           of Front-Cover Text and one of Back-Cover Text may be added by (or', &
'           through arrangements made by) any one entity. If the Document', &
'           already includes a cover text for the same cover, previously added', &
'           by you or by arrangement made by the same entity you are acting on', &
'           behalf of, you may not add another; but you may replace the old', &
'           one, on explicit permission from the previous publisher that added', &
'           the old one.', &
'', &
'           The author(s) and publisher(s) of the Document do not by this', &
'           License give permission to use their names for publicity for or to', &
'           assert or imply endorsement of any Modified Version.', &
'', &
'           5.  COMBINING DOCUMENTS', &
'', &
'           You may combine the Document with other documents released under', &
'           this License, under the terms defined in section 4 above for', &
'           modified versions, provided that you include in the combination all', &
'           of the Invariant Sections of all of the original documents,', &
'           unmodified, and list them all as Invariant Sections of your', &
'           combined work in its license notice, and that you preserve all', &
'           their Warranty Disclaimers.', &
'', &
'           The combined work need only contain one copy of this License, and', &
'           multiple identical Invariant Sections may be replaced with a single', &
'           copy. If there are multiple Invariant Sections with the same name', &
'           but different contents, make the title of each such section unique', &
'           by adding at the end of it, in parentheses, the name of the', &
'           original author or publisher of that section if known, or else a', &
'           unique number. Make the same adjustment to the section titles in', &
'           the list of Invariant Sections in the license notice of the', &
'           combined work.', &
'', &
'           In the combination, you must combine any sections Entitled', &
'           "History" in the various original documents, forming one section', &
'           Entitled "History"; likewise combine any sections Entitled', &
'           "Acknowledgements", and any sections Entitled "Dedications". You', &
'           must delete all sections Entitled "Endorsements".', &
'', &
'           6.  COLLECTIONS OF DOCUMENTS', &
'', &
'           You may make a collection consisting of the Document and other', &
'           documents released under this License, and replace the individual', &
'           copies of this License in the various documents with a single copy', &
'           that is included in the collection, provided that you follow the', &
'           rules of this License for verbatim copying of each of the documents', &
'           in all other respects.', &
'', &
'           You may extract a single document from such a collection, and', &
'           distribute it individually under this License, provided you insert', &
'           a copy of this License into the extracted document, and follow this', &
'           License in all other respects regarding verbatim copying of that', &
'           document.', &
'', &
'           7.  AGGREGATION WITH INDEPENDENT WORKS', &
'', &
'           A compilation of the Document or its derivatives with other', &
'           separate and independent documents or works, in or on a volume of a', &
'           storage or distribution medium, is called an "aggregate" if the', &
'           copyright resulting from the compilation is not used to limit the', &
'           legal rights of the compilation''s users beyond what the individual', &
'           works permit. When the Document is included in an aggregate, this', &
'           License does not apply to the other works in the aggregate which', &
'           are not themselves derivative works of the Document.', &
'', &
'           If the Cover Text requirement of section 3 is applicable to these', &
'           copies of the Document, then if the Document is less than one half', &
'           of the entire aggregate, the Document''s Cover Texts may be placed', &
'           on covers that bracket the Document within the aggregate, or the', &
'           electronic equivalent of covers if the Document is in electronic', &
'           form. Otherwise they must appear on printed covers that bracket the', &
'           whole aggregate.', &
'', &
'           8.  TRANSLATION', &
'', &
'           Translation is considered a kind of modification, so you may', &
'           distribute translations of the Document under the terms of section', &
'           4. Replacing Invariant Sections with translations requires special', &
'           permission from their copyright holders, but you may include', &
'           translations of some or all Invariant Sections in addition to the', &
'           original versions of these Invariant Sections. You may include a', &
'           translation of this License, and all the license notices in the', &
'           Document, and any Warranty Disclaimers, provided that you also', &
'           include the original English version of this License and the', &
'           original versions of those notices and disclaimers. In case of a', &
'           disagreement between the translation and the original version of', &
'           this License or a notice or disclaimer, the original version will', &
'           prevail.', &
'', &
'           If a section in the Document is Entitled "Acknowledgements",', &
'           "Dedications", or "History", the requirement (section 4) to', &
'           Preserve its Title (section 1) will typically require changing the', &
'           actual title.', &
'', &
'           9.  TERMINATION', &
'', &
'           You may not copy, modify, sublicense, or distribute the Document', &
'           except as expressly provided for under this License. Any other', &
'           attempt to copy, modify, sublicense or distribute the Document is', &
'           void, and will automatically terminate your rights under this', &
'           License. However, parties who have received copies, or rights, from', &
'           you under this License will not have their licenses terminated so', &
'           long as such parties remain in full compliance.', &
'', &
'           10. FUTURE REVISIONS OF THIS LICENSE', &
'', &
'           The Free Software Foundation may publish new, revised versions of', &
'           the GNU Free Documentation License from time to time. Such new', &
'           versions will be similar in spirit to the present version, but may', &
'           differ in detail to address new problems or concerns. See', &
'           http://www.gnu.org/copyleft/.', &
'', &
'           Each version of the License is given a distinguishing version', &
'           number. If the Document specifies that a particular numbered', &
'           version of this License "or any later version" applies to it, you', &
'           have the option of following the terms and conditions either of', &
'           that specified version or of any later version that has been', &
'           published (not as a draft) by the Free Software Foundation. If the', &
'           Document does not specify a version number of this License, you may', &
'           choose any version ever published (not as a draft) by the Free', &
'           Software Foundation.', &
'', &
'           ADDENDUM: How to use this License for your documents', &
'', &
'           To use this License in a document you have written, include a copy', &
'           of the License in the document and put the following copyright and', &
'           license notices just after the title page:', &
'', &
'               Copyright (c)  YEAR  YOUR NAME.', &
'               Permission is granted to copy, distribute and/or modify this document', &
'               under the terms of the GNU Free Documentation License, Version 1.2', &
'               or any later version published by the Free Software Foundation;', &
'               with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.', &
'               A copy of the license is included in the section entitled "GNU', &
'               Free Documentation License".', &
'', &
'           If you have Invariant Sections, Front-Cover Texts and Back-Cover', &
'           Texts, replace the "with...Texts." line with this:', &
'', &
'               with the Invariant Sections being LIST THEIR TITLES, with the', &
'               Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.', &
'', &
'           If you have Invariant Sections without Cover Texts, or some other', &
'           combination of the three, merge those two alternatives to suit the', &
'           situation.', &
'', &
'           If your document contains nontrivial examples of program code, we', &
'           recommend releasing these examples in parallel under your choice of', &
'           free software license, such as the GNU General Public License, to', &
'           permit their use in free software.', &
'', &
'           fortran-lang intrinsic descriptions', &
'', &
'                              Septembegnu_free_documentation_license(3fortran)', &
'']

shortname="gnu_free_documentation_license"
call process()


case('93','huge')

textblock=[character(len=256) :: &
'', &
'huge(3fortran)                                                  huge(3fortran)', &
'', &
'NAME', &
'  HUGE(3) - [NUMERIC MODEL] Largest number of a type and kind', &
'', &
'SYNTAX', &
'  result = huge(x)', &
'', &
'         function huge(x) result(answer)', &
'         TYPE(kind=KIND),intent(in) :: x', &
'         TYPE(kind=KIND) :: answer', &
'', &
'  where TYPE may be real or integer and KIND is any supported associated kind.', &
'', &
'DESCRIPTION', &
'  HUGE(X) returns the largest number that is not an infinity for the kind and', &
'  type of X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be an arbitrary value of type real or integer. The value is', &
'     used merely to determine what kind and type of scalar is being queried.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as x and is the largest value', &
'  supported by the specified model.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_huge', &
'      implicit none', &
'      character(len=*),parameter :: f=''(i2,1x,2(i11,1x),f14.0:,1x,l1,1x,a)''', &
'      integer :: i,j,k,biggest', &
'      real :: v, w', &
'         ! basic', &
'         print *, huge(0), huge(0.0), huge(0.0d0)', &
'         print *, tiny(0.0), tiny(0.0d0)', &
'', &
'         ! advanced', &
'         biggest=huge(0)', &
'         ! be careful of overflow when using integers in computation', &
'         do i=1,14', &
'            j=6**i   ! Danger, Danger', &
'            w=6**i   ! Danger, Danger', &
'            v=6.0**i', &
'            k=v      ! Danger, Danger', &
'            if(v.gt.biggest)then', &
'               write(*,f) i, j, k, v, v.eq.w, ''wrong j and k and w''', &
'            else', &
'               write(*,f) i, j, k, v, v.eq.w', &
'            endif', &
'         enddo', &
'      end program demo_huge', &
'', &
'  Results:', &
'', &
'        2147483647  3.4028235E+38  1.797693134862316E+308', &
'        1.1754944E-38  2.225073858507201E-308', &
'', &
'          1      6           6             6. T', &
'          2      36          36            36. T', &
'          3      216         216           216. T', &
'          4      1296        1296          1296. T', &
'          5      7776        7776          7776. T', &
'          6      46656       46656         46656. T', &
'          7      279936      279936        279936. T', &
'          8      1679616     1679616       1679616. T', &
'          9      10077696    10077696      10077696. T', &
'          10     60466176    60466176      60466176. T', &
'          11     362797056   362797056     362797056. T', &
'          12    -2118184960 -2147483648    2176782336. F wrong for j and k and w', &
'          13     175792128  -2147483648   13060694016. F wrong for j and k and w', &
'          14     1054752768 -2147483648   78364164096. F wrong for j and k and w', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                huge(3fortran)', &
'']

shortname="huge"
call process()


case('94','hypot')

textblock=[character(len=256) :: &
'', &
'hypot(3fortran)                                                hypot(3fortran)', &
'', &
'NAME', &
'  HYPOT(3) - [MATHEMATICS] returns the distance between the point and the', &
'  origin.', &
'', &
'SYNTAX', &
'  result = hypot(x, y)', &
'', &
'         real(kind=KIND) elemental function hypot(x,y) result(value)', &
'         real(kind=KIND),intent(in) :: x, y', &
'', &
'  where X,Y,VALUE shall all be of the same KIND.', &
'', &
'DESCRIPTION', &
'  HYPOT(X,Y) is referred to as the Euclidean distance function. It is equal to', &
'  $\sqrt{x^2+y^2}$, without undue underflow or overflow.', &
'', &
'  In mathematics, the Euclidean distance between two points in Euclidean space', &
'  is the length of a line segment between two points.', &
'', &
'  HYPOT(X,Y) returns the distance between the point <X,Y> and the origin.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real.', &
'', &
'  o  Y : The type and kind type parameter shall be the same as X.', &
'', &
'RETURNS', &
'  The return value has the same type and kind type parameter as X.', &
'', &
'  The result is the positive magnitude of the distance of the point <X,Y> from', &
'  the origin <0.0,0.0> .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_hypot', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'       & real_kinds, real32, real64, real128', &
'      implicit none', &
'      real(kind=real32) :: x, y', &
'      real(kind=real32),allocatable :: xs(:), ys(:)', &
'      integer :: i', &
'      character(len=*),parameter :: f=''(a,/,SP,*(3x,g0,1x,g0:,/))''', &
'', &
'         x = 1.e0_real32', &
'         y = 0.5e0_real32', &
'', &
'         write(*,*)', &
'         write(*,''(*(g0))'')''point <'',x,'','',y,''> is '',hypot(x,y)', &
'         write(*,''(*(g0))'')''units away from the origin''', &
'         write(*,*)', &
'', &
'         ! elemental', &
'         xs=[  x,  x**2,  x*10.0,  x*15.0, -x**2  ]', &
'         ys=[  y,  y**2, -y*20.0,  y**2,   -y**2  ]', &
'', &
'         write(*,f)"the points",(xs(i),ys(i),i=1,size(xs))', &
'         write(*,f)"have distances from the origin of ",hypot(xs,ys)', &
'         write(*,f)"the closest is",minval(hypot(xs,ys))', &
'', &
'      end program demo_hypot', &
'', &
'  Results:', &
'', &
'         point <1.00000000,0.500000000> is 1.11803401', &
'         units away from the origin', &
'', &
'         the points', &
'            +1.00000000 +0.500000000', &
'            +1.00000000 +0.250000000', &
'            +10.0000000 -10.0000000', &
'            +15.0000000 +0.250000000', &
'            -1.00000000 -0.250000000', &
'         have distances from the origin of', &
'            +1.11803401 +1.03077638', &
'            +14.1421356 +15.0020828', &
'            +1.03077638', &
'         the closest is', &
'            +1.03077638', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               hypot(3fortran)', &
'']

shortname="hypot"
call process()


case('95','iachar')

textblock=[character(len=256) :: &
'', &
'iachar(3fortran)                                              iachar(3fortran)', &
'', &
'NAME', &
'  IACHAR(3) - [CHARACTER:CONVERSION] Code in ASCII collating sequence', &
'', &
'SYNTAX', &
'  result = iachar(c, kind)', &
'', &
'DESCRIPTION', &
'  IACHAR(c) returns the code for the ASCII character in the first character', &
'  position of C.', &
'', &
'ARGUMENTS', &
'  o  C : Shall be a scalar character, with intent(in)', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iachar', &
'      implicit none', &
'      ! create function to convert uppercase letters to lowercase', &
'         write(*,''(a)'')lower(''abcdefg ABCDEFG'')', &
'      contains', &
'      !', &
'      elemental pure function lower(str) result (string)', &
'      ! Changes a string to lowercase', &
'      character(*), intent(In)     :: str', &
'      character(len(str))          :: string', &
'      integer                      :: i', &
'         string = str', &
'         ! step thru each letter in the string in specified range', &
'         do i = 1, len(str)', &
'            select case (str(i:i))', &
'            case (''A'':''Z'') ! change letter to miniscule', &
'               string(i:i) = char(iachar(str(i:i))+32)', &
'            case default', &
'            end select', &
'         end do', &
'      end function lower', &
'      !', &
'      end program demo_iachar', &
'', &
'  Results:', &
'', &
'         abcdefg abcdefg', &
'', &
'NOTE', &
'  See ICHAR(3) for a discussion of converting between numerical values and', &
'  formatted string representations.', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument - Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  ACHAR(3), CHAR(3), ICHAR(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              iachar(3fortran)', &
'']

shortname="iachar"
call process()


case('96','iall')

textblock=[character(len=256) :: &
'', &
'iall(3fortran)                                                  iall(3fortran)', &
'', &
'NAME', &
'  IALL(3) - [BIT:LOGICAL] Bitwise and of array elements', &
'', &
'SYNTAX', &
'  result = iall(array, mask)', &
'', &
'          or', &
'', &
'  result = iall(array, dim, mask)', &
'', &
'DESCRIPTION', &
'  Reduces with bitwise and the elements of ARRAY along dimension DIM if the', &
'  corresponding element in MASK is .true..', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer', &
'', &
'  o  DIM : (Optional) shall be a scalar of type integer with a value in the', &
'     range from 1 TO N, where N equals the rank of ARRAY.', &
'', &
'  o  MASK : (Optional) shall be of type logical and either be a scalar or an', &
'     array of the same shape as ARRAY.', &
'', &
'RETURNS', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM is absent, a scalar with the bitwise all of all elements in ARRAY is', &
'  returned. Otherwise, an array of rank N-1, where N equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iall', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'       & int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int8) :: a(2)', &
'', &
'         a(1) = int(b''00100100'')', &
'         a(2) = int(b''01101010'')', &
'', &
'         print ''(b8.8)'', iall(a)', &
'', &
'      end program demo_iall', &
'', &
'  Results:', &
'', &
'         00100000', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  IANY(3), IPARITY(3), IAND(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                iall(3fortran)', &
'']

shortname="iall"
call process()


case('97','iand')

textblock=[character(len=256) :: &
'', &
'iand(3fortran)                                                  iand(3fortran)', &
'', &
'NAME', &
'  IAND(3) - [BIT:LOGICAL] Bitwise logical and', &
'', &
'SYNTAX', &
'  result = iand(i, j)', &
'', &
'DESCRIPTION', &
'  Bitwise logical AND.', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'  o  J : The type shall be integer, of the same kind as I.', &
'', &
'RETURNS', &
'  The return type is integer, of the same kind as the arguments. (If the', &
'  argument kinds differ, it is of the same kind as the larger argument.)', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iand', &
'      implicit none', &
'      integer :: a, b', &
'            data a / z''f'' /, b / z''3'' /', &
'            write (*,*) iand(a, b)', &
'      end program demo_iand', &
'', &
'  Results:', &
'', &
'    3', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), IBCLR(3), NOT(3), BTEST(3), IBCLR(3), IBITS(3), IBSET(3), IOR(3),', &
'  IEOR(3), MVBITS(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                iand(3fortran)', &
'']

shortname="iand"
call process()


case('98','iany')

textblock=[character(len=256) :: &
'', &
'iany(3fortran)                                                  iany(3fortran)', &
'', &
'NAME', &
'  IANY(3) - [BIT:LOGICAL] Bitwise or of array elements', &
'', &
'SYNTAX', &
'  result = iany(array, mask)', &
'', &
'          or', &
'', &
'  result = iany(array, dim, mask)', &
'', &
'DESCRIPTION', &
'  Reduces with bitwise or (inclusive or) the elements of ARRAY along dimension', &
'  DIM if the corresponding element in MASK is .true..', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer', &
'', &
'  o  DIM : (Optional) shall be a scalar of type integer with a value in the', &
'     range from 1 TO N, where N equals the rank of ARRAY.', &
'', &
'  o  MASK : (Optional) shall be of type logical and either be a scalar or an', &
'     array of the same shape as ARRAY.', &
'', &
'RETURNS', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM is absent, a scalar with the bitwise or of all elements in ARRAY is', &
'  returned. Otherwise, an array of rank N-1, where N equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iany', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'       & int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int8) :: a(2)', &
'           a(1) = int(b''00100100'')', &
'           a(2) = int(b''01101010'')', &
'           print ''(b8.8)'', iany(a)', &
'      end program demo_iany', &
'', &
'  Results:', &
'', &
'         01101110', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  IPARITY(3), IALL(3), IOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                iany(3fortran)', &
'']

shortname="iany"
call process()


case('99','ibclr')

textblock=[character(len=256) :: &
'', &
'ibclr(3fortran)                                                ibclr(3fortran)', &
'', &
'NAME', &
'  IBCLR(3) - [BIT:SET] Clear bit', &
'', &
'SYNTAX', &
'  result = ibclr(i, pos)', &
'', &
'DESCRIPTION', &
'  IBCLR returns the value of I with the bit at position POS set to zero.', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'  o  POS : The type shall be integer. A value of zero refers to the least', &
'     significant bit. POS is an INTENT(IN) scalar or array of type integer.', &
'     The value of POS must be within the range zero to (BIT_SIZE(I)-1).', &
'', &
'RETURNS', &
'  The return value is of type integer and of the same kind as I.', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), NOT(3), BTEST(3), IBCLR(3), IBITS(3), IBSET(3), IAND(3), IOR(3),', &
'  IEOR(3), MVBITS(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               ibclr(3fortran)', &
'']

shortname="ibclr"
call process()


case('100','ibits')

textblock=[character(len=256) :: &
'', &
'ibits(3fortran)                                                ibits(3fortran)', &
'', &
'NAME', &
'  IBITS(3) - [BIT:COPY] Bit extraction', &
'', &
'SYNTAX', &
'  result = ibits(i, pos, len)', &
'', &
'DESCRIPTION', &
'  IBITS extracts a field of length LEN from I, starting from bit position POS', &
'  and extending left for LEN bits. The result is right-justified and the', &
'  remaining bits are zeroed. The value of pos+len must be less than or equal', &
'  to the value BIT_SIZE(I).', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'  o  POS : The type shall be integer. A value of zero refers to the least', &
'     significant bit.', &
'', &
'  o  LEN : The type shall be integer.', &
'', &
'RETURNS', &
'  The return value is of type integer and of the same kind as I.', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), IBCLR(3), NOT(3), BTEST(3), IBCLR(3), IBSET(3), IAND(3), IOR(3),', &
'  IEOR(3), MVBITS(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               ibits(3fortran)', &
'']

shortname="ibits"
call process()


case('101','ibset')

textblock=[character(len=256) :: &
'', &
'ibset(3fortran)                                                ibset(3fortran)', &
'', &
'NAME', &
'  IBSET(3) - [BIT:SET] Set bit', &
'', &
'SYNTAX', &
'  result = ibset(i, pos)', &
'', &
'DESCRIPTION', &
'  IBSET returns the value of I with the bit at position POS set to one.', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'  o  POS : The type shall be integer. A value of zero refers to the least', &
'     significant bit. pos is an INTENT(IN) scalar or array of type integer.', &
'     The value of pos must be within the range zero to (BIT_SIZE(I)-1).', &
'', &
'RETURNS', &
'  The return value is of type integer and of the same kind as I.', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), IBCLR(3), NOT(3), BTEST(3), IBCLR(3), IBITS(3), IAND(3), IOR(3),', &
'  IEOR(3), MVBITS(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               ibset(3fortran)', &
'']

shortname="ibset"
call process()


case('102','ichar')

textblock=[character(len=256) :: &
'', &
'ichar(3fortran)                                                ichar(3fortran)', &
'', &
'NAME', &
'  ICHAR(3) - [CHARACTER:CONVERSION] Character-to-integer conversion function', &
'', &
'SYNTAX', &
'  elemental function ichar(c,kind)', &
'', &
'          character(len=1),intent(in) :: c', &
'          integer,intent(in),optional :: kind', &
'', &
'DESCRIPTION', &
'  ICHAR(C) returns the code for the character in the system''s native character', &
'  set. The correspondence between characters and their codes is not', &
'  necessarily the same across different Fortran implementations. For example,', &
'  a platform using EBCDIC would return different values than an ASCII', &
'  platform.', &
'', &
'  See IACHAR(3) for specifically working with the ASCII character set.', &
'', &
'ARGUMENTS', &
'  o  C : Shall be a scalar character, with INTENT(IN)', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ichar', &
'      implicit none', &
'      integer i', &
'', &
'         write(*,*)ichar([''a'',''z'',''A'',''Z''])', &
'         do i=0,127', &
'            call printme()', &
'         enddo', &
'', &
'      contains', &
'', &
'         subroutine printme()', &
'         character(len=1) :: letter', &
'', &
'            letter=char(i)', &
'            select case(i)', &
'            case (:31,127:)', &
'               write(*,''(1x,i0.3,1x,"HEX=",z2.2,1x,i0)'')i,letter,ichar(letter)', &
'            case default', &
'               write(*,''(1x,i0.3,1x,a,1x,i0)'')i,letter,ichar(letter)', &
'            end select', &
'', &
'         end subroutine printme', &
'', &
'      end program demo_ichar', &
'', &
'NOTE', &
'  No intrinsic exists to convert between a numeric value and a formatted', &
'  character string representation -- for instance, given the character value', &
'  ''154'', obtaining an integer or real value with the value 154, or vice versa.', &
'  Instead, this functionality is provided by internal-file I/O, as in the', &
'  following example:', &
'', &
'      program read_val', &
'      integer value', &
'      character(len=10) string, string2', &
'         string = ''154''', &
'', &
'         ! Convert a string to a numeric value', &
'         read (string,''(I10)'') value', &
'         print *, value', &
'', &
'         ! Convert a value to a formatted string', &
'         write (string2,''(I10)'') value', &
'         print *, string2', &
'      end program read_val', &
'', &
'  Results:', &
'', &
'                  154', &
'  154', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument -Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  ACHAR(3), CHAR(3), IACHAR(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               ichar(3fortran)', &
'']

shortname="ichar"
call process()


case('103','ieor')

textblock=[character(len=256) :: &
'', &
'ieor(3fortran)                                                  ieor(3fortran)', &
'', &
'NAME', &
'  IEOR(3) - [BIT:LOGICAL] Bitwise logical exclusive or', &
'', &
'SYNTAX', &
'  result = ieor(i, j)', &
'', &
'DESCRIPTION', &
'  IEOR returns the bitwise Boolean exclusive-OR of I and J.', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'  o  J : The type shall be integer, of the same kind as I.', &
'', &
'RETURNS', &
'  The return type is integer, of the same kind as the arguments. (If the', &
'  argument kinds differ, it is of the same kind as the larger argument.)', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), IBCLR(3), NOT(3), BTEST(3), IBCLR(3), IBITS(3), IBSET(3), IAND(3),', &
'  IOR(3), MVBITS(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                ieor(3fortran)', &
'']

shortname="ieor"
call process()


case('104','image_index')

textblock=[character(len=256) :: &
'', &
'image_index(3fortran)                                    image_index(3fortran)', &
'', &
'NAME', &
'  IMAGE_INDEX(3) - [COLLECTIVE] Cosubscript to image index conversion', &
'', &
'SYNTAX', &
'  result = image_index(coarray, sub)', &
'', &
'DESCRIPTION', &
'  Returns the image index belonging to a cosubscript.', &
'', &
'ARGUMENTS', &
'  o  COARRAY : Coarray of any type.', &
'', &
'  o  SUB : default integer rank-1 array of a size equal to the corank of', &
'     COARRAY.', &
'', &
'RETURNS', &
'  Scalar default integer with the value of the image index which corresponds', &
'  to the cosubscripts. For invalid cosubscripts the result is zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo image_index', &
'      implicit none', &
'      integer :: array[2,-1:4,8,*]', &
'         ! Writes  28 (or 0 if there are fewer than 28 images)', &
'         write (*,*) image_index(array, [2,0,3,1])', &
'      end demo image_index', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  THIS_IMAGE(3), NUM_IMAGES(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         image_index(3fortran)', &
'']

shortname="image_index"
call process()


case('105','index')

textblock=[character(len=256) :: &
'', &
'index(3fortran)                                                index(3fortran)', &
'', &
'NAME', &
'  INDEX(3) - [CHARACTER:SEARCH] Position of a substring within a string', &
'', &
'SYNTAX', &
'  index(string, substring, back, kind) result(start)', &
'', &
'           character(len=*),intent(in) :: string', &
'           character(len=*),intent(in) :: substring', &
'           logical,intent(in),optional :: back', &
'           integer,intent(in),optional :: kind', &
'           integer(kind=KIND)          :: start', &
'', &
'DESCRIPTION', &
'  Returns the position of the start of the leftmost or rightmost occurrence of', &
'  string SUBSTRING in STRING, counting from one. If SUBSTRING is not present', &
'  in STRING, zero is returned.', &
'', &
'ARGUMENTS', &
'  o  STRING : string to be searched', &
'', &
'  o  SUBSTRING : string to attempt to locate in STRING', &
'', &
'  o  BACK : If the BACK argument is present and true, the return value is the', &
'     start of the rightmost occurrence rather than the leftmost.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RETURNS', &
'  o  START : The return value is of type integer and of kind KIND. If KIND is', &
'     absent, the return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Example program', &
'', &
'      program demo_index', &
'      implicit none', &
'      character(len=*),parameter :: str=&', &
'         ''Search this string for this expression''', &
'         !1234567890123456789012345678901234567890', &
'         write(*,*)&', &
'            index(str,''this'').eq.8,              &', &
'            ! return value is counted from the left end even if BACK=.TRUE.', &
'            index(str,''this'',back=.true.).eq.24, &', &
'            ! INDEX is case-sensitive', &
'            index(str,''This'').eq.0', &
'      end program demo_index', &
'', &
'  Expected Results:', &
'', &
'   T T T', &
'STANDARD', &
'  FORTRAN 77 and later, with KIND argument Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               index(3fortran)', &
'']

shortname="index"
call process()


case('106','int')

textblock=[character(len=256) :: &
'', &
'int(3fortran)                                                    int(3fortran)', &
'', &
'NAME', &
'  INT(3) - [TYPE:NUMERIC] Convert to integer type by truncating towards zero', &
'', &
'SYNTAX', &
'  result = int(a, kind)', &
'', &
'       integer(kind=KIND) elemental function int(a,kind)', &
'       TYPE(kind=KIND),intent(in),optional :: a', &
'       integer,optional :: kind', &
'', &
'DESCRIPTION', &
'  Convert to integer type by truncating towards zero.', &
'', &
'ARGUMENTS', &
'  o  A : Shall be of type integer, real, or complex or a BOZ-literal-constant.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'     If not present the returned type is that of default integer type.', &
'', &
'RETURNS', &
'  returns an integer variable or array applying the following rules:', &
'', &
'  CASE:', &
'', &
'  1.  If A is of type integer, INT(a) = a', &
'', &
'  2.  If A is of type real and |A| < 1, INT(A) equals 0. If |A| >= 1, then', &
'      INT(A) equals the integer whose magnitude does not exceed A and whose', &
'      sign is the same as the sign of A.', &
'', &
'  3.  If A is of type complex, rule 2 is applied to the real part of A.', &
'', &
'  4.  If a is a boz-literal constant, it is treated as an integer with the', &
'      kind specified.', &
'', &
'      The interpretation of a bit sequence whose most significant bit is 1 is', &
'      processor dependent.', &
'', &
'  The result is undefined if it cannot be represented in the specified integer', &
'  type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_int', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer :: i = 42', &
'      complex :: z = (-3.7, 1.0)', &
'      real :: x=-10.5, y=10.5', &
'', &
'         print *, int(x), int(y)', &
'', &
'         print *, int(i)', &
'', &
'         print *, int(z), int(z,8)', &
'         ! elemental', &
'         print *, int([-10.9,-10.5,-10.3,10.3,10.5,10.9])', &
'         ! note int(3) truncates towards zero', &
'', &
'         ! CAUTION:', &
'         ! a number bigger than a default integer can represent', &
'         ! produces an incorrect result and is not required to', &
'         ! be detected by the program.', &
'         x=real(huge(0))+1000.0', &
'         print *, int(x),x', &
'         ! using a larger kind', &
'         print *, int(x,kind=int64),x', &
'', &
'         print *, int(&', &
'         & B"111111111111111111111111111111111111111111111111111111111111111",&', &
'         & kind=int64)', &
'         print *, int(O"777777777777777777777",kind=int64)', &
'         print *, int(Z"7FFFFFFFFFFFFFFF",kind=int64)', &
'', &
'         ! elemental', &
'         print *', &
'         print *,int([ &', &
'         &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'         &  0.0,   &', &
'         &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'', &
'      end program demo_int', &
'', &
'  Results:', &
'', &
'                  -10   10', &
'                   42', &
'                   -3  -3', &
'                  -10  -10  -10   10   10  10', &
'', &
'    -2147483648', &
'      2.14748467E+09', &
'', &
'      2147484672', &
'        2.14748467E+09 9223372036854775807 9223372036854775807', &
'        9223372036854775807', &
'', &
'    -2', &
'      -2          -2          -2          -1', &
'', &
'    -1', &
'      0           0           0           1', &
'', &
'      1 2           2           2           2', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  AINT(3), ANINT(3), NINT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 int(3fortran)', &
'']

shortname="int"
call process()


case('107','ior')

textblock=[character(len=256) :: &
'', &
'ior(3fortran)                                                    ior(3fortran)', &
'', &
'NAME', &
'  IOR(3) - [BIT:LOGICAL] Bitwise logical inclusive or', &
'', &
'SYNTAX', &
'  result = ior(i, j) integer,intent(in) :: i integer,intent(in) :: j', &
'', &
'DESCRIPTION', &
'  IOR returns the bit-wise Boolean inclusive-OR of I and J.', &
'', &
'ARGUMENTS', &
'  o  I : an integer scalar or array.', &
'', &
'  o  J : integer scalar or array, of the same kind as I.', &
'', &
'RETURNS', &
'  The return type is integer, of the same kind as the arguments. (If the', &
'  argument kinds differ, it is of the same kind as the larger argument.)', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ior', &
'      implicit none', &
'      integer :: i, j, k', &
'         i=53       ! i=00110101 binary (lowest order byte)', &
'         j=45       ! j=00101101 binary (lowest order byte)', &
'         k=ior(i,j) ! k=00111101 binary (lowest order byte), k=61 decimal', &
'         write(*,''(i8,1x,b8.8)'')i,i,j,j,k,k', &
'      end program demo_ior', &
'', &
'  Results:', &
'', &
'               53 00110101', &
'               45 00101101', &
'               61 00111101', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), IBCLR(3), NOT(3), BTEST(3), IBCLR(3), IBITS(3), IBSET(3), IAND(3),', &
'  IEOR(3), MVBITS(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 ior(3fortran)', &
'']

shortname="ior"
call process()


case('108','iparity')

textblock=[character(len=256) :: &
'', &
'iparity(3fortran)                                            iparity(3fortran)', &
'', &
'NAME', &
'  IPARITY(3) - [BIT:LOGICAL] Bitwise exclusive or of array elements', &
'', &
'SYNTAX', &
'  result = iparity(array, mask)', &
'', &
'         or', &
'', &
'  result = iparity(array, dim, mask)', &
'', &
'DESCRIPTION', &
'  Reduces with bitwise xor (exclusive or) the elements of ARRAY along', &
'  dimension DIM if the corresponding element in MASK is .true..', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer', &
'', &
'  o  DIM : (Optional) shall be a scalar of type integer with a value in the', &
'     range from "1" TO "N", where "N" equals the rank of ARRAY.', &
'', &
'  o  MASK : (Optional) shall be of type logical and either be a scalar or an', &
'     array of the same shape as ARRAY.', &
'', &
'RETURNS', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM is absent, a scalar with the bitwise xor of all elements in ARRAY is', &
'  returned. Otherwise, an array of rank N-1, where N equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iparity', &
'      implicit none', &
'      integer, dimension(2) :: a', &
'        a(1) = int(b''00100100'')', &
'        a(2) = int(b''01101010'')', &
'        print ''(b8.8)'', iparity(a)', &
'      end program demo_iparity', &
'', &
'  Results:', &
'', &
'         01001110', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  IANY(3), IALL(3), IEOR(3), PARITY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             iparity(3fortran)', &
'']

shortname="iparity"
call process()


case('109','is_contiguous')

textblock=[character(len=256) :: &
'', &
'is_contiguous(3fortran)                                is_contiguous(3fortran)', &
'', &
'NAME', &
'  IS_CONTIGUOUS(3) - [ARRAY INQUIRY] test if object is contiguous', &
'', &
'SYNTAX', &
'  result = is_contiguous(a)', &
'', &
'DESCRIPTION', &
'  True if and only if an object is contiguous.', &
'', &
'  An object is contiguous if it is', &
'', &
'  o  (1) an object with the CONTIGUOUS attribute,', &
'', &
'  o  (2) a nonpointer whole array that is not assumed-shape,', &
'', &
'  o  (3) an assumed-shape array that is argument associated with an array that', &
'     is contiguous,', &
'', &
'  o  (4) an array allocated by an ALLOCATE statement,', &
'', &
'  o  (5) a pointer associated with a contiguous target, or', &
'', &
'  o  (6) a nonzero-sized array section provided that', &
'', &
'     o  (A) its base object is contiguous,', &
'', &
'     o  (B) it does not have a vector subscript,', &
'', &
'     o  (C) the elements of the section, in array element order, are a subset', &
'        of the base object elements that are consecutive in array element', &
'        order,', &
'', &
'     o  (D) if the array is of type character and a substring-range appears,', &
'        the substring-range specifies all of the characters of the parent-', &
'        string,', &
'', &
'     o  (E) only its final part-ref has nonzero rank, and', &
'', &
'     o  (F) it is not the real or imaginary part of an array of type complex.', &
'', &
'  An object is not contiguous if it is an array subobject, and', &
'', &
'  o  the object has two or more elements,', &
'', &
'  o  the elements of the object in array element order are not consecutive in', &
'     the elements of the base object,', &
'', &
'  o  the object is not of type character with length zero, and', &
'', &
'  o  the object is not of a derived type that has no ultimate components other', &
'     than zero-sized arrays and', &
'', &
'  o  characters with length zero.', &
'', &
'  It is processor-dependent whether any other object is contiguous.', &
'', &
'ARGUMENTS', &
'  o  A : may be of any type. It shall be an array. If it is a pointer it shall', &
'     be associated.', &
'', &
'RETURNS', &
'  o  RESULT : of type Default logical scalar. The result has the value true if', &
'     A is contiguous, and false otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_is_contiguous', &
'      implicit none', &
'      intrinsic is_contiguous', &
'      real, DIMENSION (1000, 1000), TARGET :: A', &
'      real, DIMENSION (:, :), POINTER       :: IN, OUT', &
'         IN => A              ! Associate IN with target A', &
'         OUT => A(1:1000:2,:) ! Associate OUT with subset of target A', &
'         !', &
'         write(*,*)''IN is '',IS_CONTIGUOUS(IN)', &
'         write(*,*)''OUT is '',IS_CONTIGUOUS(OUT)', &
'         !', &
'      end program demo_is_contiguous', &
'', &
'  Results:', &
'', &
'          IN is  T', &
'          OUT is  F', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022       is_contiguous(3fortran)', &
'']

shortname="is_contiguous"
call process()


case('110','ishft')

textblock=[character(len=256) :: &
'', &
'ishft(3fortran)                                                ishft(3fortran)', &
'', &
'NAME', &
'  ISHFT(3) - [BIT:SHIFT] Shift bits', &
'', &
'SYNTAX', &
'  elemental integer(kind=KIND) function ishft(i, shift )', &
'', &
'           integer(kind=KIND),intent(in)     :: i', &
'           integer(kind=SHIFTKIND,intent(in) :: shift', &
'', &
'  where KIND and SHIFTKIND may be any supported integer kind, but where the', &
'  kind for I dictates the kind of the returned value.', &
'', &
'DESCRIPTION', &
'  ISHFT(3) returns a value corresponding to I with all of the bits shifted', &
'  SHIFT places left or right as specified by the sign and magnitude of SHIFT.', &
'', &
'  Bits shifted out from the left end or right end are lost; zeros are shifted', &
'  in from the opposite end.', &
'', &
'ARGUMENTS', &
'  o  I : The value specifying the pattern of bits to shift', &
'', &
'  o  SHIFT : A value of SHIFT greater than zero corresponds to a left shift, a', &
'     value of zero corresponds to no shift, and a value less than zero', &
'     corresponds to a right shift.', &
'', &
'     If the absolute value of SHIFT is greater than BIT_SIZE(I), the value is', &
'     undefined.', &
'', &
'RETURNS', &
'  The return value has the same characteristics (shape, kind, ...) as I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ishft', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer             :: shift', &
'      integer             :: i', &
'      character(len=*),parameter :: g=''(b32.32,1x,i0)''', &
'', &
'         write(*,*) ishft(3, 1),'' <== typically should have the value 6''', &
'', &
'         shift=4', &
'         write(*,g) ishft(huge(0),shift), shift', &
'         shift=0', &
'         write(*,g) ishft(huge(0),shift), shift', &
'         shift=-4', &
'         write(*,g) ishft(huge(0),shift), shift', &
'      end program demo_ishft', &
'', &
'  Results:', &
'', &
'      >              6  <== typically should have the value 6', &
'      >   11111111111111111111111111110000 4', &
'      >   01111111111111111111111111111111 0', &
'      >   00000111111111111111111111111111 -4', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  ISHFTC(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               ishft(3fortran)', &
'']

shortname="ishft"
call process()


case('111','ishftc')

textblock=[character(len=256) :: &
'', &
'ishftc(3fortran)                                              ishftc(3fortran)', &
'', &
'NAME', &
'  ISHFTC(3) - [BIT:SHIFT] logical shift: shift rightmost bits circularly', &
'', &
'SYNTAX', &
'  elemental integer(kind=KIND) function ishftc(i, shift, size)', &
'', &
'       integer(kind=KIND),intent(in)     :: i', &
'       integer(kind=SHIFTKIND,intent(in) :: shift', &
'       integer(kind=SIZEKIND,intent(in),optional  :: size', &
'', &
'  where KIND, SHIFTKIND, and SIZEKIND may be any supported integer kind, but', &
'  where the kind for I dictates the kind of the returned value.', &
'', &
'DESCRIPTION', &
'  ISHFTC(3) circularly shifts just the specified rightmost bits of an integer.', &
'', &
'  ISHFTC(3) returns a value corresponding to I with the rightmost SIZE bits', &
'  shifted circularly SHIFT places; that is, bits shifted out one end of the', &
'  section are shifted into the opposite end of the section.', &
'', &
'  A value of SHIFT greater than zero corresponds to a left shift, a value of', &
'  zero corresponds to no shift, and a value less than zero corresponds to a', &
'  right shift.', &
'', &
'ARGUMENTS', &
'  o  I : The value specifying the pattern of bits to shift', &
'', &
'  o  SHIFT : If SHIFT is positive, the shift is to the left; if SHIFT is', &
'     negative, the shift is to the right; and if SHIFT is zero, no shift is', &
'     performed. The absolute value of SHIFT must be less than SIZE (simply', &
'     put, the number of bits to shift must be less than or equal to the number', &
'     of bits specified to be shifting!)', &
'', &
'  o  SIZE : (Optional) The type shall be integer; the value must be greater', &
'     than zero and less than or equal to BIT_SIZE(i). The default is', &
'     BIT_SIZE(I). That is, the default is to circularly shift the entire value', &
'     I.', &
'', &
'RETURNS', &
'  The result characteristics (kind, shape, size, ranke, ...) are the same as', &
'  I.', &
'', &
'  The result has the value obtained by shifting the SIZE rightmost bits of I', &
'  circularly by SHIFT positions.', &
'', &
'  No bits are lost.', &
'', &
'  The unshifted bits are unaltered.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ishftc', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer             :: shift', &
'      integer             :: i', &
'      character(len=*),parameter :: g=''(b32.32,1x,i0)''', &
'', &
'         write(*,*) ishftc(3, 1),'' <== typically should have the value 6''', &
'', &
'        ! shift a value by various amounts', &
'         do i= -bit_size(0), bit_size(0), 8', &
'            write(*,g) ishftc(huge(0),i), i', &
'         enddo', &
'', &
'      end program demo_ishftc', &
'', &
'  Results:', &
'', &
'      >              6  <== typically should have the value 6', &
'      >   01111111111111111111111111111111 -32', &
'      >   11111111111111111111111101111111 -24', &
'      >   11111111111111110111111111111111 -16', &
'      >   11111111011111111111111111111111 -8', &
'      >   01111111111111111111111111111111 0', &
'      >   11111111111111111111111101111111 8', &
'      >   11111111111111110111111111111111 16', &
'      >   11111111011111111111111111111111 24', &
'      >   01111111111111111111111111111111 32', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  ISHFT(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              ishftc(3fortran)', &
'']

shortname="ishftc"
call process()


case('112','is_iostat_end')

textblock=[character(len=256) :: &
'', &
'is_iostat_end(3fortran)                                is_iostat_end(3fortran)', &
'', &
'NAME', &
'  IS_IOSTAT_END(3) - [STATE] Test for end-of-file value', &
'', &
'SYNTAX', &
'  function is_iostat_end(i)', &
'', &
'          logical function   :: is_iostat_end (i) result(yesno)', &
'          integer,intent(in) :: i', &
'', &
'DESCRIPTION', &
'  is_iostat_end(3) tests whether a variable (assumed returned as a status from', &
'  an I/O statement) has the "end of file" I/O status value.', &
'', &
'  The function is equivalent to comparing the variable with the IOSTAT_END', &
'  parameter of the intrinsic module ISO_FORTRAN_ENV.', &
'', &
'ARGUMENTS', &
'  o  I : An integer status value to test if indicating end of file.', &
'', &
'RETURNS', &
'  Returns a logical of the default kind, .true. if I has the value which', &
'  indicates an end of file condition for IOSTAT= specifiers, and is \.false.', &
'  otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iostat', &
'      implicit none', &
'      real               :: value', &
'      integer            :: ios', &
'      character(len=256) :: message', &
'         write(*,*)''Begin entering numeric values, one per line''', &
'         do', &
'            read(*,*,iostat=ios,iomsg=message)value', &
'            if(ios.eq.0)then', &
'               write(*,*)''VALUE='',value', &
'            elseif( is_iostat_end(ios) ) then', &
'               stop ''end of file. Goodbye!''', &
'            else', &
'               write(*,*)''ERROR:'',ios,trim(message)', &
'            endif', &
'            !', &
'         enddo', &
'      end program demo_iostat', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022       is_iostat_end(3fortran)', &
'']

shortname="is_iostat_end"
call process()


case('113','is_iostat_eor')

textblock=[character(len=256) :: &
'', &
'is_iostat_eor(3fortran)                                is_iostat_eor(3fortran)', &
'', &
'NAME', &
'  IS_IOSTAT_EOR(3) - [STATE] Test for end-of-record value', &
'', &
'SYNTAX', &
'  result = is_iostat_eor(i)', &
'', &
'DESCRIPTION', &
'  is_iostat_eor tests whether an variable has the value of the I/O status "end', &
'  of record". The function is equivalent to comparing the variable with the', &
'  iostat_eor parameter of the intrinsic module ISO_FORTRAN_ENV.', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of the type integer.', &
'', &
'RETURNS', &
'  Returns a logical of the default kind, which .true. if I has the value which', &
'  indicates an end of file condition for iostat= specifiers, and is \.false.', &
'  otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_is_iostat_eor', &
'      implicit none', &
'      integer :: stat, i(50)', &
'', &
'        open(88, file=''test.dat'', form=''unformatted'')', &
'        read(88, iostat=stat) i', &
'', &
'        if(is_iostat_eor(stat)) stop ''end of record''', &
'', &
'      end program demo_is_iostat_eor', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022       is_iostat_eor(3fortran)', &
'']

shortname="is_iostat_eor"
call process()


case('114','kind')

textblock=[character(len=256) :: &
'', &
'kind(3fortran)                                                  kind(3fortran)', &
'', &
'NAME', &
'  KIND(3) - [KIND INQUIRY] Kind of an entity', &
'', &
'SYNTAX', &
'  k = kind(x)', &
'', &
'DESCRIPTION', &
'  KIND(X) returns the kind value of the entity X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type logical, integer, real, complex or character.', &
'', &
'RETURNS', &
'  The return value is a scalar of type integer and of the default integer', &
'  kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_kind', &
'      implicit none', &
'      integer,parameter :: kc = kind('' '')', &
'      integer,parameter :: kl = kind(.true.)', &
'', &
'         print *, "The default character kind is ", kc', &
'         print *, "The default logical kind is ", kl', &
'', &
'      end program demo_kind', &
'', &
'  Results:', &
'', &
'          The default character kind is            1', &
'          The default logical kind is            4', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                kind(3fortran)', &
'']

shortname="kind"
call process()


case('115','lbound')

textblock=[character(len=256) :: &
'', &
'lbound(3fortran)                                              lbound(3fortran)', &
'', &
'NAME', &
'  LBOUND(3) - [ARRAY INQUIRY] Lower dimension bounds of an array', &
'', &
'SYNTAX', &
'  result = lbound(array, dim, kind)', &
'', &
'         TYPE(kind=KIND) elemental function lbound(array,dim,kind)', &
'         TYPE(kind=KIND),intent(in)  :: array', &
'         integer,optional,intent(in) :: dim', &
'         integer,optional,intent(in) :: kind', &
'', &
'DESCRIPTION', &
'  Returns the lower bounds of an array, or a single lower bound along the DIM', &
'  dimension.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array, of any type.', &
'', &
'  o  DIM : Shall be a scalar integer.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is absent, the result is an', &
'  array of the lower bounds of ARRAY. If DIM is present, the result is a', &
'  scalar corresponding to the lower bound of the array along that dimension.', &
'  If ARRAY is an expression rather than a whole array or array structure', &
'  component, or if it has a zero extent along the relevant dimension, the', &
'  lower bound is taken to be 1.', &
'', &
'EXAMPLES', &
'  Note that in my opinion this function should not be used on assumed-size', &
'  arrays or in any function without an explicit interface. Errors can occur if', &
'  there is no interface defined.', &
'', &
'  Sample program', &
'', &
'      ! program demo_lbound', &
'      module m_bounds', &
'      implicit none', &
'       contains', &
'          subroutine msub(arr)', &
'             !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array', &
'             integer,intent(in) :: arr(:)', &
'             write(*,*)''MSUB: LOWER='',lbound(arr), &', &
'             & ''UPPER='',ubound(arr), &', &
'             & ''SIZE='',size(arr)', &
'          end subroutine msub', &
'       end module m_bounds', &
'', &
'       use m_bounds, only : msub', &
'       implicit none', &
'       interface', &
'          subroutine esub(arr)', &
'          integer,intent(in) :: arr(:)', &
'          end subroutine esub', &
'       end interface', &
'       integer :: arr(-10:10)', &
'          write(*,*)''MAIN: LOWER='',lbound(arr), &', &
'          & ''UPPER='',ubound(arr), &', &
'          & ''SIZE='',size(arr)', &
'          call csub()', &
'          call msub(arr)', &
'          call esub(arr)', &
'       contains', &
'      subroutine csub', &
'         write(*,*)''CSUB: LOWER='',lbound(arr), &', &
'         & ''UPPER='',ubound(arr), &', &
'         & ''SIZE='',size(arr)', &
'      end subroutine csub', &
'      end', &
'', &
'       subroutine esub(arr)', &
'       implicit none', &
'       integer,intent(in) :: arr(:)', &
'          ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE', &
'          ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)', &
'          write(*,*)''ESUB: LOWER='',lbound(arr), &', &
'          & ''UPPER='',ubound(arr), &', &
'          & ''SIZE='',size(arr)', &
'       end subroutine esub', &
'', &
'      !end program demo_lbound', &
'', &
'  Results:', &
'', &
'         MAIN: LOWER=         -10 UPPER=          10 SIZE=          21', &
'         CSUB: LOWER=         -10 UPPER=          10 SIZE=          21', &
'         MSUB: LOWER=           1 UPPER=          21 SIZE=          21', &
'         ESUB: LOWER=           1 UPPER=          21 SIZE=          21', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument - Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  UBOUND(3), CO_LBOUND(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              lbound(3fortran)', &
'']

shortname="lbound"
call process()


case('116','leadz')

textblock=[character(len=256) :: &
'', &
'leadz(3fortran)                                                leadz(3fortran)', &
'', &
'NAME', &
'  LEADZ(3) - [BIT:COUNT] Number of leading zero bits of an integer', &
'', &
'SYNTAX', &
'  result = leadz(i)', &
'', &
'DESCRIPTION', &
'  LEADZ returns the number of leading zero bits of an integer.', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer.', &
'', &
'RETURNS', &
'  The type of the return value is the same as a default integer. If all the', &
'  bits of I are zero, the result value is BIT_SIZE(I).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_leadz', &
'      implicit none', &
'      integer :: value, i', &
'      character(len=80) :: f', &
'        write(*,''(*(g0))'')''BIT_SIZE='',bit_size(value)', &
'        ! make a format statement for writing a value as a bit string', &
'        write(f,''("(b",i0,".",i0,")")'')bit_size(value),bit_size(value)', &
'        ! show output for various integer values', &
'        value=0', &
'        do i=0,bit_size(value)-1', &
'           write (*,''("LEADING ZERO BITS=",i3,1x)'') leadz(value)', &
'           write (*,''(" FOR VALUE ")'',advance=''no'')', &
'           write(*,f,advance=''no'') value', &
'           write(*,''(*(1x,g0))'') "OR",value', &
'           value=value+2**(i)', &
'        enddo', &
'      end program demo_leadz', &
'', &
'  Results:', &
'', &
'         BIT_SIZE=32', &
'         LEADING ZERO BITS= 32', &
'          FOR VALUE 00000000000000000000000000000000 OR 0', &
'         LEADING ZERO BITS= 31', &
'          FOR VALUE 00000000000000000000000000000001 OR 1', &
'         LEADING ZERO BITS= 30', &
'          FOR VALUE 00000000000000000000000000000011 OR 3', &
'         LEADING ZERO BITS= 29', &
'          FOR VALUE 00000000000000000000000000000111 OR 7', &
'         LEADING ZERO BITS= 28', &
'          FOR VALUE 00000000000000000000000000001111 OR 15', &
'         LEADING ZERO BITS= 27', &
'          FOR VALUE 00000000000000000000000000011111 OR 31', &
'         LEADING ZERO BITS= 26', &
'          FOR VALUE 00000000000000000000000000111111 OR 63', &
'         LEADING ZERO BITS= 25', &
'          FOR VALUE 00000000000000000000000001111111 OR 127', &
'         LEADING ZERO BITS= 24', &
'          FOR VALUE 00000000000000000000000011111111 OR 255', &
'         LEADING ZERO BITS= 23', &
'          FOR VALUE 00000000000000000000000111111111 OR 511', &
'         LEADING ZERO BITS= 22', &
'          FOR VALUE 00000000000000000000001111111111 OR 1023', &
'         LEADING ZERO BITS= 21', &
'          FOR VALUE 00000000000000000000011111111111 OR 2047', &
'         LEADING ZERO BITS= 20', &
'          FOR VALUE 00000000000000000000111111111111 OR 4095', &
'         LEADING ZERO BITS= 19', &
'          FOR VALUE 00000000000000000001111111111111 OR 8191', &
'         LEADING ZERO BITS= 18', &
'          FOR VALUE 00000000000000000011111111111111 OR 16383', &
'         LEADING ZERO BITS= 17', &
'          FOR VALUE 00000000000000000111111111111111 OR 32767', &
'         LEADING ZERO BITS= 16', &
'          FOR VALUE 00000000000000001111111111111111 OR 65535', &
'         LEADING ZERO BITS= 15', &
'          FOR VALUE 00000000000000011111111111111111 OR 131071', &
'         LEADING ZERO BITS= 14', &
'          FOR VALUE 00000000000000111111111111111111 OR 262143', &
'         LEADING ZERO BITS= 13', &
'          FOR VALUE 00000000000001111111111111111111 OR 524287', &
'         LEADING ZERO BITS= 12', &
'          FOR VALUE 00000000000011111111111111111111 OR 1048575', &
'         LEADING ZERO BITS= 11', &
'          FOR VALUE 00000000000111111111111111111111 OR 2097151', &
'         LEADING ZERO BITS= 10', &
'          FOR VALUE 00000000001111111111111111111111 OR 4194303', &
'         LEADING ZERO BITS=  9', &
'          FOR VALUE 00000000011111111111111111111111 OR 8388607', &
'         LEADING ZERO BITS=  8', &
'          FOR VALUE 00000000111111111111111111111111 OR 16777215', &
'         LEADING ZERO BITS=  7', &
'          FOR VALUE 00000001111111111111111111111111 OR 33554431', &
'         LEADING ZERO BITS=  6', &
'          FOR VALUE 00000011111111111111111111111111 OR 67108863', &
'         LEADING ZERO BITS=  5', &
'          FOR VALUE 00000111111111111111111111111111 OR 134217727', &
'         LEADING ZERO BITS=  4', &
'          FOR VALUE 00001111111111111111111111111111 OR 268435455', &
'         LEADING ZERO BITS=  3', &
'          FOR VALUE 00011111111111111111111111111111 OR 536870911', &
'         LEADING ZERO BITS=  2', &
'          FOR VALUE 00111111111111111111111111111111 OR 1073741823', &
'         LEADING ZERO BITS=  1', &
'          FOR VALUE 01111111111111111111111111111111 OR 2147483647', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BIT_SIZE(3), POPCNT(3), POPPAR(3), TRAILZ(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               leadz(3fortran)', &
'']

shortname="leadz"
call process()


case('117','len')

textblock=[character(len=256) :: &
'', &
'len(3fortran)                                                    len(3fortran)', &
'', &
'NAME', &
'  LEN(3) - [CHARACTER] Length of a character entity', &
'', &
'SYNTAX', &
'  integer(kind=KIND) function len(string,kind)', &
'', &
'           character(len=*),intent(in) :: string', &
'           integer,optional,intent(in) :: kind', &
'', &
'  where the returned value is the same integer kind as the KIND argument, or', &
'  of the default integer kind if KIND is not specified.', &
'', &
'DESCRIPTION', &
'  LEN(3) Returns the length of a character string.', &
'', &
'  If STRING is an array, the length of an element of STRING is returned, as', &
'  all elements of an array are the same length.', &
'', &
'  Note that STRING need not be defined when this intrinsic is invoked, as only', &
'  the length (not the content) of STRING is needed.', &
'', &
'ARGUMENTS', &
'  o  STRING : A scalar or array of type character to return the length of', &
'', &
'  o  KIND : A constant integer initialization expression indicating the kind', &
'     parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_len', &
'      implicit none', &
'', &
'      ! fixed length', &
'      character(len=40) :: string', &
'      ! allocatable length', &
'      character(len=:),allocatable :: astring', &
'      character(len=:),allocatable :: many_strings(:)', &
'      integer :: ii', &
'        ! BASIC USAGE', &
'         ii=len(string)', &
'         write(*,*)''length ='',ii', &
'', &
'        ! ALLOCATABLE VARIABLE LENGTH CAN CHANGE', &
'        ! the allocatable string length will be the length of RHS expression', &
'         astring='' How long is this allocatable string? ''', &
'         write(*,*)astring, '' LEN='', len(astring)', &
'        ! print underline', &
'         write(*,*) repeat(''='',len(astring))', &
'        ! assign new value to astring and length changes', &
'         astring=''New allocatable string''', &
'         write(*,*)astring, '' LEN='', len(astring)', &
'        ! print underline', &
'         write(*,*) repeat(''='',len(astring))', &
'', &
'        ! THE STRING LENGTH WILL BE CONSTANT FOR A FIXED-LENGTH VARIABLE', &
'         string='' How long is this fixed string? ''', &
'         write(*,*)string,'' LEN='',len(string)', &
'         string=''New fixed string ''', &
'         write(*,*)string,'' LEN='',len(string)', &
'', &
'        ! ALL STRINGS IN AN ARRAY ARE THE SAME LENGTH', &
'        ! a scalar is returned for an array, as all values in a Fortran', &
'        ! character array must be of the same length.', &
'         many_strings = [ character(len=7) :: ''Tom'', ''Dick'', ''Harry'' ]', &
'         write(*,*)''length of ALL elements of array='',len(many_strings)', &
'', &
'        ! NAME%LEN IS ESSENTIALLY THE SAME AS LEN(NAME)', &
'        ! you can also query the length (and other attributes) of a string', &
'        ! using a "type parameter inquiry" (available since fortran 2018)', &
'         write(*,*)''length from type parameter inquiry='',string%len', &
'        ! %len is equivalent to a call to LEN() except the kind of the integer', &
'        ! value returned is always of default kind.', &
'', &
'        ! LOOK AT HOW A PASSED STRING CAN BE USED ...', &
'         call passed('' how long? '')', &
'', &
'      contains', &
'', &
'         subroutine passed(str)', &
'         character(len=*),intent(in)  :: str', &
'         ! the length of str can be used in the definitions of variables', &
'            ! you can query the length of the passed variable', &
'            write(*,*)''length of passed value is '', LEN(str)', &
'         end subroutine passed', &
'', &
'      end program demo_len', &
'', &
'  Results:', &
'', &
'          length =          40', &
'           How long is this allocatable string?  LEN=          38', &
'          ======================================', &
'          New allocatable string LEN=          22', &
'          ======================', &
'           How long is this fixed string?          LEN=          40', &
'          New fixed string                         LEN=          40', &
'          length of ALL elements of array=           7', &
'          length from type parameter inquiry=          40', &
'          length of passed value is           11', &
'', &
'STANDARD', &
'  FORTRAN 77 and later; with KIND argument - Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  len_trim(3), adjustr(3), trim(3), and adjustl(3) are related routines that', &
'  allow you to deal with leading and trailing blanks.', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 len(3fortran)', &
'']

shortname="len"
call process()


case('118','len_trim')

textblock=[character(len=256) :: &
'', &
'len_trim(3fortran)                                          len_trim(3fortran)', &
'', &
'NAME', &
'  LEN_TRIM(3) - [CHARACTER:WHITESPACE] Length of a character entity without', &
'  trailing blank characters', &
'', &
'SYNTAX', &
'  result = len_trim(string, kind)', &
'', &
'          integer(kind=KIND) function len_trim(string,KIND) result (value)', &
'          character(len=*),intent(in) :: string', &
'          integer,optional,intent(in) :: KIND', &
'          integer(kind=KIND) :: value', &
'', &
'DESCRIPTION', &
'  Returns the length of a character string, ignoring any trailing blanks.', &
'', &
'ARGUMENTS', &
'  o  STRING : The input string whose length is to be measured. Shall be a', &
'     scalar of type character', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_len_trim', &
'      implicit none', &
'      character(len=:),allocatable :: string', &
'         string='' how long is this string?     ''', &
'         write(*,*)''LENGTH='',len(string)', &
'         write(*,*)''TRIMMED LENGTH='',len_trim(string)', &
'         !', &
'         ELE:block ! elemental example', &
'         character(len=:),allocatable :: tablet(:)', &
'         tablet=[character(len=256) :: &', &
'         & '' how long is this string?     '',&', &
'         & ''and this one?'']', &
'            write(*,*)''LENGTH=            '',len(tablet)', &
'            write(*,*)''TRIMMED LENGTH=    '',len_trim(tablet)', &
'            write(*,*)''SUM TRIMMED LENGTH='',sum(len_trim(tablet))', &
'         endblock ELE', &
'         !', &
'      end program demo_len_trim', &
'', &
'  Results:', &
'', &
'          LENGTH=          30', &
'          TRIMMED LENGTH=          25', &
'          LENGTH=                     256', &
'          TRIMMED LENGTH=              25          13', &
'          SUM TRIMMED LENGTH=          38', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument - Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: REPEAT(3), LEN(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022            len_trim(3fortran)', &
'']

shortname="len_trim"
call process()


case('119','lge')

textblock=[character(len=256) :: &
'', &
'lge(3fortran)                                                    lge(3fortran)', &
'', &
'NAME', &
'  LGE(3) - [CHARACTER:COMPARE] ASCII Lexical greater than or equal', &
'', &
'SYNTAX', &
'  elemental logical function lge(string_a, string_b)', &
'', &
'          character(len=*),intent(in) :: string_a', &
'          character(len=*),intent(in) :: string_b', &
'', &
'DESCRIPTION', &
'  Determines whether one string is lexically greater than or equal to another', &
'  string, where the two strings are interpreted as containing ASCII character', &
'  codes. If the String A and String B are not the same length, the shorter is', &
'  compared as if spaces were appended to it to form a value that has the same', &
'  length as the longer.', &
'', &
'  The lexical comparison intrinsics LGE(3), LGT(3), LLE(3), and LLT(3) differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and \.lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas the former always use the ASCII ordering.', &
'', &
'ARGUMENTS', &
'  o  STRING_A : Shall be of default character type.', &
'', &
'  o  STRING_B : Shall be of default character type.', &
'', &
'RETURNS', &
'  Returns .true. if string_a >= string_b, and .false. otherwise, based on the', &
'  ASCII ordering.', &
'', &
'  If both input arguments are null strings, .true. is always returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_lge', &
'      implicit none', &
'      integer :: i', &
'         write(*,''(*(a))'')(char(i),i=32,126)  ! ASCII order', &
'         write(*,*) lge(''abc'',''ABC'')          ! [T] lowercase is > uppercase', &
'         write(*,*) lge(''abc'',''abc  '')        ! [T] trailing spaces', &
'         ! If both strings are of zero length the result is true', &
'         write(*,*) lge('''','''')                ! [T]', &
'         write(*,*) lge('''',''a'')               ! [F] the null string is padded', &
'         write(*,*) lge(''a'','''')               ! [T]', &
'         write(*,*) lge(''abc'',[''abc'',''123''])  ! [T T]  scalar and array', &
'         write(*,*) lge([''cba'', ''123''],''abc'') ! [T F]', &
'         write(*,*) lge([''abc'',''123''],[''cba'',''123'']) ! [F T]  both arrays', &
'      end program demo_lge', &
'', &
'  Results:', &
'', &
'          !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ', &
'          [\]^_`abcdefghijklmnopqrstuvwxyz{|}~', &
'', &
'   T', &
'   T', &
'   T', &
'   F', &
'   T', &
'   T T', &
'   T F', &
'   F T', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  LGT(3), LLE(3), LLT(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 lge(3fortran)', &
'']

shortname="lge"
call process()


case('120','lgt')

textblock=[character(len=256) :: &
'', &
'lgt(3fortran)                                                    lgt(3fortran)', &
'', &
'NAME', &
'  LGT(3) - [CHARACTER:COMPARE] ASCII Lexical greater than', &
'', &
'SYNTAX', &
'  elemental logical function lgt(string_a, string_b)', &
'', &
'          character(len=*),intent(in) :: string_a', &
'          character(len=*),intent(in) :: string_b', &
'', &
'DESCRIPTION', &
'  Determines whether one string is lexically greater than another string,', &
'  where the two strings are interpreted as containing ASCII character codes.', &
'  If the String A and String B are not the same length, the shorter is', &
'  compared as if spaces were appended to it to form a value that has the same', &
'  length as the longer.', &
'', &
'  In general, the lexical comparison intrinsics LGE, LGT, LLE, and LLT differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and \.lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas the former always use the ASCII ordering.', &
'', &
'ARGUMENTS', &
'  o  STRING_A : Shall be of default character type.', &
'', &
'  o  STRING_B : Shall be of default character type.', &
'', &
'RETURNS', &
'  Returns .true. if string_a > string_b, and .false. otherwise, based on the', &
'  ASCII ordering.', &
'', &
'  If both input arguments are null strings, .false. is always returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_lgt', &
'      implicit none', &
'      integer :: i', &
'         write(*,''(*(a))'')(char(i),i=32,126)  ! ASCII order', &
'         write(*,*) lgt(''abc'',''ABC'')          ! [T] lowercase is > uppercase', &
'         write(*,*) lgt(''abc'',''abc  '')        ! [F] trailing spaces', &
'         ! If both strings are of zero length the result is false.', &
'         write(*,*) lgt('''','''')                ! [F]', &
'         write(*,*) lgt('''',''a'')               ! [F] the null string is padded', &
'         write(*,*) lgt(''a'','''')               ! [T]', &
'         write(*,*) lgt(''abc'',[''abc'',''123''])  ! [F T]  scalar and array', &
'         write(*,*) lgt([''cba'', ''123''],''abc'') ! [T F]', &
'         write(*,*) lgt([''abc'',''123''],[''cba'',''123'']) ! [F F]  both arrays', &
'      end program demo_lgt', &
'', &
'  Results:', &
'', &
'          !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ', &
'          [\]^_`abcdefghijklmnopqrstuvwxyz{|}~', &
'', &
'   T', &
'   F', &
'   F', &
'   F', &
'   T', &
'   F T', &
'   T F', &
'   F F', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  LGE(3), LLE(3), LLT(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 lgt(3fortran)', &
'']

shortname="lgt"
call process()


case('121','lle')

textblock=[character(len=256) :: &
'', &
'lle(3fortran)                                                    lle(3fortran)', &
'', &
'NAME', &
'  LLE(3) - [CHARACTER:COMPARE] ASCII Lexical less than or equal', &
'', &
'SYNTAX', &
'  elemental logical function lle(string_a, string_b)', &
'', &
'          character(len=*),intent(in) :: string_a', &
'          character(len=*),intent(in) :: string_b', &
'', &
'DESCRIPTION', &
'  Determines whether one string is lexically less than or equal to another', &
'  string, where the two strings are interpreted as containing ASCII character', &
'  codes. if the STRING_A and STRING_B are not the same length, the shorter is', &
'  compared as if spaces were appended to it to form a value that has the same', &
'  length as the longer. Leading spaces are significant.', &
'', &
'  In general, the lexical comparison intrinsics LGE, LGT, LLE, and LLT differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and \.lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas the former always use the ASCII ordering.', &
'', &
'ARGUMENTS', &
'  o  STR_A : variable or array of default character type.', &
'', &
'  o  STR_B : variable or array of default character type.', &
'', &
'      if STR_A and STR_B are both arrays they must be of the same shape.', &
'', &
'RETURNS', &
'  o  RESULT Returns .true. if STR_A <= STR_B, and .false. otherwise, based on', &
'     the ASCII ordering.', &
'', &
'     If both input arguments are null strings, .true. is always returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_lle', &
'      implicit none', &
'      integer :: i', &
'         write(*,''(*(a))'')(char(i),i=32,126)', &
'         write(*,*) lle(''abc'',''ABC'')          ! F lowercase is > uppercase', &
'         write(*,*) lle(''abc'',''abc  '')        ! T trailing spaces', &
'         ! If both strings are of zero length the result is true.', &
'         write(*,*) lle('''','''')                ! T', &
'         write(*,*) lle('''',''a'')               ! T the null string is padded', &
'         write(*,*) lle(''a'','''')               ! F', &
'         write(*,*) lle(''abc'',[''abc'',''123''])  ! [T,F] scalar and array', &
'         write(*,*) lle([''cba'', ''123''],''abc'') ! [F,T]', &
'         write(*,*) lle([''abc'',''123''],[''cba'',''123'']) ! [T,T] both arrays', &
'      end program demo_lle', &
'', &
'  Results:', &
'', &
'        !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ', &
'        [\]^_`abcdefghijklmnopqrstuvwxyz{|}~', &
'', &
'   F', &
'   T', &
'   T', &
'   T', &
'   F', &
'   T F', &
'   F T', &
'   T T', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  LGE(3), LGT(3), LLT(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 lle(3fortran)', &
'']

shortname="lle"
call process()


case('122','llt')

textblock=[character(len=256) :: &
'', &
'llt(3fortran)                                                    llt(3fortran)', &
'', &
'NAME', &
'  LLT(3) - [CHARACTER:COMPARE] ASCII Lexical less than', &
'', &
'SYNTAX', &
'  elemental logical function llt(string_a, string_b)', &
'', &
'          character(len=*),intent(in) :: string_a', &
'          character(len=*),intent(in) :: string_b', &
'', &
'DESCRIPTION', &
'  Determines whether one string is lexically less than another string, where', &
'  the two strings are interpreted as containing ASCII character codes. If the', &
'  STRING_A and STRING_B are not the same length, the shorter is compared as if', &
'  spaces were appended to it to form a value that has the same length as the', &
'  longer.', &
'', &
'  In general, the lexical comparison intrinsics LGE, LGT, LLE, and LLT differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and \.lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas the former always use the ASCII ordering.', &
'', &
'ARGUMENTS', &
'  o  STRING_A : Shall be of default character type.', &
'', &
'  o  STRING_B : Shall be of default character type.', &
'', &
'RETURNS', &
'  Returns .true. if string_a <= string_b, and .false. otherwise, based on the', &
'  ASCII ordering.', &
'', &
'  If both input arguments are null strings, .false. is always returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_llt', &
'      implicit none', &
'      integer :: i', &
'         write(*,''(*(a))'')(char(i),i=32,126)  ! ASCII order', &
'         write(*,*) llt(''abc'',''ABC'')          ! [F] lowercase is > uppercase', &
'         write(*,*) llt(''abc'',''abc  '')        ! [F] trailing spaces', &
'         ! If both strings are of zero length the result is false.', &
'         write(*,*) llt('''','''')                ! [F]', &
'         write(*,*) llt('''',''a'')               ! [T] the null string is padded', &
'         write(*,*) llt(''a'','''')               ! [F]', &
'         write(*,*) llt(''abc'',[''abc'',''123''])  ! [F F]  scalar and array', &
'         write(*,*) llt([''cba'', ''123''],''abc'') ! [F T]', &
'         write(*,*) llt([''abc'',''123''],[''cba'',''123'']) ! [T F]  both arrays', &
'      end program demo_llt', &
'', &
'  Results:', &
'', &
'        > !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ', &
'        > [\]^_`abcdefghijklmnopqrstuvwxyz{|}~', &
'        > F', &
'        > F', &
'        > F', &
'        > T', &
'        > F', &
'        > F F', &
'        > F T', &
'        > T F', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  LGE(3), LGT(3), LLE(3))', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 llt(3fortran)', &
'']

shortname="llt"
call process()


case('123','log10')

textblock=[character(len=256) :: &
'', &
'log10(3fortran)                                                log10(3fortran)', &
'', &
'NAME', &
'  LOG10(3) - [MATHEMATICS] Base 10 logarithm function', &
'', &
'SYNTAX', &
'  result = log10(x)', &
'', &
'         real(kind=KIND) elemental function log10(x)', &
'         real(kind=KIND),intent(in) :: x', &
'', &
'DESCRIPTION', &
'  LOG10(X) computes the base 10 logarithm of X. This is generally called the', &
'  "common logarithm".', &
'', &
'ARGUMENTS', &
'  o  X : A real value > 0 to take the log of.', &
'', &
'RETURNS', &
'  The return value is of type real . The kind type parameter is the same as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_log10', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'       & real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 10.0_real64', &
'', &
'         x = log10(x)', &
'         write(*,''(*(g0))'')''log10('',x,'') is '',log10(x)', &
'', &
'         ! elemental', &
'         write(*, *)log10([1.0, 10.0, 100.0, 1000.0, 10000.0, &', &
'                           & 100000.0, 1000000.0, 10000000.0])', &
'', &
'      end program demo_log10', &
'', &
'  Results:', &
'', &
'         log10(1.0000000000000000) is 0.0000000000000000', &
'            0.00000000       1.00000000       2.00000000       3.00000000', &
'            4.00000000       5.00000000       6.00000000       7.00000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               log10(3fortran)', &
'']

shortname="log10"
call process()


case('124','log')

textblock=[character(len=256) :: &
'', &
'log(3fortran)                                                    log(3fortran)', &
'', &
'NAME', &
'  LOG(3) - [MATHEMATICS] Logarithm function', &
'', &
'SYNTAX', &
'  result = log(x)', &
'', &
'DESCRIPTION', &
'  LOG(X) computes the natural logarithm of X, i.e. the logarithm to the base', &
'  "e".', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value is of type real or complex. The kind type parameter is the', &
'  same as X. If X is complex, the imaginary part OMEGA is in the range', &
'', &
'  -PI < OMEGA <= PI.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_log', &
'      implicit none', &
'        real(kind(0.0d0)) :: x = 2.71828182845904518d0', &
'        complex :: z = (1.0, 2.0)', &
'        write(*,*)x, log(x)    ! will yield (approximately) 1', &
'        write(*,*)z, log(z)', &
'      end program demo_log', &
'', &
'  Results:', &
'', &
'            2.7182818284590451        1.0000000000000000', &
'  (1.00000000,2.00000000) (0.804718971,1.10714877)', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 log(3fortran)', &
'']

shortname="log"
call process()


case('125','log_gamma')

textblock=[character(len=256) :: &
'', &
'log_gamma(3fortran)                                        log_gamma(3fortran)', &
'', &
'NAME', &
'  LOG_GAMMA(3) - [MATHEMATICS] Logarithm of the Gamma function', &
'', &
'SYNTAX', &
'  x = log_gamma(x)', &
'', &
'DESCRIPTION', &
'  LOG_GAMMA(X) computes the natural logarithm of the absolute value of the', &
'  Gamma function.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real and neither zero nor a negative integer.', &
'', &
'RETURNS', &
'  The return value is of type real of the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_log_gamma', &
'      implicit none', &
'      real :: x = 1.0', &
'         write(*,*)x,log_gamma(x) ! returns 0.0', &
'      end program demo_log_gamma', &
'', &
'  Results:', &
'', &
'            1.00000000       0.00000000', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  Gamma function: GAMMA(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           log_gamma(3fortran)', &
'']

shortname="log_gamma"
call process()


case('126','logical')

textblock=[character(len=256) :: &
'', &
'logical(3fortran)                                            logical(3fortran)', &
'', &
'NAME', &
'  LOGICAL(3) - [TYPE:LOGICAL] Converts one kind of logical variable to another', &
'', &
'SYNTAX', &
'  result = logical(l, kind)', &
'', &
'       logical(kind=KIND) function logical(L,KIND)', &
'        logical(kind=INK),intent(in) :: L', &
'        integer,intent(in),optional :: KIND', &
'', &
'DESCRIPTION', &
'  Converts one kind of logical variable to another.', &
'', &
'ARGUMENTS', &
'  o  L : The type shall be logical.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is a logical value equal to L, with a kind corresponding to', &
'  KIND, or of the default logical kind if KIND is not given.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_logical', &
'      ! Access array containing the kind type parameter values supported by this', &
'      ! compiler for entities of logical type', &
'      use iso_fortran_env, only : logical_kinds', &
'', &
'         ! list kind values supported on this platform, which generally vary', &
'         ! in storage size', &
'         do i =1, size(logical_kinds)', &
'            write(*,*)logical_kinds(i)', &
'         enddo', &
'', &
'      end program demo_logical', &
'', &
'  Results:', &
'', &
'    1 2 4 8 16', &
'', &
'STANDARD', &
'  Fortran 95 and later, related ISO_FORTRAN_ENV module - fortran 2009', &
'', &
'SEE ALSO', &
'  INT(3), REAL(3), CMPLX(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             logical(3fortran)', &
'']

shortname="logical"
call process()


case('127','maskl')

textblock=[character(len=256) :: &
'', &
'maskl(3fortran)                                                maskl(3fortran)', &
'', &
'NAME', &
'  MASKL(3) - [BIT:SET] Generates a left justified mask', &
'', &
'SYNTAX', &
'  result = maskl(i, kind)', &
'', &
'        integer elemental function maskl(i,kind)', &
'        integer,intent(in),optional :: kind', &
'', &
'DESCRIPTION', &
'  MASKL(I[, KIND]) has its leftmost I bits set to 1, and the remaining bits', &
'  set to 0.', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer. Its value must be non-negative, and less', &
'     than or equal to the number of bits for the kind of the result.', &
'', &
'  o  KIND : Shall be a scalar constant expression of type integer.', &
'', &
'RETURNS', &
'  The return value is of type integer. If KIND is present, it specifies the', &
'  kind value of the return type; otherwise, it is of the default integer kind.', &
'', &
'  The leftmost I bits are set to 1 and the other bits are set to 0.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_maskl', &
'      implicit none', &
'      integer :: i', &
'         i=maskl(1)', &
'         write(*,''(i0,1x,b0,/)'') i,i', &
'         ! elemental', &
'         write(*,''(*(i11,1x,b0,1x,/))'') maskl([(i,i,i=1,bit_size(0))])', &
'      end program demo_maskl', &
'', &
'  Results:', &
'', &
'      -2147483648 10000000000000000000000000000000', &
'', &
'                0 0', &
'      -2147483648 10000000000000000000000000000000', &
'      -1073741824 11000000000000000000000000000000', &
'       -536870912 11100000000000000000000000000000', &
'       -268435456 11110000000000000000000000000000', &
'       -134217728 11111000000000000000000000000000', &
'        -67108864 11111100000000000000000000000000', &
'        -33554432 11111110000000000000000000000000', &
'        -16777216 11111111000000000000000000000000', &
'         -8388608 11111111100000000000000000000000', &
'         -4194304 11111111110000000000000000000000', &
'         -2097152 11111111111000000000000000000000', &
'         -1048576 11111111111100000000000000000000', &
'          -524288 11111111111110000000000000000000', &
'          -262144 11111111111111000000000000000000', &
'          -131072 11111111111111100000000000000000', &
'           -65536 11111111111111110000000000000000', &
'           -32768 11111111111111111000000000000000', &
'           -16384 11111111111111111100000000000000', &
'            -8192 11111111111111111110000000000000', &
'            -4096 11111111111111111111000000000000', &
'            -2048 11111111111111111111100000000000', &
'            -1024 11111111111111111111110000000000', &
'             -512 11111111111111111111111000000000', &
'             -256 11111111111111111111111100000000', &
'             -128 11111111111111111111111110000000', &
'              -64 11111111111111111111111111000000', &
'              -32 11111111111111111111111111100000', &
'              -16 11111111111111111111111111110000', &
'               -8 11111111111111111111111111111000', &
'               -4 11111111111111111111111111111100', &
'               -2 11111111111111111111111111111110', &
'               -1 11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  MASKR(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               maskl(3fortran)', &
'']

shortname="maskl"
call process()


case('128','maskr')

textblock=[character(len=256) :: &
'', &
'maskr(3fortran)                                                maskr(3fortran)', &
'', &
'NAME', &
'  MASKR(3) - [BIT:SET] Generates a right-justified mask', &
'', &
'SYNTAX', &
'  result = maskr(i, kind)', &
'', &
'        integer elemental function maskr(i,kind)', &
'        integer,intent(in),optional :: kind', &
'', &
'DESCRIPTION', &
'  MASKR(I[, KIND]) has its rightmost I bits set to 1, and the remaining bits', &
'  set to 0.', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer. Its value must be non-negative, and less', &
'     than or equal to the number of bits for the kind of the result.', &
'', &
'  o  KIND : Shall be a scalar constant expression of type integer.', &
'', &
'RETURNS', &
'  The return value is of type integer. If KIND is present, it specifies the', &
'  kind value of the return type; otherwise, it is of the default integer kind.', &
'', &
'  It has its rightmost I bits set to 1, and the remaining bits set to 0.', &
'', &
'EXAMPLE', &
'  Sample program:', &
'', &
'      program demo_maskr', &
'      implicit none', &
'      integer :: i', &
'         i=maskr(1)', &
'         write(*,''(i0,1x,b0,1x,b0/)'') i,i, shiftl(7,bit_size(0)-1)', &
'         i=maskr(5)', &
'         write(*,''(i0,1x,b0,1x,b0/)'') i,i, shiftl(7,bit_size(0)-5)', &
'         i=maskr(11)', &
'         write(*,''(i0,1x,b0,1x,b0/)'') i,i, shiftl(7,bit_size(0)-11)', &
'         ! elemental', &
'         write(*,''(*(i11,1x,b0,1x,/))'') maskr([(i,i,i=0,bit_size(0))])', &
'      end program demo_maskr', &
'', &
'  Results:', &
'', &
'    1 1 10000000000000000000000000000000', &
'', &
'    31 11111 111000000000000000000000000000', &
'', &
'    2047 11111111111 111000000000000000000000', &
'', &
'      0 0 1 1 3 11 7 111 15 1111 31 11111 63 111111 127 1111111 255 11111111', &
'      511 111111111 1023 1111111111 2047 11111111111 4095 111111111111 8191', &
'      1111111111111 16383 11111111111111 32767 111111111111111 65535', &
'      1111111111111111 131071 11111111111111111 262143 111111111111111111', &
'      524287 1111111111111111111 1048575 11111111111111111111 2097151', &
'      111111111111111111111 4194303 1111111111111111111111 8388607', &
'      11111111111111111111111 16777215 111111111111111111111111 33554431', &
'      1111111111111111111111111 67108863 11111111111111111111111111 134217727', &
'      111111111111111111111111111 268435455 1111111111111111111111111111', &
'      536870911 11111111111111111111111111111 1073741823', &
'      111111111111111111111111111111 2147483647', &
'      1111111111111111111111111111111 -1 11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  MASKL(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               maskr(3fortran)', &
'']

shortname="maskr"
call process()


case('129','matmul')

textblock=[character(len=256) :: &
'', &
'matmul(3fortran)                                              matmul(3fortran)', &
'', &
'NAME', &
'  MATMUL(3) - [TRANSFORMATIONAL] numeric or logical matrix multiplication', &
'', &
'SYNTAX', &
'  function matmul(matrix_a, matrix_b)', &
'', &
'       type(NUMERIC_OR_LOGICAL) :: matrix_a(..)', &
'       type(NUMERIC_OR_LOGICAL) :: matrix_b(..)', &
'       type(PROMOTED) :: matmul(..)', &
'', &
'  Arguments may be any numeric (integer, real, or complex ) or logical one or', &
'  two-dimensional array.', &
'', &
'  If one is logical, both must be logical.', &
'', &
'DESCRIPTION', &
'  MATMUL(3) performs a matrix multiplication on numeric or logical arguments.', &
'', &
'  for the numeric expression C=MATMUL(A,B) the element C(I,J) of the product', &
'  is obtained by multiplying term-by-term the entries of the ith row of A and', &
'  the jth column of B, and summing these products. In other words, C(I,J) is', &
'  the dot product of the ith row of A and the jth column of B.', &
'', &
'  Numeric results will be promoted to the same type and kind using the usual', &
'  rules for promoting mathematical operations (like +-*/).', &
'', &
'ARGUMENTS', &
'  o  MATRIX_A : A numeric or logical array with a rank of one or two.', &
'', &
'  o  MATRIX_B : A numeric or logical array with a rank of one or two. The', &
'     first dimension of MATRIX_B shall be equal to the last dimension of', &
'     MATRIX_A.', &
'', &
'  Note that MATRIX_B may be a different numeric type than MATRIX_A, but you', &
'  cannot use one numeric matrix and one logical matrix.', &
'', &
'RETURNS', &
'  The result is an array containing the matrix product of MATRIX_A and', &
'  MATRIX_B.', &
'', &
'  If one of the arguments is of rank one, the result has a rank of one. If', &
'  both arguments are of rank two, the result has a rank of two.', &
'', &
'  If MATRIX_A and MATRIX_B are numeric the array elements of the result are:', &
'', &
'        Value_of_Element (i,j) = &', &
'        SUM( (row_i_of_MATRIX_A) * (column_j_of_MATRIX_B) )', &
'', &
'  For numeric arguments the type and kind of the result follow the usual type', &
'  and kind promotion rules that apply to the data types of the arguments, such', &
'  as apply to +-*/ operations.', &
'', &
'  If MATRIX_A and MATRIX_B are of type logical, the array elements of the', &
'  result are:', &
'', &
'        Value_of_Element (i,j) = &', &
'        ANY( (row_i_of_MATRIX_A) .AND. (column_j_of_MATRIX_B) )', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_matmul', &
'      implicit none', &
'      integer :: a(2,3), b(3,2), c(2), d(3), e(2,2), f(3), g(2)', &
'       a = reshape([1, 2, 3, 4, 5, 6], [2, 3])', &
'       b = reshape([1, 2, 3, 4, 5, 6], [3, 2])', &
'       c = [1, 2]', &
'       d = [1, 2, 3]', &
'       e = matmul(a, b)', &
'       f = matmul(c,a)', &
'       g = matmul(a,d)', &
'', &
'       call print_matrix_int(''A is '',a)', &
'       call print_matrix_int(''B is '',b)', &
'       call print_vector_int(''C is '',c)', &
'       call print_vector_int(''D is '',d)', &
'       call print_matrix_int(''E is matmul(A,B)'',e)', &
'       call print_vector_int(''F is matmul(C,A)'',f)', &
'       call print_vector_int(''G is matmul(A,D)'',g)', &
'      contains', &
'', &
'      ! CONVENIENCE ROUTINES TO PRINT IN ROW-COLUMN ORDER', &
'      subroutine print_vector_int(title,arr)', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)           :: arr(:)', &
'         call print_matrix_int(title,reshape(arr,[1,shape(arr)]))', &
'      end subroutine print_vector_int', &
'', &
'      subroutine print_matrix_int(title,arr)', &
'      !@(#) print small 2d integer arrays in row-column format', &
'      character(len=*),parameter :: all=''(" > ",*(g0,1x))'' ! a handy format', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)           :: arr(:,:)', &
'      integer                      :: i', &
'      character(len=:),allocatable :: biggest', &
'', &
'            print all', &
'            print all, trim(title)', &
'            biggest=''           ''  ! make buffer to write integer into', &
'            ! find how many characters to use for integers', &
'            write(biggest,''(i0)'')ceiling(log10(real(maxval(abs(arr)))))+2', &
'            ! use this format to write a row', &
'            biggest=''(" > [",*(i''//trim(biggest)//'':,","))''', &
'            ! print one row of array at a time', &
'            do i=1,size(arr,dim=1)', &
'               write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'               write(*,''(" ]")'')', &
'            enddo', &
'', &
'      end subroutine print_matrix_int', &
'', &
'      end program demo_matmul', &
'', &
'  Results:', &
'', &
'          >', &
'          > A is', &
'          > [  1,  3,  5 ]', &
'          > [  2,  4,  6 ]', &
'          >', &
'          > B is', &
'          > [  1,  4 ]', &
'          > [  2,  5 ]', &
'          > [  3,  6 ]', &
'          >', &
'          > C is', &
'          > [  1,  2 ]', &
'          >', &
'          > D is', &
'          > [  1,  2,  3 ]', &
'          >', &
'          > E is matmul(A,B)', &
'          > [  22,  49 ]', &
'          > [  28,  64 ]', &
'          >', &
'          > F is matmul(C,A)', &
'          > [   5,  11,  17 ]', &
'          >', &
'          > G is matmul(A,D)', &
'          > [  22,  28 ]', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  PRODUCT(3), TRANSPOSE(3)', &
'', &
'  o  Matrix multiplication : Wikipedia', &
'', &
'  o  The Winograd variant of Strassen''s matrix-matrix multiply algorithm may', &
'     be of interest for optimizing multiplication of very large matrices. See', &
'', &
'          "GEMMW: A portable level 3 BLAS Winograd variant of Strassen''s', &
'          matrix-matrix multiply algorithm",', &
'', &
'          Douglas, C. C., Heroux, M., Slishman, G., and Smith, R. M.,', &
'          Journal of Computational Physics,', &
'          Vol. 110, No. 1, January 1994, pages 1-10.', &
'', &
'  The numerical instabilities of Strassen''s method for matrix multiplication', &
'  requires special processing.', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              matmul(3fortran)', &
'']

shortname="matmul"
call process()


case('130','max')

textblock=[character(len=256) :: &
'', &
'max(3fortran)                                                    max(3fortran)', &
'', &
'NAME', &
'  MAX(3) - [NUMERIC] Maximum value of an argument list', &
'', &
'SYNTAX', &
'  result = max(a1, a2, a3, ...)', &
'', &
'DESCRIPTION', &
'  Returns the argument with the largest (most positive) value.', &
'', &
'ARGUMENTS', &
'  o  A1 : The type shall be integer or real.', &
'', &
'  o  A2,A3,... : An expression of the same type and kind as A1.', &
'', &
'RETURNS', &
'  The return value corresponds to the maximum value among the arguments, and', &
'  has the same type and kind as the first argument.', &
'', &
'  The function is both elemental and allows for an arbitrary number of', &
'  arguments. This means if some elements are scalar and some are arrays that', &
'  all the arrays must be of the same size, and the returned value will be an', &
'  array that is the result as if multiple calls were made with all scalar', &
'  values with a single element of each array used in each call.  If called', &
'  with all arrays the returned array is the same as if multiple calls were', &
'  made with MAX(ARR1(1),ARR2(1), ...) to MAX(ARR1(N),ARR2(N)).', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_max', &
'      implicit none', &
'      real :: arr1(4)= [10.0,11.0,30.0,-100.0]', &
'      real :: arr2(5)= [20.0,21.0,32.0,-200.0,2200.0]', &
'', &
'        !! this is simple enough because it is not being called elementally', &
'        !! because all arguments are scalar', &
'        !!', &
'', &
'        write(*,*)''scalars:'',max(10.0,11.0,30.0,-100.0)', &
'', &
'        !!', &
'        !! this is all max(3) could do before it became an elemental', &
'        !! function and is the most intuitive', &
'        !! except that it can take an arbitrary number of options,', &
'        !! which is not common in Fortran without', &
'        !! declaring a lot of optional parameters.', &
'        !!', &
'        !! That is it unless you want to use the elemental features of max(3)!', &
'', &
'        !! Error: Intrinsic    max    at (1) must have at least two arguments', &
'        !!write(*,*)max(arr1)', &
'        !! This does not work because it is like trying to return', &
'        !! [(max(arr1(i)),i=1,size(arr1))]', &
'        !! so it is trying to take the max of a single value.', &
'        !! To find the largest element of an array', &
'        !! call maxloc(3) or maxval(3).', &
'', &
'        !! Error: Different shape for arguments ''a1'' and ''a2'' for intrinsic', &
'        !! ''max'' at (1) on dimension 1 (4 and 5)', &
'        !!write(*,*)max(arr1,arr2)', &
'        !! but this will return an array of', &
'        !! [(max(arr1(N),arr2(N),N=1,size(arr1))]', &
'', &
'        write(*,*)max(arr1,arr2(1:4))', &
'', &
'        !! so this works only if all the arrays are the same size and', &
'        !! you want an array of the largest Nth elements', &
'        !! from the input arrays.', &
'        !! maybe you wanted to do maxval([arr1,arr2]) or', &
'        !! equivalently max(maxval(arr1),maxval(arr2))', &
'        !! to find the single largest element in both arrays?', &
'', &
'        !! compares all scalars to each member of array and', &
'        !! returns array of size arr2', &
'', &
'        write(*,*)''scalars and array:'',max(10.0,11.0,30.0,-100.0,arr2)', &
'', &
'        !! Error: Different shape for arguments ''a5'' and ''a6''', &
'        !! for intrinsic ''max'' at (1) on dimension 1 (5 and 4)', &
'        !! write(*,*)''scalars and array:'',max(10.0,11.0,30.0,-100.0,arr2,arr1)', &
'        !! as the same reason above when arrays are used', &
'        !! (without scalar values) all the arrays must be the same size', &
'', &
'        write(*,*)''scalars and array:'',&', &
'        & max(40.0,11.0,30.0,-100.0,arr2(:4),arr1)', &
'      end program demo_max', &
'', &
'  Results:', &
'', &
'          scalars:   30.000000', &
'            20.0000000  21.000000  32.000000 -100.00000', &
'          scalars and array: 30.000000 30.000000 32.000000 30.000000 2200.0000', &
'          scalars and array: 40.000000 40.000000 40.000000 40.000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  MAXLOC(3), MAXVAL(3), MIN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 max(3fortran)', &
'']

shortname="max"
call process()


case('131','maxexponent')

textblock=[character(len=256) :: &
'', &
'maxexponent(3fortran)                                    maxexponent(3fortran)', &
'', &
'NAME', &
'  MAXEXPONENT(3) - [NUMERIC MODEL] Maximum exponent of a real kind', &
'', &
'SYNTAX', &
'  result = maxexponent(x)', &
'', &
'DESCRIPTION', &
'  MAXEXPONENT(X) returns the maximum exponent in the model of the type of X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real.', &
'', &
'RETURNS', &
'  The return value is of type integer and of the default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_maxexponent', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp) :: x', &
'      real(kind=dp) :: y', &
'', &
'         print *, minexponent(x), maxexponent(x)', &
'         print *, minexponent(y), maxexponent(y)', &
'      end program demo_maxexponent', &
'', &
'  Results:', &
'', &
'                 -125         128', &
'', &
'    -1021', &
'      1024', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MINEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         maxexponent(3fortran)', &
'']

shortname="maxexponent"
call process()


case('132','maxloc')

textblock=[character(len=256) :: &
'', &
'maxloc(3fortran)                                              maxloc(3fortran)', &
'', &
'NAME', &
'  MAXLOC(3) - [ARRAY:LOCATION] Location of the maximum value within an array', &
'', &
'SYNTAX', &
'  result = maxloc(array, dim, mask) result = maxloc(array, mask)', &
'', &
'DESCRIPTION', &
'  Determines the location of the element in the array with the maximum value,', &
'  or, if the DIM argument is supplied, determines the locations of the maximum', &
'  element along each row of the array in the DIM direction. If MASK is', &
'  present, only the elements for which MASK is .true. are considered. If more', &
'  than one element in the array has the maximum value, the location returned', &
'  is that of the first such element in array element order. If the array has', &
'  zero size, or all of the elements of MASK are \.false., then the result is', &
'  an array of zeroes. Similarly, if DIM is supplied and all of the elements of', &
'  MASK along a given row are zero, the result value for that row is zero.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer, real, or character.', &
'', &
'  o  DIM : (Optional) Shall be a scalar of type integer, with a value between', &
'     one and the rank of ARRAY, inclusive. It may not be an optional dummy', &
'     argument.', &
'', &
'  o  MASK : Shall be an array of type logical, and conformable with ARRAY.', &
'', &
'RETURNS', &
'  If DIM is absent, the result is a rank-one array with a length equal to the', &
'  rank of ARRAY. If DIM is present, the result is an array with a rank one', &
'  less than the rank of ARRAY, and a size corresponding to the size of ARRAY', &
'  with the DIM dimension removed. If DIM is present and ARRAY has a rank of', &
'  one, the result is a scalar. In all cases, the result is of default integer', &
'  type.', &
'', &
'  The value returned is reference to the offset from the beginning of the', &
'  array, not necessarily the subscript value if the array subscripts do not', &
'  start with one.', &
'', &
'EXAMPLES', &
'  sample program', &
'', &
'      program demo_maxloc', &
'      implicit none', &
'      integer      :: ii', &
'      integer,save :: i(-3:3)=[(abs(abs(ii)-50),ii=-3,3)]', &
'      integer,save :: ints(3,5)= reshape([&', &
'         1,  2,  3,  4,  5, &', &
'         10, 20, 30, 40, 50, &', &
'         11, 22, 33, 44, 55  &', &
'      ],shape(ints),order=[2,1])', &
'', &
'          write(*,*) maxloc(ints)', &
'          write(*,*) maxloc(ints,dim=1)', &
'          write(*,*) maxloc(ints,dim=2)', &
'          ! when array bounds do not start with one remember MAXLOC(3) returns', &
'          ! the offset relative to the lower bound-1 of the location of the', &
'          ! maximum value, not the subscript of the maximum value. When the', &
'          ! lower bound of the array is one, these values are the same. In', &
'          ! other words, MAXLOC(3) returns the subscript of the value assuming', &
'          ! the first subscript of the array is one no matter what the lower', &
'          ! bound of the subscript actually is.', &
'          write(*,''(g0,1x,g0)'') (ii,i(ii),ii=lbound(i,dim=1),ubound(i,dim=1))', &
'          write(*,*)maxloc(i)', &
'', &
'      end program demo_maxloc', &
'', &
'  Results:', &
'', &
'    3', &
'', &
'    3 3       3       3       3', &
'', &
'    5 5       5 -3 47 -2 48 -1 49 0 50 1 49 2 48 3 47', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  MAX(3), MAXVAL(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              maxloc(3fortran)', &
'']

shortname="maxloc"
call process()


case('133','maxval')

textblock=[character(len=256) :: &
'', &
'maxval(3fortran)                                              maxval(3fortran)', &
'', &
'NAME', &
'  MAXVAL(3) - [ARRAY REDUCTION] determines the maximum value in an array or', &
'  row', &
'', &
'SYNTAX', &
'  result = maxval(array, dim, mask)', &
'', &
'  or', &
'', &
'      result = maxval(array, mask)', &
'', &
'DESCRIPTION', &
'  Determines the maximum value of the elements in an array value, or, if the', &
'  DIM argument is supplied, determines the maximum value along each row of the', &
'  array in the DIM direction. If MASK is present, only the elements for which', &
'  MASK is .true. are considered. If the array has zero size, or all of the', &
'  elements of MASK are .false., then the result is the most negative number of', &
'  the type and kind of ARRAY if ARRAY is numeric, or a string of nulls if', &
'  ARRAY is of character type.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer, real, or character.', &
'', &
'  o  DIM : (Optional) Shall be a scalar of type integer, with a value between', &
'     one and the rank of ARRAY, inclusive. It may not be an optional dummy', &
'     argument.', &
'', &
'  o  MASK : (Optional) Shall be an array of type logical, and conformable with', &
'     ARRAY.', &
'', &
'RETURNS', &
'  If DIM is absent, or if ARRAY has a rank of one, the result is a scalar.  If', &
'  DIM is present, the result is an array with a rank one less than the rank of', &
'  ARRAY, and a size corresponding to the size of ARRAY with the DIM dimension', &
'  removed. In all cases, the result is of the same type and kind as ARRAY.', &
'', &
'EXAMPLES', &
'  sample program:', &
'', &
'      program demo_maxval', &
'      implicit none', &
'      integer,save :: ints(3,5)= reshape([&', &
'         1,  2,  3,  4,  5, &', &
'        10, 20, 30, 40, 50, &', &
'        11, 22, 33, 44, 55  &', &
'      ],shape(ints),order=[2,1])', &
'', &
'         write(*,*) maxval(ints)', &
'         write(*,*) maxval(ints,dim=1)', &
'         write(*,*) maxval(ints,dim=2)', &
'         ! find biggest number less than 30 with mask', &
'         write(*,*) maxval(ints,mask=ints.lt.30)', &
'      end program demo_maxval', &
'', &
'  Results:', &
'', &
'         55', &
'         11     22     33     44     55', &
'          5     50     55', &
'         22', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  MAX(3), MAXLOC(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              maxval(3fortran)', &
'']

shortname="maxval"
call process()


case('134','merge')

textblock=[character(len=256) :: &
'', &
'merge(3fortran)                                                merge(3fortran)', &
'', &
'NAME', &
'  MERGE(3) - [ARRAY CONSTRUCTION] Merge variables', &
'', &
'SYNTAX', &
'  result = merge(tsource, fsource, mask)', &
'', &
'DESCRIPTION', &
'  The elemental function MERGE(3) selects values from two arrays or scalars', &
'  according to a logical mask. The result is equal to an element of TSOURCE', &
'  where the corresponding element of MASK is .true., or an element of FSOURCE', &
'  when it is .false. .', &
'', &
'  Multi-dimensional arrays are supported.', &
'', &
'  Note that argument expressions to MERGE(3) are not required to be short-', &
'  circuited so (as an example) if the array X contains zero values in the', &
'  statement below the standard does not prevent floating point divide by zero', &
'  being generated; as 1.0/X may be evaluated for all values of X before the', &
'  mask is used to select which value to retain:', &
'', &
'            y = merge( 1.0/x, 0.0, x /= 0.0 )', &
'', &
'  Note the compiler is also free to short-circuit or to generate an infinity', &
'  so this may work in many programming environments but is not recommended.', &
'', &
'  For cases like this one may instead use masked assignment via the WHERE', &
'  construct:', &
'', &
'            where(x .ne. 0.0)', &
'               y = 1.0/x', &
'            elsewhere', &
'               y = 0.0', &
'            endwhere', &
'', &
'  instead of the more obscure', &
'', &
'            merge(1.0/merge(x,1.0,x /= 0.0), 0.0, x /= 0.0)', &
'', &
'ARGUMENTS', &
'  o  TSOURCE : May be of any type, including user-defined.', &
'', &
'  o  FSOURCE : Shall be of the same type and type parameters as TSOURCE.', &
'', &
'  o  MASK : Shall be of type logical.', &
'', &
'  Note that (currently) character values must be of the same length.', &
'', &
'RETURNS', &
'  The result is of the same type and type parameters as TSOURCE. For any', &
'  element the result is TSOURCE if MASK is true and FSOURCE otherwise.', &
'', &
'EXAMPLES', &
'  The value of', &
'', &
'           merge (1.0, 0.0, k > 0)', &
'', &
'  is 1.0 for K=5 and 0.0 for K=-2.', &
'', &
'      program demo_merge', &
'      implicit none', &
'      integer :: tvals(2,3), fvals(2,3), answer(2,3)', &
'      logical :: mask(2,3)', &
'      integer :: i', &
'      logical :: chooseleft', &
'', &
'         tvals(1,:)=[  10, -60,  50 ]', &
'         tvals(2,:)=[ -20,  40, -60 ]', &
'', &
'         fvals(1,:)=[ 0, 3, 2 ]', &
'         fvals(2,:)=[ 7, 4, 8 ]', &
'', &
'         mask(1,:)=[ .true.,  .false., .true. ]', &
'         mask(2,:)=[ .false., .false., .true. ]', &
'', &
'         write(*,*)''mask of logicals''', &
'         answer=merge( tvals, fvals, mask )', &
'         call printme()', &
'', &
'         write(*, *)''highest values''', &
'         answer=merge( tvals, fvals, tvals > fvals )', &
'         call printme()', &
'', &
'         write(*, *)''lowest values''', &
'         answer=merge( tvals, fvals, tvals < fvals )', &
'         call printme()', &
'', &
'         write(*, *)''zero out negative values''', &
'         answer=merge( tvals, 0, tvals < 0)', &
'         call printme()', &
'', &
'         write(*, *)''binary choice''', &
'         chooseleft=.false.', &
'         write(*, ''(3i4)'')merge([1,2,3],[10,20,30],chooseleft)', &
'         chooseleft=.true.', &
'         write(*, ''(3i4)'')merge([1,2,3],[10,20,30],chooseleft)', &
'', &
'      contains', &
'', &
'      subroutine printme()', &
'            write(*, ''(3i4)'')(answer(i, :), i=1, size(answer, dim=1))', &
'      end subroutine printme', &
'', &
'      end program demo_merge', &
'', &
'  Expected Results:', &
'', &
'          mask of logicals', &
'           10   3  50', &
'            7   4 -60', &
'          highest values', &
'           10   3  50', &
'            7  40   8', &
'          lowest values', &
'            0 -60   2', &
'          -20   4 -60', &
'          zero out negative values', &
'            0 -60   0', &
'          -20   0 -60', &
'          binary choice', &
'           10  20  30', &
'            1   2   3', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  PACK(3), UNPACK(3), PACK(3), SPREAD(3), UNPACK(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022               merge(3fortran)', &
'']

shortname="merge"
call process()


case('135','merge_bits')

textblock=[character(len=256) :: &
'', &
'merge_bits(3fortran)                                      merge_bits(3fortran)', &
'', &
'NAME', &
'  MERGE_BITS(3) - [BIT:COPY] Merge bits using a mask', &
'', &
'SYNTAX', &
'  result = merge_bits(i, j, mask)', &
'', &
'          elemental function merge_bits(i,j,mask) result(r)', &
'          integer(kind=KIND), intent(in) :: i, j, mask', &
'          integer(kind=KIND) :: r', &
'', &
'  where the result and all input values have the same integer type and KIND', &
'  with the exception that the mask and either I or J may be a BOZ constant.', &
'', &
'DESCRIPTION', &
'  A common graphics operation in Ternary Raster Operations is to combine bits', &
'  from two different sources, generally referred to as bit-blending.', &
'  MERGE_BITS performs a masked bit-blend of I and J using the bits of the MASK', &
'  value to determine which of the input values to copy bits from.', &
'', &
'  Specifically, The k-th bit of the result is equal to the k-th bit of I if', &
'  the k-th bit of MASK is 1; it is equal to the k-th bit of J otherwise (so', &
'  all three input values must have the same number of bits).', &
'', &
'  The resulting value is the same as would result from', &
'', &
'          ior (iand (i, mask),iand (j, not (mask)))', &
'', &
'  An exception to all values being of the same integer type is that I or J', &
'  and/or the mask may be a BOZ constant (A BOZ constant means it is either a', &
'  Binary, Octal, or Hexadecimal literal constant). The BOZ values are', &
'  converted to the integer type of the non-BOZ value(s) as if called by the', &
'  intrinsic function INT() with the kind of the non-BOZ value(s), so the BOZ', &
'  values must be in the range of the type of the result.', &
'', &
'ARGUMENTS', &
'  o  I : value to select bits from when the associated bit in the mask is', &
'', &
'     1.', &
'', &
'  o  J : value to select bits from when the associated bit in the mask is', &
'', &
'     0.', &
'', &
'  o  MASK : a value whose bits are used as a mask to select bits from I and J', &
'', &
'RETURNS', &
'  The bits blended from I and J using the mask MASK. It is the same type as I', &
'  if I is of type integer, otherwise the same type as J.', &
'', &
'EXAMPLE', &
'  Sample program:', &
'', &
'      program demo_merge_bits', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int16) :: if_one,if_zero,msk', &
'      character(len=*),parameter :: fmt=''(*(g0, 1X))''', &
'', &
'         ! basic usage', &
'         print *,''MERGE_BITS( 5,10,41) should be 3.=>'',merge_bits(5,10,41)', &
'         print *,''MERGE_BITS(13,18,22) should be 4.=>'',merge_bits(13,18,22)', &
'', &
'         ! use some values in base2 illustratively:', &
'         if_one =int(b''1010101010101010'',kind=int16)', &
'         if_zero=int(b''0101010101010101'',kind=int16)', &
'', &
'         msk=int(b''0101010101010101'',kind=int16)', &
'         print ''("should get all zero bits =>",b16.16)'', &', &
'         & merge_bits(if_one,if_zero,msk)', &
'', &
'         msk=int(b''1010101010101010'',kind=int16)', &
'         print ''("should get all ones bits =>",b16.16)'', &', &
'         & merge_bits(if_one,if_zero,msk)', &
'', &
'         ! using BOZ values', &
'         print fmt, &', &
'         & merge_bits(32767_int16,    o''12345'',         32767_int16), &', &
'         & merge_bits(o''12345'', 32767_int16, b''0000000000010101''), &', &
'         & merge_bits(32767_int16,    o''12345'',             z''1234'')', &
'', &
'         ! a do-it-yourself equivalent for comparison and validation', &
'         print fmt, &', &
'         & ior(iand(32767_int16, 32767_int16),                   &', &
'         &   iand(o''12345'', not(32767_int16))),                  &', &
'', &
'         & ior(iand(o''12345'', int(o''12345'', kind=int16)),        &', &
'         &   iand(32767_int16, not(int(o''12345'', kind=int16)))), &', &
'', &
'         & ior(iand(32767_int16, z''1234''),                       &', &
'         &   iand(o''12345'', not(int( z''1234'', kind=int16))))', &
'', &
'      end program demo_merge_bits', &
'', &
'  Results:', &
'', &
'          MERGE_BITS( 5,10,41) should be 3.=>           3', &
'          MERGE_BITS(13,18,22) should be 4.=>           4', &
'  should get all zero bits =>0000000000000000 should get all ones bits', &
'  =>1111111111111111 32767 32751 5877 32767 32767 5877', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022          merge_bits(3fortran)', &
'']

shortname="merge_bits"
call process()


case('136','min')

textblock=[character(len=256) :: &
'', &
'min(3fortran)                                                    min(3fortran)', &
'', &
'NAME', &
'  MIN(3) - [NUMERIC] Minimum value of an argument list', &
'', &
'SYNTAX', &
'  result = min(a1, a2, a3, ... )', &
'', &
'DESCRIPTION', &
'  Returns the argument with the smallest (most negative) value.', &
'', &
'ARGUMENTS', &
'  o  A1 : The type shall be integer or real.', &
'', &
'  o  A2, A3, ... : An expression of the same type and kind as A1.', &
'', &
'RETURNS', &
'  The return value corresponds to the minimum value among the arguments, and', &
'  has the same type and kind as the first argument.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_min', &
'      implicit none', &
'          write(*,*)min(10.0,11.0,30.0,-100.0)', &
'      end program demo_min', &
'', &
'  Results:', &
'', &
'            -100.0000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  MAX(3), MINLOC(3), MINVAL(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 min(3fortran)', &
'']

shortname="min"
call process()


case('137','minexponent')

textblock=[character(len=256) :: &
'', &
'minexponent(3fortran)                                    minexponent(3fortran)', &
'', &
'NAME', &
'  MINEXPONENT(3) - [NUMERIC MODEL] Minimum exponent of a real kind', &
'', &
'SYNTAX', &
'  result = minexponent(x)', &
'', &
'DESCRIPTION', &
'  MINEXPONENT(X) returns the minimum exponent in the model of the type of X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real.', &
'', &
'RETURNS', &
'  The return value is of type integer and of the default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_minexponent', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'       &real_kinds, real32, real64, real128', &
'      implicit none', &
'      real(kind=real32) :: x', &
'      real(kind=real64) :: y', &
'          print *, minexponent(x), maxexponent(x)', &
'          print *, minexponent(y), maxexponent(y)', &
'      end program demo_minexponent', &
'', &
'  Expected Results:', &
'', &
'              -125         128', &
'', &
'    -1021', &
'      1024', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         minexponent(3fortran)', &
'']

shortname="minexponent"
call process()


case('138','minloc')

textblock=[character(len=256) :: &
'', &
'minloc(3fortran)                                              minloc(3fortran)', &
'', &
'NAME', &
'  MINLOC(3) - [ARRAY:LOCATION] Location of the minimum value within an array', &
'', &
'SYNTAX', &
'  result = minloc(array, dim, mask)', &
'', &
'  or', &
'', &
'          result = minloc(array, mask)', &
'', &
'DESCRIPTION', &
'  Determines the location of the element in the array with the minimum value,', &
'  or, if the DIM argument is supplied, determines the locations of the minimum', &
'  element along each row of the array in the DIM direction. If MASK is', &
'  present, only the elements for which MASK is .true. are considered. If more', &
'  than one element in the array has the minimum value, the location returned', &
'  is that of the first such element in array element order. If the array has', &
'  zero size, or all of the elements of MASK are \.false., then the result is', &
'  an array of zeroes. Similarly, if DIM is supplied and all of the elements of', &
'  MASK along a given row are zero, the result value for that row is zero.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer, real, or character.', &
'', &
'  o  DIM : (Optional) Shall be a scalar of type integer, with a value between', &
'     one and the rank of ARRAY, inclusive. It may not be an optional dummy', &
'     argument.', &
'', &
'  o  MASK : Shall be an array of type logical, and conformable with ARRAY.', &
'', &
'RETURNS', &
'  If DIM is absent, the result is a rank-one array with a length equal to the', &
'  rank of ARRAY. If DIM is present, the result is an array with a rank one', &
'  less than the rank of ARRAY, and a size corresponding to the size of ARRAY', &
'  with the DIM dimension removed. If DIM is present and ARRAY has a rank of', &
'  one, the result is a scalar. In all cases, the result is of default integer', &
'  type.', &
'', &
'EXAMPLES', &
'  sample program:', &
'', &
'      program demo_minloc', &
'      implicit none', &
'      integer,save :: ints(3,5)= reshape([&', &
'         4, 10,  1,  7, 13, &', &
'         9, 15,  6, 12,  3, &', &
'        14,  5, 11,  2,  8  &', &
'      ],shape(ints),order=[2,1])', &
'         write(*,*) minloc(ints)', &
'         write(*,*) minloc(ints,dim=1)', &
'         write(*,*) minloc(ints,dim=2)', &
'         ! where in each column is the smallest number .gt. 10 ?', &
'         write(*,*) minloc(ints,dim=2,mask=ints.gt.10)', &
'         ! a one-dimensional array with dim=1 explicitly listed returns a scalar', &
'         write(*,*) minloc(pack(ints,.true.),dim=1) ! scalar', &
'      end program demo_minloc', &
'', &
'  Results:', &
'', &
'    1', &
'', &
'    1 3       1       3       2', &
'', &
'    3 5       4', &
'', &
'    5 4       3 7', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  MIN(3), MINVAL(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              minloc(3fortran)', &
'']

shortname="minloc"
call process()


case('139','minval')

textblock=[character(len=256) :: &
'', &
'minval(3fortran)                                              minval(3fortran)', &
'', &
'NAME', &
'  MINVAL(3) - [ARRAY REDUCTION] Minimum value of an array', &
'', &
'SYNTAX', &
'  result = minval(array, dim, mask) result = minval(array, mask)', &
'', &
'DESCRIPTION', &
'  Determines the minimum value of the elements in an array value, or, if the', &
'  DIM argument is supplied, determines the minimum value along each row of the', &
'  array in the DIM direction.', &
'', &
'  If MASK is present, only the elements for which MASK is .true. are', &
'  considered.', &
'', &
'  If the array has zero size, or all of the elements of MASK are .false., then', &
'  the result is HUGE(ARRAY) if ARRAY is numeric, or a string of CHAR(LEN=255)', &
'  characters if ARRAY is of character type.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer, real, or character.', &
'', &
'  o  DIM : (Optional) Shall be a scalar of type integer, with a value between', &
'     one and the rank of ARRAY, inclusive. It may not be an optional dummy', &
'     argument.', &
'', &
'  o  MASK : Shall be an array of type logical, and conformable with ARRAY.', &
'', &
'RETURNS', &
'  If DIM is absent, or if ARRAY has a rank of one, the result is a scalar.', &
'', &
'  If DIM is present, the result is an array with a rank one less than the rank', &
'  of ARRAY, and a size corresponding to the size of ARRAY with the DIM', &
'  dimension removed. In all cases, the result is of the same type and kind as', &
'  ARRAY.', &
'', &
'EXAMPLES', &
'  sample program:', &
'', &
'      program demo_minval', &
'      implicit none', &
'      integer :: i', &
'      character(len=*),parameter :: g=''(3x,*(g0,1x))''', &
'', &
'      integer,save :: ints(3,5)= reshape([&', &
'             1,  -2,   3,   4,   5,  &', &
'            10,  20, -30,  40,  50,  &', &
'            11,  22,  33, -44,  55  &', &
'      ],shape(ints),order=[2,1])', &
'', &
'      integer,save :: box(3,5,2)', &
'', &
'         box(:,:,1)=ints', &
'         box(:,:,2)=-ints', &
'', &
'         write(*,*)''Given the array''', &
'         write(*,''(1x,*(g4.4,1x))'') &', &
'         & (ints(i,:),new_line(''a''),i=1,size(ints,dim=1))', &
'', &
'         write(*,*)''What is the smallest element in the array?''', &
'         write(*,g) minval(ints),''at <'',minloc(ints),''>''', &
'', &
'         write(*,*)''What is the smallest element in each column?''', &
'         write(*,g) minval(ints,dim=1)', &
'', &
'         write(*,*)''What is the smallest element in each row?''', &
'         write(*,g) minval(ints,dim=2)', &
'', &
'         ! notice the shape of the output has less columns', &
'         ! than the input in this case', &
'         write(*,*)''What is the smallest element in each column,''', &
'         write(*,*)''considering only those elements that are''', &
'         write(*,*)''greater than zero?''', &
'         write(*,g) minval(ints, dim=1, mask = ints > 0)', &
'', &
'         write(*,*)&', &
'         & ''if everything is false a zero-sized array is NOT returned''', &
'         write(*,*) minval(ints, dim=1, mask = .false.)', &
'         write(*,*)''even for a zero-sized input''', &
'         write(*,g) minval([integer ::], dim=1, mask = .false.)', &
'', &
'         write(*,*)''a scalar answer for everything false is huge()''', &
'         write(*,g) minval(ints, mask = .false.)', &
'         write(*,g) minval([integer ::], mask = .false.)', &
'', &
'         write(*,*)''some calls with three dimensions''', &
'         write(*,g) minval(box, mask = .true. )', &
'         write(*,g) minval(box, dim=1, mask = .true. )', &
'', &
'         write(*,g) minval(box, dim=2, mask = .true. )', &
'         write(*,g) ''shape of answer is '', &', &
'         & shape(minval(box, dim=2, mask = .true. ))', &
'', &
'      end program demo_minval', &
'', &
'  Results:', &
'', &
'       Given the array', &
'          1   -2    3    4    5', &
'         10   20  -30   40   50', &
'         11   22   33  -44   55', &
'', &
'       What is the smallest element in the array?', &
'         -44 at < 3 4 >', &
'       What is the smallest element in each column?', &
'         1 -2 -30 -44 5', &
'       What is the smallest element in each row?', &
'         -2 -30 -44', &
'       What is the smallest element in each column,', &
'       considering only those elements that are', &
'       greater than zero?', &
'         1 20 3 4 5', &
'       if everything is false a zero-sized array is NOT returned', &
'        2147483647  2147483647  2147483647  2147483647  2147483647', &
'       even for a zero-sized input', &
'         2147483647', &
'       a scalar answer for everything false is huge()', &
'         2147483647', &
'         2147483647', &
'       some calls with three dimensions', &
'         -55', &
'         1 -2 -30 -44 5 -11 -22 -33 -40 -55', &
'         -2 -30 -44 -5 -50 -55', &
'         shape of answer is  3 2', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  MIN(3), MINLOC(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              minval(3fortran)', &
'']

shortname="minval"
call process()


case('140','mod')

textblock=[character(len=256) :: &
'', &
'mod(3fortran)                                                    mod(3fortran)', &
'', &
'NAME', &
'  MOD(3) - [NUMERIC] Remainder function', &
'', &
'SYNTAX', &
'  result = mod(a, p)', &
'', &
'DESCRIPTION', &
'  MOD(a,p) computes the remainder of the division of A by P.', &
'', &
'ARGUMENTS', &
'  o  A : Shall be a scalar of type integer or real.', &
'', &
'  o  P : Shall be a scalar of the same type and kind as A and not equal to', &
'     zero.', &
'', &
'RETURNS', &
'  The return value is the result of A - (INT(A/P) * P). The type and kind of', &
'  the return value is the same as that of the arguments. The returned value', &
'  has the same sign as A and a magnitude less than the magnitude of P.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_mod', &
'      implicit none', &
'           print *, mod(17,3)           ! yields 2', &
'           print *, mod(17.5,5.5)       ! yields 1.0', &
'           print *, mod(17.5d0,5.5d0)   ! yields 1.0d0', &
'           print *, mod(17.5d0,5.5d0)   ! yields 1.0d0', &
'', &
'           print *, mod(-17,3)          ! yields -2', &
'           print *, mod(-17.5,5.5)      ! yields -1.0', &
'           print *, mod(-17.5d0,5.5d0)  ! yields -1.0d0', &
'           print *, mod(-17.5d0,5.5d0)  ! yields -1.0d0', &
'', &
'           print *, mod(17,-3)          ! yields 2', &
'           print *, mod(17.5,-5.5)      ! yields 1.0', &
'           print *, mod(17.5d0,-5.5d0)  ! yields 1.0d0', &
'           print *, mod(17.5d0,-5.5d0)  ! yields 1.0d0', &
'      end program demo_mod', &
'', &
'  Results:', &
'', &
'    2 1.00000000 1.0000000000000000 1.0000000000000000 -2 -1.00000000', &
'    -1.0000000000000000 -1.0000000000000000 2 1.00000000 1.0000000000000000', &
'    1.0000000000000000', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  MODULO(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 mod(3fortran)', &
'']

shortname="mod"
call process()


case('141','modulo')

textblock=[character(len=256) :: &
'', &
'modulo(3fortran)                                              modulo(3fortran)', &
'', &
'NAME', &
'  MODULO(3) - [NUMERIC] Modulo function', &
'', &
'SYNTAX', &
'  result = modulo(a, p)', &
'', &
'DESCRIPTION', &
'  MODULO(A,P) computes the A modulo P.', &
'', &
'ARGUMENTS', &
'  o  A : Shall be a scalar of type integer or real.', &
'', &
'  o  P : Shall be a scalar of the same type and kind as A. It shall not be', &
'     zero.', &
'', &
'RETURNS', &
'  The type and kind of the result are those of the arguments.', &
'', &
'  o  If A and P are of type integer: MODULO(A,P) has the value of A - FLOOR', &
'     (REAL(A) / REAL(P)) * P.', &
'', &
'  o  If A and P are of type real: MODULO(A,P) has the value of A - FLOOR (A /', &
'     P) * P.', &
'', &
'  The returned value has the same sign as P and a magnitude less than the', &
'  magnitude of P.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_modulo', &
'      implicit none', &
'           print *, modulo(17,3)        ! yields 2', &
'           print *, modulo(17.5,5.5)    ! yields 1.0', &
'', &
'           print *, modulo(-17,3)       ! yields 1', &
'           print *, modulo(-17.5,5.5)   ! yields 4.5', &
'', &
'           print *, modulo(17,-3)       ! yields -1', &
'           print *, modulo(17.5,-5.5)   ! yields -4.5', &
'      end program demo_modulo', &
'', &
'  Results:', &
'', &
'    2 1.00000000 1 4.50000000 -1 -4.50000000', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  MOD(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              modulo(3fortran)', &
'']

shortname="modulo"
call process()


case('142','move_alloc')

textblock=[character(len=256) :: &
'', &
'move_alloc(3fortran)                                      move_alloc(3fortran)', &
'', &
'NAME', &
'  MOVE_ALLOC(3) - [] Move allocation from one object to another', &
'', &
'SYNTAX', &
'  call move_alloc(src, dest)', &
'', &
'DESCRIPTION', &
'  MOVE_ALLOC(SRC, DEST) moves the allocation from SRC to DEST. SRC will become', &
'  deallocated in the process.', &
'', &
'ARGUMENTS', &
'  o  SRC : allocatable, INTENT(INOUT), may be of any type and kind.', &
'', &
'  o  DEST : allocatable, INTENT(OUT), shall be of the same type, kind and rank', &
'     as SRC.', &
'', &
'EXAMPLES', &
'  Basic Sample program to allocate a bigger grid', &
'', &
'      program demo_move_alloc', &
'      implicit none', &
'      ! Example to allocate a bigger GRID', &
'      real, allocatable :: grid(:), tempgrid(:)', &
'      integer :: n, i', &
'', &
'         ! initialize small GRID', &
'         n = 3', &
'         allocate (grid(1:n))', &
'         grid = [ (real (i), i=1,n) ]', &
'', &
'         ! initialize TEMPGRID which will be used to replace GRID', &
'         allocate (tempgrid(1:2*n))    ! Allocate bigger grid', &
'         tempgrid(::2)  = grid         ! Distribute values to new locations', &
'         tempgrid(2::2) = grid + 0.5   ! initialize other values', &
'', &
'         ! move TEMPGRID to GRID', &
'         call MOVE_ALLOC (from=tempgrid, to=grid)', &
'', &
'         ! TEMPGRID should no longer be allocated', &
'         ! and GRID should be the size TEMPGRID was', &
'         if (size (grid) /= 2*n .or. allocated (tempgrid)) then', &
'            print *, "Failure in move_alloc!"', &
'         endif', &
'         print *, allocated(grid), allocated(tempgrid)', &
'         print ''(99f8.3)'', grid', &
'      end program demo_move_alloc', &
'', &
'  Results:', &
'', &
'   T F', &
'  1.000', &
'    1.500   2.000   2.500   3.000   3.500', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  ALLOCATED(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          move_alloc(3fortran)', &
'']

shortname="move_alloc"
call process()


case('143','mvbits')

textblock=[character(len=256) :: &
'', &
'mvbits(3fortran)                                              mvbits(3fortran)', &
'', &
'NAME', &
'  MVBITS(3) - [BIT:COPY] reproduce bit patterns found in one integer in', &
'  another', &
'', &
'SYNTAX', &
'  call mvbits(from, frompos, len, to, topos)', &
'', &
'DESCRIPTION', &
'  MVBITS(3F) copies a bit pattern found in a range of adjacent bits in the', &
'  integer FROM to a specified position in another integer TO (which is of the', &
'  same kind as FROM). It otherwise leaves the bits in TO as-is.', &
'', &
'  The bit positions copied must exist within the value of FROM. That is, the', &
'  values of FROMPOS+LEN-1 and TOPOS+LEN-1 must be nonnegative and less than', &
'  BIT_SIZE(from).', &
'', &
'  The bits are numbered 0 to BIT_SIZE(I)-1, from right to left.', &
'', &
'ARGUMENTS', &
'  o  FROM : An integer to read bits from.', &
'', &
'  o  FROMPOS : FROMPOS is the position of the first bit to copy. It is a', &
'     nonnegative integer value < BIT_SIZE(FROM).', &
'', &
'  o  LEN : A nonnegative integer value that indicates how many bits to copy', &
'     from FROM. It must not specify copying bits past the end of FROM. That', &
'     is, FROMPOS + LEN must be less than or equal to BIT_SIZE(FROM).', &
'', &
'  o  TO : The integer variable to place the copied bits into. It must be of', &
'     the same kind as FROM and may even be the same variable as FROM.', &
'', &
'     TO : is set by copying the sequence of bits of length LEN, starting at', &
'     position FROMPOS of FROM to position TOPOS of TO. No other bits of TO are', &
'     altered. On return, the LEN bits of TO starting at TOPOS are equal to the', &
'     value that the LEN bits of FROM starting at FROMPOS had on entry.', &
'', &
'  o  TOPOS : A nonnegative integer value indicating the starting location in', &
'     TO to place the specified copy of bits from FROM. TOPOS + LEN must be', &
'     less than or equal to BIT_SIZE(TO).', &
'', &
'EXAMPLE', &
'  Sample program that populates a new 32-bit integer with its bytes in reverse', &
'  order (ie. changes the Endian of the integer).', &
'', &
'      program demo_mvbits', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: intfrom, intto, abcd_int', &
'      character(len=*),parameter :: bits= ''(g0,t30,b32.32)''', &
'      character(len=*),parameter :: fmt= ''(g0,t30,a,t40,b32.32)''', &
'', &
'          intfrom=huge(0)  ! all bits are 1 accept the sign bit', &
'          intto=0          ! all bits are 0', &
'', &
'          !! CHANGE BIT 0', &
'          ! show the value and bit pattern', &
'          write(*,bits)intfrom,intfrom', &
'          write(*,bits)intto,intto', &
'', &
'          ! copy bit 0 from intfrom to intto to show the rightmost bit changes', &
'          !          (from,    frompos, len,    to, topos)', &
'          call mvbits(intfrom,       0,   1, intto,     0) ! change bit 0', &
'          write(*,bits)intto,intto', &
'', &
'          !! COPY PART OF A VALUE TO ITSELF', &
'          ! can copy bit from a value to itself', &
'          call mvbits(intfrom,0,1,intfrom,31)', &
'          write(*,bits)intfrom,intfrom', &
'', &
'          !! MOVING BYTES AT A TIME', &
'          ! make native integer value with bit patterns', &
'          ! that happen to be the same as the beginning of the alphabet', &
'          ! to make it easy to see the bytes are reversed', &
'          abcd_int=transfer(''abcd'',0)', &
'          ! show the value and bit pattern', &
'          write(*,*)''native''', &
'          write(*,fmt)abcd_int,abcd_int,abcd_int', &
'', &
'          ! change endian of the value', &
'          abcd_int=int_swap32(abcd_int)', &
'          ! show the values and their bit pattern', &
'          write(*,*)''non-native''', &
'          write(*,fmt)abcd_int,abcd_int,abcd_int', &
'', &
'       contains', &
'', &
'       pure elemental function int_swap32(intin) result(intout)', &
'       ! Convert a 32 bit integer from big Endian to little Endian,', &
'       ! or conversely from little Endian to big Endian.', &
'       !', &
'       integer(kind=int32), intent(in)  :: intin', &
'       integer(kind=int32) :: intout', &
'          ! copy bytes from input value to new position in output value', &
'          !          (from,  frompos, len,     to, topos)', &
'          call mvbits(intin,       0,   8, intout,    24) ! byte1 to byte4', &
'          call mvbits(intin,       8,   8, intout,    16) ! byte2 to byte3', &
'          call mvbits(intin,      16,   8, intout,     8) ! byte3 to byte2', &
'          call mvbits(intin,      24,   8, intout,     0) ! byte4 to byte1', &
'       end function int_swap32', &
'', &
'       end program demo_mvbits', &
'', &
'  Results:', &
'', &
'         2147483647                   01111111111111111111111111111111', &
'         0                            00000000000000000000000000000000', &
'         1                            00000000000000000000000000000001', &
'         -1                           11111111111111111111111111111111', &
'          native', &
'         1684234849                   abcd      01100100011000110110001001100001', &
'          non-native', &
'         1633837924                   dcba      01100001011000100110001101100100', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IEOR(3), IBCLR(3), NOT(3), BTEST(3), IBCLR(3), IBITS(3), IBSET(3), IAND(3),', &
'  IOR(3), IEOR(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              mvbits(3fortran)', &
'']

shortname="mvbits"
call process()


case('144','nearest')

textblock=[character(len=256) :: &
'', &
'nearest(3fortran)                                            nearest(3fortran)', &
'', &
'NAME', &
'  NEAREST(3) - [MODEL_COMPONENTS] Nearest representable number', &
'', &
'SYNTAX', &
'  result = nearest(x, s)', &
'', &
'DESCRIPTION', &
'  NEAREST(X, S) returns the processor-representable number nearest to X in the', &
'  direction indicated by the sign of S.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real.', &
'', &
'  o  S : Shall be of type real and not equal to zero.', &
'', &
'RETURNS', &
'  The return value is of the same type as X. If S is positive, NEAREST returns', &
'  the processor-representable number greater than X and nearest to it. If S is', &
'  negative, NEAREST returns the processor-representable number smaller than X', &
'  and nearest to it.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_nearest', &
'      implicit none', &
'', &
'         real :: x, y', &
'         x = nearest(42.0, 1.0)', &
'         y = nearest(42.0, -1.0)', &
'         write (*,"(3(g20.15))") x, y, x - y', &
'', &
'      !  write (*,"(3(g20.15))") &', &
'      !   nearest(tiny(0.0),1.0), &', &
'      !   nearest(tiny(0.0),-1.0), &', &
'      !   nearest(tiny(0.0),1.0) -nearest(tiny(0.0),-1.0)', &
'', &
'      !  write (*,"(3(g20.15))") &', &
'      !   nearest(huge(0.0),1.0), &', &
'      !   nearest(huge(0.0),-1.0), &', &
'      !   nearest(huge(0.0),1.0)- nearest(huge(0.0),-1.0)', &
'', &
'      end program demo_nearest', &
'', &
'  Results:', &
'', &
'         42.0000038146973    41.9999961853027    .762939453125000E-05', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             nearest(3fortran)', &
'']

shortname="nearest"
call process()


case('145','new_line')

textblock=[character(len=256) :: &
'', &
'new_line(3fortran)                                          new_line(3fortran)', &
'', &
'NAME', &
'  NEW_LINE(3) - [CHARACTER] new-line character', &
'', &
'SYNTAX', &
'  result = new_line(c)', &
'', &
'         character(len=1,kind=kind(c)) :: new_line(c)', &
'         character(len=1),intent(in) :: c(..)', &
'', &
'DESCRIPTION', &
'  NEW_LINE(C) returns the new-line character.', &
'', &
'  Case (i) : If A is default character and the character in position 10 of the', &
'  ASCII collating sequence is representable in the default character set, then', &
'  the result is ACHAR(10).', &
'', &
'  Case (ii) : If A is an ASCII character or an ISO 10646 character, then the', &
'  result is CHAR(10, KIND (A)).', &
'', &
'  Case (iii) : Otherwise, the result is a processor-dependent character that', &
'  represents a newline in output to files connected for formatted stream', &
'  output if there is such a character.', &
'', &
'  Case (iv) : Otherwise, the result is the blank character.', &
'', &
'ARGUMENTS', &
'  o  C : The argument shall be a scalar or array of the type character.', &
'', &
'RETURNS', &
'  Returns a character scalar of length one with the new-line character of the', &
'  same kind as parameter C.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_new_line', &
'      implicit none', &
'      character,parameter :: nl=new_line(''a'')', &
'      character(len=:),allocatable :: string', &
'', &
'         string=''This is record 1.''//nl//''This is record 2.''', &
'         write(*,''(a)'') string', &
'', &
'         write(*,''(*(a))'',advance=''no'') &', &
'            nl,''This is record 1.'',nl,''This is record 2.'',nl', &
'', &
'      end program demo_new_line', &
'', &
'  Results:', &
'', &
'         This is record 1.', &
'         This is record 2.', &
'', &
'         This is record 1.', &
'         This is record 2.', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022            new_line(3fortran)', &
'']

shortname="new_line"
call process()


case('146','nint')

textblock=[character(len=256) :: &
'', &
'nint(3fortran)                                                  nint(3fortran)', &
'', &
'NAME', &
'  NINT(3) - [TYPE:NUMERIC] Nearest whole number', &
'', &
'SYNTAX', &
'  elemental function nint(x [, kind=NN]) result(ANSWER)', &
'  real(kind=??),intent(in) :: x integer(kind=NN) :: ANSWER', &
'', &
'DESCRIPTION', &
'  NINT(X) rounds its argument to the nearest whole number with its sign', &
'  preserved.', &
'', &
'  The user must ensure the value is a valid value for the range of the KIND', &
'  returned. If the processor cannot represent the result in the kind', &
'  specified, the result is undefined.', &
'', &
'  If X is greater than zero, NINT(X) has the value INT(X+0.5).', &
'', &
'  If X is less than or equal to zero, NINT(X) has the value INT(A-0.5).', &
'', &
'ARGUMENTS', &
'  o  X : The type of the argument shall be real.', &
'', &
'  o  KIND : (Optional) A constant integer expression indicating the kind', &
'     parameter of the result. Otherwise, the kind type parameter is that of', &
'     default integer type.', &
'', &
'RETURNS', &
'  o  ANSWER : The result is the integer nearest X, or if there are two', &
'     integers equally near X, the result is whichever such integer has the', &
'     greater magnitude.', &
'', &
'     The result is undefined if it cannot be represented in the specified', &
'     integer type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_nint', &
'      implicit none', &
'      integer,parameter :: dp=kind(0.0d0)', &
'      real              :: x4 = 1.234E0', &
'      real(kind=dp)     :: x8 = 4.721_dp', &
'', &
'      ! basic use', &
'         print *, nint(x4), nint(x8),nint(-x8)', &
'         ! elemental', &
'         print *,nint([ &', &
'         &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'         &  0.0,   &', &
'         &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'', &
'      ! issues', &
'      ISSUES: block', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      integer :: icheck', &
'         ! make sure input is in range for the type returned', &
'         write(*,*)''Range limits for typical KINDS:''', &
'         write(*,''(1x,g0,1x,g0)'')  &', &
'         & int8,huge(0_int8),   &', &
'         & int16,huge(0_int16), &', &
'         & int32,huge(0_int32), &', &
'         & int64,huge(0_int64)', &
'', &
'         ! the standard does not require this to be an error ...', &
'         x8=12345.67e15 ! too big of a number', &
'         icheck=selected_int_kind(ceiling(log10(x8)))', &
'         write(*,*)''Any KIND big enough? ICHECK='',icheck', &
'         print *, ''These are all wrong answers for '',x8', &
'         print *, nint(x8,kind=int8)', &
'         print *, nint(x8,kind=int16)', &
'         print *, nint(x8,kind=int32)', &
'         print *, nint(x8,kind=int64)', &
'      endblock ISSUES', &
'', &
'      end program demo_nint', &
'', &
'  Results:', &
'', &
'    1 5   -5', &
'', &
'  -3', &
'    -3   -2   -2   -2', &
'', &
'    -1', &
'      -1    0    1    1', &
'', &
'      2 2    2    3    3 Range limits for typical KINDS: 1 127 2 32767 4', &
'        2147483647 8 9223372036854775807', &
'', &
'    Any KIND big enough? ICHECK=', &
'      16', &
'', &
'    These are all wrong answers for', &
'      1.2345669499901444E+019 0 0 0 -9223372036854775808', &
'', &
'STANDARD', &
'  FORTRAN 77 and later, with KIND argument - Fortran 90 and later', &
'', &
'SEE ALSO', &
'  AINT(3), ANINT(3), INT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                nint(3fortran)', &
'']

shortname="nint"
call process()


case('147','norm2')

textblock=[character(len=256) :: &
'', &
'norm2(3fortran)                                                norm2(3fortran)', &
'', &
'NAME', &
'  NORM2(3) - [MATHEMATICS] Euclidean vector norm', &
'', &
'SYNTAX', &
'  result = norm2(array, dim)', &
'', &
'  real function result norm2(array, dim)', &
'', &
'         real,intent(in) :: array(..)', &
'         integer,intent(in),optional :: dim', &
'', &
'DESCRIPTION', &
'  Calculates the Euclidean vector norm (L_2 norm) of ARRAY along dimension', &
'  DIM.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type real.', &
'', &
'  o  DIM : shall be a scalar of type integer with a value in the range from 1', &
'     to RANK(ARRAY).', &
'', &
'RETURNS', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM is absent, a scalar with the square root of the sum of squares of the', &
'  elements of ARRAY is returned.', &
'', &
'  Otherwise, an array of rank N-1, where N equals the rank of ARRAY, and a', &
'  shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_norm2', &
'      implicit none', &
'', &
'      real :: x(3,3) = reshape([ &', &
'         1, 2, 3, &', &
'         4, 5, 6, &', &
'         7, 8, 9  &', &
'      ],shape(x),order=[2,1])', &
'', &
'      write(*,*) ''x=''', &
'      write(*,''(4x,3f4.0)'')transpose(x)', &
'', &
'      write(*,*) ''norm2(x)='',norm2(x)', &
'', &
'      write(*,*) ''x**2=''', &
'      write(*,''(4x,3f4.0)'')transpose(x**2)', &
'      write(*,*)''sqrt(sum(x**2))='',sqrt(sum(x**2))', &
'', &
'      end program demo_norm2', &
'', &
'  Results:', &
'', &
'       x=', &
'            1.  2.  3.', &
'            4.  5.  6.', &
'            7.  8.  9.', &
'       norm2(x)=   16.88194', &
'       x**2=', &
'            1.  4.  9.', &
'           16. 25. 36.', &
'           49. 64. 81.', &
'       sqrt(sum(x**2))=   16.88194', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  PRODUCT(3), SUM(3), HYPOT(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               norm2(3fortran)', &
'']

shortname="norm2"
call process()


case('148','not')

textblock=[character(len=256) :: &
'', &
'not(3fortran)                                                    not(3fortran)', &
'', &
'NAME', &
'  NOT(3) - [BIT:LOGICAL] Logical negation', &
'', &
'SYNTAX', &
'  result = not(i)', &
'', &
'DESCRIPTION', &
'  NOT returns the bitwise Boolean inverse of I.', &
'', &
'ARGUMENTS', &
'  o  I : The type shall be integer.', &
'', &
'RETURNS', &
'  The return type is integer, of the same kind as the argument.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_not', &
'      implicit none', &
'      integer :: i', &
'', &
'         i=13741', &
'         write(*,''(b32.32,1x,i0)'')i,i', &
'         write(*,''(b32.32,1x,i0)'')not(i),not(i)', &
'', &
'      end program demo_not', &
'', &
'  Results:', &
'', &
'         00000000000000000011010110101101 13741', &
'         11111111111111111100101001010010 -13742', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  IAND(3), IOR(3), IEOR(3), IBITS(3), IBSET(3),', &
'', &
'  IBCLR(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 not(3fortran)', &
'']

shortname="not"
call process()


case('149','null')

textblock=[character(len=256) :: &
'', &
'null(3fortran)                                                  null(3fortran)', &
'', &
'NAME', &
'  NULL(3) - [TRANSFORMATIONAL] Function that returns a disassociated pointer', &
'', &
'SYNTAX', &
'  ptr => null(mold)', &
'', &
'DESCRIPTION', &
'  Returns a disassociated pointer.', &
'', &
'  If MOLD is present, a disassociated pointer of the same type is returned,', &
'  otherwise the type is determined by context.', &
'', &
'  In Fortran 95, MOLD is optional. Please note that Fortran 2003 includes', &
'  cases where it is required.', &
'', &
'ARGUMENTS', &
'  o  MOLD : (Optional) shall be a pointer of any association status and of any', &
'     type.', &
'', &
'RETURNS', &
'  A disassociated pointer or an unallocated allocatable entity.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      !program demo_null', &
'      module showit', &
'      implicit none', &
'      private', &
'      character(len=*),parameter :: g=''(*(g0,1x))''', &
'      public gen', &
'      ! a generic interface that only differs in the', &
'      ! type of the pointer the second argument is', &
'      interface gen', &
'       module procedure s1', &
'       module procedure s2', &
'      end interface', &
'', &
'      contains', &
'', &
'      subroutine s1 (j, pi)', &
'       integer j', &
'       integer, pointer :: pi', &
'         if(associated(pi))then', &
'            write(*,g)''Two integers in S1:,'',j,''and'',pi', &
'         else', &
'            write(*,g)''One integer in S1:,'',j', &
'         endif', &
'      end subroutine s1', &
'', &
'      subroutine s2 (k, pr)', &
'       integer k', &
'       real, pointer :: pr', &
'         if(associated(pr))then', &
'            write(*,g)''integer and real in S2:,'',k,''and'',pr', &
'         else', &
'            write(*,g)''One integer in S2:,'',k', &
'         endif', &
'      end subroutine s2', &
'', &
'      end module showit', &
'', &
'      use showit, only : gen', &
'', &
'      real,target :: x = 200.0', &
'      integer,target :: i = 100', &
'', &
'      real, pointer :: real_ptr', &
'      integer, pointer :: integer_ptr', &
'', &
'      ! so how do we call S1() or S2() with a disassociated pointer?', &
'', &
'      ! the answer is the null() function with a mold value', &
'', &
'      ! since s1() and s2() both have a first integer', &
'      ! argument the NULL() pointer must be associated', &
'      ! to a real or integer type via the mold option', &
'      ! so the following can distinguish whether s1(1)', &
'      ! or s2() is called, even though the pointers are', &
'      ! not associated or defined', &
'', &
'      call gen (1, null (real_ptr) )    ! invokes s2', &
'      call gen (2, null (integer_ptr) ) ! invokes s1', &
'      real_ptr => x', &
'      integer_ptr => i', &
'      call gen (3, real_ptr ) ! invokes s2', &
'      call gen (4, integer_ptr ) ! invokes s1', &
'', &
'      end', &
'      !end program demo_null', &
'', &
'  Results:', &
'', &
'         One integer in S2:, 1', &
'         One integer in S1:, 2', &
'         integer and real in S2:, 3 and 200.000000', &
'         Two integers in S1:, 4 and 100', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  ASSOCIATED(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                null(3fortran)', &
'']

shortname="null"
call process()


case('150','num_images')

textblock=[character(len=256) :: &
'', &
'num_images(3fortran)                                      num_images(3fortran)', &
'', &
'NAME', &
'  NUM_IMAGES(3) - [COLLECTIVE] Number of images', &
'', &
'SYNTAX', &
'  result = num_images(distance, failed)', &
'', &
'DESCRIPTION', &
'  Returns the number of images.', &
'', &
'ARGUMENTS', &
'  o  DISTANCE : (optional, INTENT(IN)) Nonnegative scalar integer', &
'', &
'  o  FAILED : (optional, INTENT(IN)) Scalar logical expression', &
'', &
'RETURNS', &
'  Scalar default-kind integer. If DISTANCE is not present or has value 0, the', &
'  number of images in the current team is returned. For values smaller or', &
'  equal distance to the initial team, it returns the number of images index on', &
'  the ancestor team which has a distance of DISTANCE from the invoking team.', &
'  If DISTANCE is larger than the distance to the initial team, the number of', &
'  images of the initial team is returned. If FAILED is not present the total', &
'  number of images is returned; if it has the value \.true., the number of', &
'  failed images is returned, otherwise, the number of images which do have not', &
'  the failed status.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_num_images', &
'      implicit none', &
'      integer :: value[*]', &
'      integer :: i', &
'', &
'         value = this_image()', &
'         sync all', &
'         if (this_image() == 1) then', &
'           do i = 1, num_images()', &
'             write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]', &
'           end do', &
'         endif', &
'', &
'      end program demo_num_images', &
'', &
'STANDARD', &
'  Fortran 2008 and later. With DISTANCE or FAILED argument, TS 18508 or later', &
'', &
'SEE ALSO', &
'  THIS_IMAGE(3), IMAGE_INDEX(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          num_images(3fortran)', &
'']

shortname="num_images"
call process()


case('151','out_of_range')

textblock=[character(len=256) :: &
'', &
'out_of_range(3fortran)                                  out_of_range(3fortran)', &
'', &
'NAME', &
'  OUT_OF_RANGE(3) - [TYPE:NUMERIC] Whether a value cannot be converted safely.', &
'', &
'SYNTAX', &
'  result = OUT_OF_RANGE (X, MOLD [, ROUND])', &
'', &
'         logical,elemental               :: out_of_range', &
'         type(TYPE,kind=KIND),intent(in) :: x', &
'         type(TYPE,kind=KIND),intent(in) :: mold', &
'         logical,intent(in),optional     :: round', &
'', &
'         where TYPE may be _real_ or _integer_ of any available KIND.', &
'', &
'DESCRIPTION', &
'  OUT_OF_RANGE(3) determines whether a value X can be converted safely to a', &
'  real or integer variable the same type and kind as MOLD.', &
'', &
'ARGUMENTS', &
'  o  X : a scalar of type integer or real to be tested for whether it can be', &
'     stored in a variable of the type and kind of MOLD', &
'', &
'  o  MOLD : shall be an integer or real scalar. If it is a variable, it need', &
'     not be defined, as only the type and kind are queried.', &
'', &
'  o  ROUND : flag whether to round the value of XX before validating it as an', &
'     integer value like MOLD.', &
'', &
'     ROUND can only be present if X is of type real and MOLD is of type', &
'     integer.', &
'', &
'RETURNS', &
'  From the standard:', &
'', &
'  Case (i): If MOLD is of type integer, and ROUND is absent or present with', &
'  the value false, the result is true if and only if the value of X is an IEEE', &
'  infinity or NaN, or if the integer with largest magnitude that lies between', &
'  zero and X inclusive is not representable by objects with the type and kind', &
'  of MOLD.', &
'', &
'  Case (ii): If MOLD is of type integer, and ROUND is present with the value', &
'  true, the result is true if and only if the value of X is an IEEE infinity', &
'  or NaN, or if the integer nearest X, or the integer of greater magnitude if', &
'  two integers are equally near to X, is not representable by objects with the', &
'  type and kind of MOLD.', &
'', &
'  Case (iii): Otherwise, the result is true if and only if the value of X is', &
'  an IEEE infinity or NaN that is not supported by objects of the type and', &
'  kind of MOLD, or if X is a finite number and the result of rounding the', &
'  value of X (according to the IEEE rounding mode if appropriate) to the', &
'  extended model for the kind of MOLD has magnitude larger than that of the', &
'  largest finite number with the same sign as X that is representable by', &
'  objects with the type and kind of MOLD.', &
'', &
'NOTE', &
'  MOLD is required to be a scalar because the only information taken from it', &
'  is its type and kind. Allowing an array MOLD would require that it be', &
'  conformable with X. ROUND is scalar because allowing an array rounding mode', &
'  would have severe performance difficulties on many processors.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_out_of_range', &
'      use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      integer            :: i', &
'      integer(kind=int8) :: i8, j8', &
'', &
'          ! compilers are not required to produce an error on out of range.', &
'          ! here storing the default integers into 1-byte integers', &
'          ! incorrectly can have unexpected results', &
'          do i=127,130', &
'             i8=i', &
'             j8=-i', &
'             ! OUT_OF_RANGE(3f) can let you check if the value will fit', &
'             write(*,*)i8,j8,'' might have expected'',i,-i, &', &
'              & out_of_range( i,i8), &', &
'              & out_of_range(-i,i8)', &
'          enddo', &
'          write(*,*) ''RANGE IS '',-1-huge(0_int8),''TO'',huge(0_int8)', &
'          ! the real -128.5 is truncated to -128 and is in range', &
'          write(*,*) out_of_range (  -128.5, 0_int8)         ! false', &
'', &
'          ! the real -128.5 is rounded to -129 and is not in range', &
'          write(*,*) out_of_range (  -128.5, 0_int8, .true.) ! true', &
'', &
'      end program demo_out_of_range', &
'', &
'  Results:', &
'', &
'        >  127 -127  might have expected         127        -127 F F', &
'        > -128 -128  might have expected         128        -128 T F', &
'        > -127  127  might have expected         129        -129 T T', &
'        > -126  126  might have expected         130        -130 T T', &
'        > RANGE IS         -128 TO  127', &
'        > F', &
'        > T', &
'', &
'STANDARD', &
'  FORTRAN 2018 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022        out_of_range(3fortran)', &
'']

shortname="out_of_range"
call process()


case('152','pack')

textblock=[character(len=256) :: &
'', &
'pack(3fortran)                                                  pack(3fortran)', &
'', &
'NAME', &
'  PACK(3) - [ARRAY CONSTRUCTION] Pack an array into an array of rank one', &
'', &
'SYNTAX', &
'  result = pack(array, mask,vector)', &
'', &
'         TYPE(kind=KIND) function pack(array,mask,vector)', &
'         TYPE(kind=KIND),option(in) :: array(*)', &
'         logical  :: mask(*)', &
'         TYPE(kind=KIND),option(in),optional :: vector(*)', &
'', &
'  where TYPE(kind=KIND) may be any type, where ARRAY and VECTOR and the', &
'  returned value must by of the same type. MASK may be a scalar as well an an', &
'  array.', &
'', &
'DESCRIPTION', &
'  Stores the elements of ARRAY in an array of rank one.', &
'', &
'  The beginning of the resulting array is made up of elements whose MASK', &
'  equals .true.. Afterwards, positions are filled with elements taken from', &
'  VECTOR.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of any type.', &
'', &
'  o  MASK : Shall be an array of type logical and of the same size as ARRAY.', &
'     Alternatively, it may be a logical scalar.', &
'', &
'  o  VECTOR : (Optional) shall be an array of the same type as ARRAY and of', &
'     rank one. If present, the number of elements in VECTOR shall be equal to', &
'     or greater than the number of true elements in MASK. If MASK is scalar,', &
'     the number of elements in VECTOR shall be equal to or greater than the', &
'     number of elements in ARRAY.', &
'', &
'RETURNS', &
'  The result is an array of rank one and the same type as that of ARRAY.  If', &
'  VECTOR is present, the result size is that of VECTOR, the number of \.true.', &
'  values in MASK otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_pack', &
'      implicit none', &
'         call test1()', &
'         call test2()', &
'         call test3()', &
'      contains', &
'      !', &
'      subroutine test1()', &
'      ! gathering nonzero elements from an array:', &
'      integer :: m(6)', &
'', &
'         m = [ 1, 0, 0, 0, 5, 0 ]', &
'         write(*, fmt="(*(i0, '' ''))") pack(m, m /= 0)  ! "1 5"', &
'', &
'      end subroutine test1', &
'      !', &
'      subroutine test2()', &
'      ! Gathering nonzero elements from an array and appending elements', &
'      ! from VECTOR till the size of the mask array (or array size if the', &
'      ! mask is scalar):', &
'      integer :: m(4)', &
'', &
'         m = [ 1, 0, 0, 2 ]', &
'         write(*, fmt="(*(i0, '' ''))") pack(m, m /= 0, [ 0, 0, 3, 4 ])', &
'', &
'      end subroutine test2', &
'      !', &
'      subroutine test3()', &
'      ! select strings whose second character is "a"', &
'      character(len=10) :: m(4)', &
'', &
'      m = [ character(len=10) :: ''ape'', ''bat'', ''cat'', ''dog'']', &
'         write(*, fmt="(*(g0, '' ''))") pack(m, m(:)(2:2) == ''a'' )', &
'', &
'      end subroutine test3', &
'      !', &
'      end program demo_pack', &
'', &
'  Results:', &
'', &
'    1 5 1 2 3 4', &
'', &
'    bat', &
'      cat', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  UNPACK(3), MERGE(3), PACK(3), SPREAD(3), UNPACK(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                pack(3fortran)', &
'']

shortname="pack"
call process()


case('153','parity')

textblock=[character(len=256) :: &
'', &
'parity(3fortran)                                              parity(3fortran)', &
'', &
'NAME', &
'  PARITY(3) - [TRANSFORMATIONAL] Reduction with exclusive OR()', &
'', &
'SYNTAX', &
'  result = parity(mask, dim)', &
'', &
'          function parity(mask, dim)', &
'          type(logical(kind=LKIND))                    :: dim', &
'          type(logical(kind=LKIND)),intent(in)         :: mask(..)', &
'          type(integer(kind=KIND)),intent(in),optional :: dim', &
'', &
'  where KIND and LKIND are any supported kind for the type.', &
'', &
'DESCRIPTION', &
'  Calculates the parity (i.e. the reduction using .xor.) of MASK along', &
'  dimension DIM.', &
'', &
'ARGUMENTS', &
'  o  MASK : Shall be an array of type logical.', &
'', &
'  o  DIM : (Optional) shall be a scalar of type integer with a value in the', &
'     range from 1 TO N, where N equals the rank of MASK.', &
'', &
'RETURNS', &
'  The result is of the same type as MASK.', &
'', &
'  If DIM is absent, a scalar with the parity of all elements in MASK is', &
'  returned: .TRUE. if an odd number of elements are .TRUE. and .FALSE.', &
'  otherwise.', &
'', &
'  When DIM is specified the returned shape is similar to that of MASK with', &
'  dimension DIM dropped.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_parity', &
'      implicit none', &
'      logical :: x(2) = [ .true., .false. ]', &
'         print *, parity(x)', &
'      end program demo_parity', &
'', &
'  Results:', &
'', &
'   T', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              parity(3fortran)', &
'']

shortname="parity"
call process()


case('154','popcnt')

textblock=[character(len=256) :: &
'', &
'popcnt(3fortran)                                              popcnt(3fortran)', &
'', &
'NAME', &
'  POPCNT(3) - [BIT:COUNT] Number of bits set', &
'', &
'SYNTAX', &
'  result = popcnt(i)', &
'', &
'DESCRIPTION', &
'  Returns the number of bits set in the binary representation of an integer.', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer.', &
'', &
'RETURNS', &
'  The return value is of type integer and of the default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_popcnt', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'         & int8, int16, int32, int64', &
'      implicit none', &
'           print *, popcnt(127),       poppar(127)', &
'           print *, popcnt(huge(0)), poppar(huge(0))', &
'           print *, popcnt(huge(0_int8)), poppar(huge(0_int8))', &
'           print *, popcnt(huge(0_int16)), poppar(huge(0_int16))', &
'           print *, popcnt(huge(0_int32)), poppar(huge(0_int32))', &
'           print *, popcnt(huge(0_int64)), poppar(huge(0_int64))', &
'      end program demo_popcnt', &
'', &
'  Results:', &
'', &
'    7', &
'', &
'  31', &
'', &
'    7', &
'', &
'  15', &
'', &
'    31', &
'', &
'    63', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  POPPAR(3), LEADZ(3), TRAILZ(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              popcnt(3fortran)', &
'']

shortname="popcnt"
call process()


case('155','poppar')

textblock=[character(len=256) :: &
'', &
'poppar(3fortran)                                              poppar(3fortran)', &
'', &
'NAME', &
'  POPPAR(3) - [BIT:COUNT] Parity of the number of bits set', &
'', &
'SYNTAX', &
'  result = poppar(i)', &
'', &
'DESCRIPTION', &
'  Returns the parity of an integer''s binary representation (i.e., the parity', &
'  of the number of bits set).', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer.', &
'', &
'RETURNS', &
'  The return value is equal to 0 if I has an even number of bits set and 1 if', &
'  an odd number of bits are set.', &
'', &
'  It is of type integer and of the default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_popcnt', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'         & int8, int16, int32, int64', &
'      implicit none', &
'         print  *,  popcnt(127),            poppar(127)', &
'         print  *,  popcnt(huge(0_int8)),   poppar(huge(0_int8))', &
'         print  *,  popcnt(huge(0_int16)),  poppar(huge(0_int16))', &
'         print  *,  popcnt(huge(0_int32)),  poppar(huge(0_int32))', &
'         print  *,  popcnt(huge(0_int64)),  poppar(huge(0_int64))', &
'      end program demo_popcnt', &
'', &
'  Results:', &
'', &
'    7', &
'', &
'    7', &
'', &
'  15', &
'', &
'    31', &
'', &
'    63', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  POPCNT(3), LEADZ(3), TRAILZ(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              poppar(3fortran)', &
'']

shortname="poppar"
call process()


case('156','precision')

textblock=[character(len=256) :: &
'', &
'precision(3fortran)                                        precision(3fortran)', &
'', &
'NAME', &
'  PRECISION(3) - [NUMERIC MODEL] Decimal precision of a real kind', &
'', &
'SYNTAX', &
'  result = precision(x)', &
'', &
'DESCRIPTION', &
'  PRECISION(X) returns the decimal precision in the model of the type of X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real or complex.', &
'', &
'RETURNS', &
'  The return value is of type integer and of the default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_precision', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp) :: x(2)', &
'      complex(kind=dp) :: y', &
'', &
'         print *, precision(x), range(x)', &
'         print *, precision(y), range(y)', &
'      end program demo_precision', &
'', &
'  Results:', &
'', &
'    6 37', &
'', &
'  15', &
'    307', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           precision(3fortran)', &
'']

shortname="precision"
call process()


case('157','present')

textblock=[character(len=256) :: &
'', &
'present(3fortran)                                            present(3fortran)', &
'', &
'NAME', &
'  PRESENT(3) - [STATE] Determine whether an optional dummy argument is', &
'  specified', &
'', &
'SYNTAX', &
'  result = present(a)', &
'', &
'         function present (a)', &
'         logical :: present', &
'', &
'DESCRIPTION', &
'  Determines whether an optional dummy argument is present.', &
'', &
'ARGUMENTS', &
'  o  A : May be of any type and may be a pointer, scalar or array value, or a', &
'     dummy procedure. It shall be the name of an optional dummy argument', &
'     accessible within the current subroutine or function.', &
'', &
'RETURNS', &
'  Returns either .true. if the optional argument A is present, or .false.', &
'  otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_present', &
'      implicit none', &
'         write(*,*) func(), func(42)', &
'      contains', &
'', &
'      integer function func(x)', &
'      integer, intent(in), optional :: x', &
'         if(present(x))then', &
'           func=x**2', &
'         else', &
'           func=0', &
'         endif', &
'      end function', &
'', &
'      end program demo_present', &
'', &
'  Results:', &
'', &
'    0 1764', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             present(3fortran)', &
'']

shortname="present"
call process()


case('158','product')

textblock=[character(len=256) :: &
'', &
'product(3fortran)                                            product(3fortran)', &
'', &
'NAME', &
'  PRODUCT(3) - [ARRAY REDUCTION] Product of array elements', &
'', &
'SYNTAX', &
'  result = product(array, dim, mask)', &
'', &
'          NUMERIC,intent(in) :: array(..)', &
'          integer,intent(in),optional :: dim', &
'          logical,intent(in),optional :: mask(..)', &
'', &
'  where NUMERIC is any numeric type', &
'', &
'DESCRIPTION', &
'  Multiplies together all the selected elements of ARRAY, or along dimension', &
'  DIM if the corresponding element in MASK is .true..', &
'', &
'  If DIM is absent, a scalar with the product of all elements in ARRAY is', &
'  returned. (Note a zero-sized ARRAY returns 1).', &
'', &
'  When DIM is present, If the masked array has a dimension of one (ie. is a', &
'  vector) the result is a scalar. Otherwise, an array of rank N-1, where N', &
'  equals the rank of ARRAY, and a shape similar to that of ARRAY with', &
'  dimension DIM dropped is returned.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer, real or complex.', &
'', &
'  o  DIM : shall be a scalar of type integer with a value in the range from 1', &
'     TO N, where N equals the rank of ARRAY.', &
'', &
'  o  MASK : shall be of type logical and either be a scalar or an array of the', &
'     same shape as ARRAY.', &
'', &
'RETURNS', &
'  The result is of the same type as ARRAY.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_product', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))'' ! a handy format', &
'      character(len=1),parameter :: nl=new_line(''a'')', &
'', &
'      NO_DIM: block', &
'      !    If DIM is not specified, the result is the product of all the', &
'      !    selected array elements.', &
'      integer :: i,n, p1, p2', &
'      integer,allocatable :: array(:)', &
'         ! all elements are selected by default', &
'         do n=1,10', &
'            print all, ''factorial of '',n,'' is '', product([(real(i),i=1,n)])', &
'         enddo', &
'', &
'         ! using a mask', &
'         array=[10,12,13,15,20,25,30]', &
'         p1=product(array, mask=mod(array, 2)==1) ! only odd elements', &
'         p2=product(array, mask=mod(array, 2)/=1) ! only even elements', &
'         print all, nl,''product of all elements'',product(array) ! all elements', &
'         print all, '' odd * even ='',nl,p1,''*'',p2,''='',p1*p2', &
'', &
'         ! NOTE: If ARRAY is a zero-sized array, the result is equal to one', &
'         print all', &
'         print all, ''zero-sized array=>'',product([integer :: ])', &
'         ! NOTE: If nothing in the mask is true, this also results in a null', &
'         !       array', &
'         print all, ''all elements have a false mask=>'', &', &
'                  & product(array,mask=.false.)', &
'', &
'      endblock NO_DIM', &
'', &
'      WITH_DIM: block', &
'      integer :: rect(2,3)', &
'      integer :: box(2,3,4)', &
'', &
'      !  lets fill a few arrays', &
'         rect = reshape([ &', &
'           1, 2, 3,       &', &
'           4, 5, 6        &', &
'         ],shape(rect),order=[2,1])', &
'         call print_matrix_int(''rect'',rect)', &
'', &
'      !  Find the product of each column in RECT.', &
'         print all, ''product of columns='',product(rect, dim = 1)', &
'', &
'      ! Find the product of each row in RECT.', &
'         print all, ''product of rows='',product(rect, dim = 2)', &
'', &
'      ! now lets try a box', &
'         box(:,:,1)=rect', &
'         box(:,:,2)=rect*(+10)', &
'         box(:,:,3)=rect*(-10)', &
'         box(:,:,4)=rect*2', &
'         ! lets look at the values', &
'         call print_matrix_int(''box 1'',box(:,:,1))', &
'         call print_matrix_int(''box 2'',box(:,:,2))', &
'         call print_matrix_int(''box 3'',box(:,:,3))', &
'         call print_matrix_int(''box 4'',box(:,:,4))', &
'', &
'         ! remember without dim= even a box produces a scalar', &
'         print all, ''no dim gives a scalar'',product(real(box))', &
'', &
'         ! only one plane has negative values, so note all the "1" values', &
'         ! for vectors with no elements', &
'         call print_matrix_int(''negative values'', &', &
'         & product(box,mask=box < 0,dim=1))', &
'', &
'      !   If DIM is specified and ARRAY has rank greater than one, the', &
'      !   result is a new array in which dimension DIM has been eliminated.', &
'', &
'         ! pick a dimension to multiply though', &
'         call print_matrix_int(''dim=1'',product(box,dim=1))', &
'', &
'         call print_matrix_int(''dim=2'',product(box,dim=2))', &
'', &
'         call print_matrix_int(''dim=3'',product(box,dim=3))', &
'', &
'      endblock WITH_DIM', &
'', &
'      contains', &
'', &
'         subroutine print_matrix_int(title,arr)', &
'         implicit none', &
'', &
'         !@(#) print small 2d integer arrays in row-column format', &
'', &
'         character(len=*),intent(in)  :: title', &
'         integer,intent(in)           :: arr(:,:)', &
'         integer                      :: i', &
'         character(len=:),allocatable :: biggest', &
'', &
'            print all', &
'            print all, trim(title),'':('',shape(arr),'')''  ! print title', &
'            biggest=''           ''  ! make buffer to write integer into', &
'            ! find how many characters to use for integers', &
'            write(biggest,''(i0)'')ceiling(log10(real(maxval(abs(arr)))))+2', &
'            ! use this format to write a row', &
'            biggest=''(" > [",*(i''//trim(biggest)//'':,","))''', &
'            ! print one row of array at a time', &
'            do i=1,size(arr,dim=1)', &
'               write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'               write(*,''(" ]")'')', &
'            enddo', &
'', &
'         end subroutine print_matrix_int', &
'', &
'      end program demo_product', &
'', &
'  Results:', &
'', &
'      factorial of  1  is  1.000000', &
'      factorial of  2  is  2.000000', &
'      factorial of  3  is  6.000000', &
'      factorial of  4  is  24.00000', &
'      factorial of  5  is  120.0000', &
'      factorial of  6  is  720.0000', &
'      factorial of  7  is  5040.000', &
'      factorial of  8  is  40320.00', &
'      factorial of  9  is  362880.0', &
'      factorial of  10  is  3628800.', &
'', &
'       product of all elements 351000000', &
'       odd * even =', &
'       4875 * 72000 = 351000000', &
'', &
'      zero-sized array=> 1', &
'      all elements have a false mask=> 1', &
'', &
'      rect :( 2 3 )', &
'       > [  1,  2,  3 ]', &
'       > [  4,  5,  6 ]', &
'      product of columns= 4 10 18', &
'      product of rows= 6 120', &
'', &
'      box 1 :( 2 3 )', &
'       > [  1,  2,  3 ]', &
'       > [  4,  5,  6 ]', &
'', &
'      box 2 :( 2 3 )', &
'       > [  10,  20,  30 ]', &
'       > [  40,  50,  60 ]', &
'', &
'      box 3 :( 2 3 )', &
'       > [ -10, -20, -30 ]', &
'       > [ -40, -50, -60 ]', &
'', &
'      box 4 :( 2 3 )', &
'       > [   2,   4,   6 ]', &
'       > [   8,  10,  12 ]', &
'      no dim gives a scalar .1719927E+26', &
'', &
'      negative values :( 3 4 )', &
'       > [     1,     1,   400,     1 ]', &
'       > [     1,     1,  1000,     1 ]', &
'       > [     1,     1,  1800,     1 ]', &
'', &
'      dim=1 :( 3 4 )', &
'       > [     4,   400,   400,    16 ]', &
'       > [    10,  1000,  1000,    40 ]', &
'       > [    18,  1800,  1800,    72 ]', &
'', &
'      dim=2 :( 2 4 )', &
'       > [       6,    6000,   -6000,      48 ]', &
'       > [     120,  120000, -120000,     960 ]', &
'', &
'      dim=3 :( 2 3 )', &
'       > [    -200,   -3200,  -16200 ]', &
'       > [  -51200, -125000, -259200 ]', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  SUM(3), note that an element by element multiplication is done directly', &
'  using the star character.', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022             product(3fortran)', &
'']

shortname="product"
call process()


case('159','radix')

textblock=[character(len=256) :: &
'', &
'radix(3fortran)                                                radix(3fortran)', &
'', &
'NAME', &
'  RADIX(3) - [NUMERIC MODEL] Base of a model number', &
'', &
'SYNTAX', &
'  result = radix(x)', &
'', &
'DESCRIPTION', &
'  RADIX(X) returns the base of the model representing the entity X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type integer or real', &
'', &
'RETURNS', &
'  The return value is a scalar of type integer and of the default integer', &
'  kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_radix', &
'      implicit none', &
'         print *, "The radix for the default integer kind is", radix(0)', &
'         print *, "The radix for the default real kind is", radix(0.0)', &
'         print *, "The radix for the doubleprecision real kind is", radix(0.0d0)', &
'      end program demo_radix', &
'', &
'  Results:', &
'', &
'          The radix for the default integer kind is           2', &
'          The radix for the default real kind is           2', &
'          The radix for the doubleprecision real kind is          2', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               radix(3fortran)', &
'']

shortname="radix"
call process()


case('160','random_init')

textblock=[character(len=256) :: &
'', &
'random_init(3fortran)                                    random_init(3fortran)', &
'', &
'              RANDOM_INIT(3) - [MATHEMATICS:RANDOM] control multi-image', &
'              pseudorandom number generator initialization.', &
'', &
'SYNTAX', &
'  call random_init (repeatable, image_distinct)', &
'', &
'           subroutine random_init(repeatable, image_distinct)', &
'           logical,intent(in) :: repeatable', &
'           logical,intent(in) :: image_distinct', &
'', &
'DESCRIPTION', &
'  Pseudorandom generators produce a deterministic sequence of numbers that', &
'  pass statistical tests that show they appear sufficiently random to be', &
'  treated as such. So they are numbers that are generated by a repeatable', &
'  computation that appear random if you do know what algorithm is being used.', &
'', &
'  To get different sets of random numbers you give them a different starting', &
'  point called a "seed"; which is often an array of whole numbers.', &
'', &
'  External values (often time-related) are frequently used to automatically', &
'  generate different seed values so you can get different sequences of random', &
'  values without manually generating a seed each time you want a different set', &
'  of values.', &
'', &
'  The standard Fortran procedures do not specify a specific generator', &
'  algorithm. If you require a generator that produces the same values or a', &
'  specific quality independent of the compiler or platform being used you will', &
'  want to use your own generator or review the specific generators used by', &
'  your compiler. There are many packages available for such situations.', &
'', &
'  But the standard procedures available are sufficient for many use cases.', &
'  They consist of RANDOM_NUMBER(3F), RANDOM_SEED(3F), and RANDOM_INIT(3F).', &
'', &
'  RANDOM_NUMBER(3F) calls a generator and returns a psuedorandom scalar or', &
'  array. This simple-to-use function does not directly define how to seed or', &
'  initialize the generator, however. So if you do not call one of the other', &
'  two initializer procedures it is implementation dependent as to whether the', &
'  initial seed is always the same or changes with each program start, or', &
'  whether all images in a parallel program start with the same seed or unique', &
'  seeds for each image, for instance.', &
'', &
'  So you need to either set the seed with RANDOM_SEED(3) yourself and', &
'  optionally the behavior when running in parallel with coarrays with', &
'  **random_init(3f) if you do not want to just depend on your particular', &
'  compiler behavior.', &
'', &
'  RANDOM_INIT(3F) Initializes the state of the pseudorandom number generator', &
'  procedure RANDOM_NUMBER(3F). RANDOM_INIT(3f) is equivalent to invoking', &
'  RANDOM_SEED(3F) with no parameters but considers parallel images and', &
'  otherwise processor-dependent behaviors as well.', &
'', &
'  Not every compiler vendor gives a unique seed for random_seed(), for', &
'  example.', &
'', &
'  The initial behavior of the pseudorandom number generator random_number()', &
'  procedure is processor-dependent if not initialized.  Even if initialized', &
'  with RANDOM_SEED() if a specific seed array is not specified behavior is', &
'  still processor-dependent for multiple image codes unless specific modes are', &
'  selected with RANDOM_INIT().', &
'', &
'  There are four combinations of REPEATABLE and IMAGE_DISTINCT. The behavior', &
'  is as follows:', &
'', &
'  Case (i) : REPEATABLE=.true.,IMAGE_DISTINCT=.true.', &
'', &
'  PUT different on every invoking image. In each execution of the program with', &
'  the same execution environment, if the invoking image index value in the', &
'  initial team is the same, the value for PUT shall be the same.', &
'', &
'  PROGRAM main REAL,DIMENSION(1000) :: y CALL RANDOM_INIT (REPEATABLE=.TRUE.,', &
'  IMAGE_DISTINCT=.TRUE.) CALL RANDOM_NUMBER (y) . . .', &
'', &
'END', &
'  After executing the above code, the array y contains a different sequence of', &
'  pseudorandom numbers on each image that executes the code.  If the program', &
'  is executed multiple times, for an image that has the same image index in', &
'  the initial team, the value of y is the same each time the program is run.', &
'', &
'  Consider the following:', &
'', &
'  CALL RANDOM_INIT(.TRUE., .TRUE.)', &
'', &
'  The sequence of random numbers is repeatable. If the program is compiled', &
'  with -fcoarray=lib and multiple images are instantiated, then each image', &
'  accesses a repeatable distinct sequence of random numbers. Technically, the', &
'  Standard states that a distinct seed is used in each image (with the tacit', &
'  assumption that the sequences are distinct, but this is not guaranteed).', &
'  Also, the repeatability is guaranteed for the currently executing image.', &
'  Rerunning the executable does not require the same distinct seeds, but I', &
'  have chose to use the same seeds.', &
'', &
'  Case (ii) : REPEATABLE=.true.,IMAGE_DISTINCT=.false.', &
'', &
'  PUT is the same on every invoking image. In each execution of the program', &
'  with the same execution environment, the value for PUT shall be the same.', &
'', &
'  Case (iii) : REPEATABLE=.false., IMAGE_DISTINCT=.true.', &
'', &
'  PUT is different on every invoking image. Different values for PUT shall be', &
'  used for subsequent invocations, and for each execution of the program.', &
'', &
'  Case (iv) : REPEATABLE=.false.,IMAGE_DISTINCT=.false.', &
'', &
'  PUT that is the same on every invoking image. Different values for PUT shall', &
'  be used for subsequent invocations, and for each execution of the program.', &
'', &
'  the array y contains the same sequence of pseudorandom numbers on each image', &
'  that executes the code. If the program is executed multiple times, the value', &
'  of y is different each time the program is run.', &
'', &
'  Consider another example:', &
'', &
'  PROGRAM main REAL,DIMENSION(1000) :: y CALL RANDOM_INIT (REPEATABLE=.FALSE.,', &
'  IMAGE_DISTINCT=.FALSE.) CALL RANDOM_NUMBER (y) . .  \. END', &
'', &
'  The pseudorandom number generator used by RANDOM_NUMBER maintains a seed on', &
'  each image that is updated during the execution of RANDOM_NUMBER and that', &
'  can be retrieved or changed by RANDOM_INIT or RANDOM_SEED .  Computation of', &
'  the seed from the argument PUT is performed in a processor-dependent manner.', &
'  The value assigned to GET need not be the same as the value of PUT in an', &
'  immediately preceding reference to RANDOM_SEED. For example, following', &
'  execution of the statements', &
'', &
'  In each of these cases, a different processor-dependent value for PUT shall', &
'  result in a different sequence of pseudorandom numbers.', &
'', &
'ARGUMENTS', &
'  o  **repeatable : If .true., the seed is set to a processor-dependent value', &
'     that is the same each time RANDOM_INIT(3F) is called from the same', &
'     program execution (or the same image???).', &
'', &
'     The sequence of random numbers is different for repeated execution of the', &
'     program.', &
'', &
'     If it is .false., the seed is set to a processor-dependent value.', &
'', &
'     : when .true. init the seed used by RANDOM_NUMBER differently on every', &
'     invoking image.', &
'', &
'     If it is .true., the seed is set to a processor-dependent value that is', &
'     the same each time random_init is called from the same image.', &
'', &
'  o  IMAGE_DISTINCT', &
'', &
'      image_distinct : If .true., the seed is set to a processor-dependent', &
'      value that is distinct from the seed set by a call to random_init in', &
'      another image.', &
'', &
'      If it is .false., the seed is set to a value that does depend which', &
'      image called random_init.', &
'', &
'      IMAGE_DISTINCT is clearly meant for a program that uses co-arrays', &
'      where upon execution multiple images are instantiated. If a program', &
'      does not use co-arrays or only a single image is instantiated, then', &
'      IMAGE_DISTINCT is irrelevant.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_random_init', &
'         ! random_number(3f) on this invoking image will generate a sequence', &
'         ! that differs form other images that invoke a similar statement, as', &
'         ! well as being different on subsequent program execution.', &
'         call random_init (repeatable=.false., image_distinct=.true.)', &
'', &
'      end program demo_random_init', &
'      Example', &
'', &
'      program test_random_seed', &
'      implicit none', &
'      real x(3), y(3)', &
'         call random_init   (repeatable=.true., image_distinct=.true.)', &
'         call random_number (x)', &
'         call random_init   (repeatable=.true., image_distinct=.true.)', &
'         call random_number (y)', &
'         ! x and y are the same sequence', &
'         if (any(x /= y)) stop "x(:) and y(:) not all equal"', &
'      end program test_random_seed', &
'', &
'  Results:', &
'', &
'STANDARD', &
'  Fortran 2018 and later', &
'', &
'SEE ALSO', &
'  *_random_seed**(3), *_random_init**(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022         random_init(3fortran)', &
'']

shortname="random_init"
call process()


case('161','random_number')

textblock=[character(len=256) :: &
'', &
'random_number(3fortran)                                random_number(3fortran)', &
'', &
'NAME', &
'  RANDOM_NUMBER(3) - [MATHEMATICS:RANDOM] Pseudo-random number', &
'', &
'SYNTAX', &
'  random_number(harvest)', &
'', &
'DESCRIPTION', &
'  Returns a single pseudorandom number or an array of pseudorandom numbers', &
'  from the uniform distribution over the range 0 <= x < 1.', &
'', &
'ARGUMENTS', &
'  o  HARVEST : Shall be a scalar or an array of type real.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_random_number', &
'      use, intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      integer, allocatable :: seed(:)', &
'      integer              :: n', &
'      integer              :: first,last', &
'      integer              :: i', &
'      integer              :: rand_int', &
'      integer,allocatable  :: count(:)', &
'      real(kind=dp)        :: rand_val', &
'         call random_seed(size = n)', &
'         allocate(seed(n))', &
'         call random_seed(get=seed)', &
'         first=1', &
'         last=10', &
'         allocate(count(last-first+1))', &
'         ! To have a discrete uniform distribution on the integers', &
'         ! [first, first+1, ..., last-1, last] carve the continuous', &
'         ! distribution up into last+1-first equal sized chunks,', &
'         ! mapping each chunk to an integer.', &
'         !', &
'         ! One way is:', &
'         !   call random_number(rand_val)', &
'         ! choose one from last-first+1 integers', &
'         !   rand_int = first + FLOOR((last+1-first)*rand_val)', &
'            count=0', &
'            ! generate a lot of random integers from 1 to 10 and count them.', &
'            ! with a large number of values you should get about the same', &
'            ! number of each value', &
'            do i=1,100000000', &
'               call random_number(rand_val)', &
'               rand_int=first+floor((last+1-first)*rand_val)', &
'               if(rand_int.ge.first.and.rand_int.le.last)then', &
'                  count(rand_int)=count(rand_int)+1', &
'               else', &
'                  write(*,*)rand_int,'' is out of range''', &
'               endif', &
'            enddo', &
'            write(*,''(i0,1x,i0)'')(i,count(i),i=1,size(count))', &
'      end program demo_random_number', &
'', &
'  Results:', &
'', &
'    1 10003588 2 10000104 3 10000169 4 9997996 5 9995349 6 10001304 7 10001909', &
'    8 9999133 9 10000252 10 10000196', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  RANDOM_SEED(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022       random_number(3fortran)', &
'']

shortname="random_number"
call process()


case('162','random_seed')

textblock=[character(len=256) :: &
'', &
'random_seed(3fortran)                                    random_seed(3fortran)', &
'', &
'NAME', &
'  RANDOM_SEED(3) - [MATHEMATICS:RANDOM] Initialize a pseudo-random number', &
'  sequence', &
'', &
'SYNTAX', &
'  call random_seed(size, put, get)', &
'', &
'DESCRIPTION', &
'  Restarts or queries the state of the pseudorandom number generator used by', &
'  random_number.', &
'', &
'  If random_seed is called without arguments, it is seeded with random data', &
'  retrieved from the operating system.', &
'', &
'ARGUMENTS', &
'  o  SIZE : (Optional) Shall be a scalar and of type default integer, with', &
'     INTENT(OUT). It specifies the minimum size of the arrays used with the', &
'     PUT and GET arguments.', &
'', &
'  o  PUT : (Optional) Shall be an array of type default integer and rank one.', &
'     It is INTENT(IN) and the size of the array must be larger than or equal', &
'     to the number returned by the SIZE argument.', &
'', &
'  o  GET : (Optional) Shall be an array of type default integer and rank one.', &
'     It is INTENT(OUT) and the size of the array must be larger than or equal', &
'     to the number returned by the SIZE argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_random_seed', &
'      implicit none', &
'      integer, allocatable :: seed(:)', &
'      integer :: n', &
'', &
'         call random_seed(size = n)', &
'         allocate(seed(n))', &
'         call random_seed(get=seed)', &
'         write (*, *) seed', &
'', &
'      end program demo_random_seed', &
'', &
'  Results:', &
'', &
'           -674862499 -1750483360  -183136071  -317862567   682500039', &
'           349459   344020729 -1725483289', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  RANDOM_NUMBER(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022         random_seed(3fortran)', &
'']

shortname="random_seed"
call process()


case('163','range')

textblock=[character(len=256) :: &
'', &
'range(3fortran)                                                range(3fortran)', &
'', &
'NAME', &
'  RANGE(3) - [NUMERIC MODEL] Decimal exponent range of a real kind', &
'', &
'SYNTAX', &
'  result = range(x)', &
'', &
'            function range (x)', &
'            integer :: range', &
'            type(TYPE,kind=KIND),intent(in) :: x', &
'', &
'  where TYPE is real or complex and KIND is any kind supported by TYPE.', &
'', &
'DESCRIPTION', &
'  RANGE(X) returns the decimal exponent range in the model of the type of X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real or complex.', &
'', &
'RETURNS', &
'  The return value is of type integer and of the default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_range', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp)    :: x(2)', &
'      complex(kind=dp) :: y', &
'         print *, precision(x), range(x)', &
'         print *, precision(y), range(y)', &
'      end program demo_range', &
'', &
'  Results:', &
'', &
'    6 37', &
'', &
'  15', &
'    307', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               range(3fortran)', &
'']

shortname="range"
call process()


case('164','rank')

textblock=[character(len=256) :: &
'', &
'rank(3fortran)                                                  rank(3fortran)', &
'', &
'NAME', &
'  RANK(3) - [ARRAY INQUIRY] Rank of a data object', &
'', &
'SYNTAX', &
'  result = rank(a)', &
'', &
'DESCRIPTION', &
'  RANK(A) returns the rank of a scalar or array data object.', &
'', &
'ARGUMENTS', &
'  o  A : can be of any type', &
'', &
'RETURNS', &
'  The return value is of type integer and of the default integer kind. For', &
'  arrays, their rank is returned; for scalars zero is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_rank', &
'      implicit none', &
'      integer :: a', &
'      real, allocatable :: b(:,:)', &
'      real  :: c(10,20,30)', &
'         print *, rank(a), rank(b), rank(c)', &
'      end program demo_rank', &
'', &
'  Results:', &
'', &
'    0 2           3', &
'', &
'STANDARD', &
'  TS 29113', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                rank(3fortran)', &
'']

shortname="rank"
call process()


case('165','real')

textblock=[character(len=256) :: &
'', &
'real(3fortran)                                                  real(3fortran)', &
'', &
'NAME', &
'  REAL(3) - [TYPE:NUMERIC] Convert to real type', &
'', &
'SYNTAX', &
'  result = real(x, kind)', &
'', &
'DESCRIPTION', &
'  REAL(X, KIND) converts its argument X to a real type.', &
'', &
'  For complex values this is similar to the modern complex-part-designator %RE', &
'  which also designates the real part of a value, accept a designator can', &
'  appear on the left-hand side of an assignment as well, as in', &
'  VAL%RE=(3.0,4.0).', &
'', &
'ARGUMENTS', &
'  o  X : Shall be integer, real, or complex to convert to real.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  These functions return a real variable or array under the following rules:', &
'', &
'  1.  REAL(x) is converted to a default real type if X is an integer or real', &
'      variable.', &
'', &
'  2.  REAL(x) is converted to a real type with the magnitude of the real', &
'      component of a complex value with kind type parameter of X.', &
'', &
'  3.  REAL(X, KIND) is converted to a real type with kind type parameter KIND', &
'      if X is a complex, integer, or real variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_real', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      complex              :: zr = (1.0, 2.0)', &
'      doubleprecision      :: xd=huge(3.0d0)', &
'      complex(kind=dp) :: zd=cmplx(4.0e0_dp,5.0e0_dp,kind=dp)', &
'', &
'         print *, real(zr), aimag(zr)', &
'         print *, dble(zd), aimag(zd)', &
'', &
'         write(*,*)xd,real(xd,kind=kind(0.0d0)),dble(xd)', &
'      end program demo_real', &
'', &
'  Results:', &
'', &
'       1.00000000       2.00000000', &
'       4.0000000000000000       5.0000000000000000', &
'       1.7976931348623157E+308  1.7976931348623157E+308  1.7976931348623157E+308', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  DBLE(3), CMPLX(3), AIMAG(3), INT(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                real(3fortran)', &
'']

shortname="real"
call process()


case('166','reduce')

textblock=[character(len=256) :: &
'', &
'reduce(3fortran)                                              reduce(3fortran)', &
'', &
'NAME', &
'  REDUCE(3) - [TRANSFORMATIONAL] general reduction of an array', &
'', &
'SYNTAX', &
'  There are two forms to this function:', &
'', &
'         reduce(array, operation, mask, identity, ordered)', &
'         reduce(array, operation, dim, mask, identity, ordered)', &
'', &
'            type(TYPE),intent(in)          :: array', &
'            pure function                  :: operation', &
'            integer,intent(in),optional    :: dim', &
'            logical,optional               :: mask', &
'            type(TYPE),intent(in),optional :: identity', &
'            logical,intent(in),optional    :: ordered', &
'', &
'  where TYPE may be of any type. TYPE must be the same for ARRAY and IDENTITY.', &
'', &
'DESCRIPTION', &
'  Reduce a list of conditionally selected values from an array to a single', &
'  value by iteratively applying a binary function.', &
'', &
'  Common in functional programming, a REDUCE function applies a binary', &
'  operator (a pure function with two arguments) to all elements cumulatively.', &
'', &
'  REDUCE is a "higher-order" function; ie. it is a function that receives', &
'  other functions as arguments.', &
'', &
'  The REDUCE function receives a binary operator (a function with two', &
'  arguments, just like the basic arithmetic operators). It is first applied to', &
'  two unused values in the list to generate an accumulator value which is', &
'  subsequently used as the first argument to the function as the function is', &
'  recursively applied to all the remaining selected values in the input array.', &
'', &
'OPTIONS', &
'  o  ARRAY : An array of any type and allowed rank to select values from.', &
'', &
'  o  OPERATION : shall be a pure function with exactly two arguments; each', &
'     argument shall be a scalar, nonallocatable, nonpointer, nonpolymorphic,', &
'     nonoptional dummy data object with the same type and type parameters as', &
'     ARRAY. If one argument has the ASYNCHRONOUS, TARGET, or VALUE attribute,', &
'     the other shall have that attribute. Its result shall be a nonpolymorphic', &
'     scalar and have the same type and type parameters as ARRAY. OPERATION', &
'     should implement a mathematically associative operation. It need not be', &
'     commutative.', &
'', &
'   NOTE', &
'  If OPERATION is not computationally associative, REDUCE without', &
'  ORDERED=.TRUE. with the same argument values might not always produce the', &
'  same result, as the processor can apply the associative law to the', &
'  evaluation.', &
'', &
'  Many operations that mathematically are associative are not when applied to', &
'  floating-point numbers. The order you sum values in may affect the result,', &
'  for example.', &
'', &
'  o  DIM : An integer scalar with a value in the range 1<= DIM <= n, where n', &
'     is the rank of ARRAY.', &
'', &
'     o  MASK : (optional) shall be of type logical and shall be conformable', &
'        with ARRAY.', &
'', &
'        When present only those elements of ARRAY are passed to OPERATION for', &
'        which the corresponding elements of MASK are true, as if *array was', &
'        filtered with PACK(3).', &
'', &
'     o  IDENTITY : shall be scalar with the same type and type parameters as', &
'        ARRAY. If the initial sequence is empty, the result has the value', &
'        IDENTIFY if IDENTIFY is present, and otherwise, error termination is', &
'        initiated.', &
'', &
'     o  ORDERED : shall be a logical scalar. If ORDERED is present with the', &
'        value .true., the calls to the OPERATOR function begins with the first', &
'        two elements of ARRAY and the process continues in row-column order', &
'        until the sequence has only one element which is the value of the', &
'        reduction. Otherwise, the compiler is free to assume that the', &
'        operation is commutative and may evaluate the reduction in the most', &
'        optimal way.', &
'', &
'RESULT', &
'  The result is of the same type and type parameters as ARRAY. It is scalar if', &
'  DIM does not appear.', &
'', &
'  If DIM is present, it indicates the one dimension along which to perform the', &
'  reduction, and the resultant array has a rank reduced by one relative to the', &
'  input array.', &
'', &
'EXAMPLES', &
'  The following examples all use the function MY_MULT, which returns the', &
'  product of its two real arguments.', &
'', &
'         program demo_reduce', &
'         implicit none', &
'         character(len=*),parameter :: f=''("[",*(g0,",",1x),"]")''', &
'         integer,allocatable :: arr(:), b(:,:)', &
'', &
'         ! Basic usage:', &
'            ! the product of the elements of an array', &
'            arr=[1, 2, 3, 4 ]', &
'            write(*,*) arr', &
'            write(*,*) ''product='', reduce(arr, my_mult)', &
'            write(*,*) ''sum='', reduce(arr, my_sum)', &
'', &
'         ! Examples of masking:', &
'            ! the product of only the positive elements of an array', &
'            arr=[1, -1, 2, -2, 3, -3 ]', &
'            write(*,*)''positive value product='',reduce(arr, my_mult, mask=arr>0)', &
'         ! sum values ignoring negative values', &
'            write(*,*)''sum positive values='',reduce(arr, my_sum, mask=arr>0)', &
'', &
'         ! a single-valued array returns the single value as the', &
'         ! calls to the operator stop when only one element remains', &
'            arr=[ 1234 ]', &
'            write(*,*)''single value sum'',reduce(arr, my_sum )', &
'            write(*,*)''single value product'',reduce(arr, my_mult )', &
'', &
'         ! Example of operations along a dimension:', &
'         !  If B is the array   1 3 5', &
'         !                      2 4 6', &
'            b=reshape([1,2,3,4,5,6],[2,3])', &
'            write(*,f) REDUCE(B, MY_MULT),''should be [720]''', &
'            write(*,f) REDUCE(B, MY_MULT, DIM=1),''should be [2,12,30]''', &
'            write(*,f) REDUCE(B, MY_MULT, DIM=2),''should be [15, 48]''', &
'', &
'         contains', &
'', &
'         pure function my_mult(a,b) result(c)', &
'         integer,intent(in) :: a, b', &
'         integer            :: c', &
'            c=a*b', &
'         end function my_mult', &
'', &
'         pure function my_sum(a,b) result(c)', &
'         integer,intent(in) :: a, b', &
'         integer            :: c', &
'            c=a+b', &
'         end function my_sum', &
'', &
'         end program demo_reduce', &
'', &
'  Results:', &
'', &
'           >  1 2 3 4', &
'           >  product= 24', &
'           >  sum=     10', &
'           >  positive value sum= 6', &
'           >  sum positive values= 6', &
'           >  single value sum     1234', &
'           >  single value product 1234', &
'           > [720, should be [720],', &
'           > [2, 12, 30, should be [2,12,30],', &
'           > [15, 48, should be [15, 48],', &
'', &
'SEE ALSO', &
'  o  co_reduce(3)', &
'', &
'  o  associative:wikipedia', &
'', &
'STANDARD', &
'  Fortran 2018', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              reduce(3fortran)', &
'']

shortname="reduce"
call process()


case('167','repeat')

textblock=[character(len=256) :: &
'', &
'repeat(3fortran)                                              repeat(3fortran)', &
'', &
'NAME', &
'  REPEAT(3) - [CHARACTER] Repeated string concatenation', &
'', &
'SYNTAX', &
'  result = repeat(string, ncopies)', &
'', &
'         character(len=len(string)*ncopies) :: repeat', &
'         character(len=*),intent(in)        :: string', &
'         integer,intent(in)                 :: ncopies', &
'', &
'DESCRIPTION', &
'  Concatenates NCOPIES copies of a string.', &
'', &
'ARGUMENTS', &
'  o  STRING : The input string to repeatedly generate. Shall be scalar and of', &
'     type character.', &
'', &
'  o  NCOPIES : Number of copies to make of string, greater than or equal to', &
'     zero (0). Shall be scalar and of type integer.', &
'', &
'RETURNS', &
'  A new scalar of type character built up from NCOPIES copies of STRING.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_repeat', &
'      implicit none', &
'      integer :: i', &
'          write(*,''(a)'') repeat("^v", 36)         ! line break', &
'          write(*,''(a)'') repeat("_", 72)          ! line break', &
'          write(*,''(a)'') repeat("1234567890", 7)  ! number line', &
'          do i=80,0,-1 ! a simple progress bar', &
'              write(*,''(a)'',advance=''no'') &', &
'              & repeat("#", i)//repeat('' '',80-i)//char(13)', &
'              !do something slow', &
'          enddo', &
'      end program demo_repeat', &
'', &
'  Results:', &
'', &
'      ^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v', &
'', &
'   ________________________________________________________________________', &
'  1234567890123456789012345678901234567890123456789012345678901234567890', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NON-ELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              repeat(3fortran)', &
'']

shortname="repeat"
call process()


case('168','reshape')

textblock=[character(len=256) :: &
'', &
'reshape(3fortran)                                            reshape(3fortran)', &
'', &
'NAME', &
'  RESHAPE(3) - [ARRAY RESHAPE] Function to reshape an array', &
'', &
'SYNTAX', &
'  result = reshape(source, shape, pad, order)', &
'', &
'DESCRIPTION', &
'  Reshapes array SOURCE to correspond to SHAPE. If necessary, the new array', &
'  may be padded with elements from PAD or permuted as defined by ORDER.', &
'', &
'ARGUMENTS', &
'  o  SOURCE : an array of any type.', &
'', &
'  o  SHAPE : an array of rank one and type integer. Its values must be', &
'     positive or zero.', &
'', &
'  o  PAD : (Optional) an array of the same type as SOURCE.', &
'', &
'  o  ORDER : (Optional) an array of type integer and the same shape as SHAPE.', &
'     Its values shall be a permutation of the numbers from 1 to n, where n is', &
'     the size of SHAPE. If ORDER is absent, the natural ordering shall be', &
'     assumed.', &
'', &
'RETURNS', &
'  The result is an array of shape SHAPE with the same type as SOURCE.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_reshape', &
'      implicit none', &
'      integer :: i', &
'      integer, dimension(4) :: x=[(i,i=10,40,10)]', &
'      real :: xx(3,4)', &
'      real,allocatable :: v(:)', &
'          ! x is originally a vector with four elements', &
'          write(*,*) shape(x) ! what is the current shape of the array?', &
'          write(*,*) shape(reshape(x, [2, 2]))    ! prints "2 2"', &
'', &
'          ! pack any array into a vector', &
'          xx=1.0', &
'          v=reshape(xx,[size(xx)])', &
'          write(*,*)shape(v),ubound(v)', &
'      end program demo_reshape', &
'', &
'  Results:', &
'', &
'    4', &
'', &
'    2', &
'', &
'  12', &
'    12', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  SHAPE(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             reshape(3fortran)', &
'']

shortname="reshape"
call process()


case('169','rrspacing')

textblock=[character(len=256) :: &
'', &
'rrspacing(3fortran)                                        rrspacing(3fortran)', &
'', &
'NAME', &
'  RRSPACING(3) - [MODEL_COMPONENTS] Reciprocal of the relative spacing', &
'', &
'SYNTAX', &
'  result = rrspacing(x)', &
'', &
'DESCRIPTION', &
'  RRSPACING(X) returns the reciprocal of the relative spacing of model numbers', &
'  near X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as X. The value returned is', &
'  equal to ABS(FRACTION(X)) * FLOAT(RADIX(X))**DIGITS(X).', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           rrspacing(3fortran)', &
'']

shortname="rrspacing"
call process()


case('170','same_type_as')

textblock=[character(len=256) :: &
'', &
'same_type_as(3fortran)                                  same_type_as(3fortran)', &
'', &
'NAME', &
'  SAME_TYPE_AS(3) - [STATE] Query dynamic types for equality', &
'', &
'SYNTAX', &
'  result = same_type_as(a, b)', &
'', &
'DESCRIPTION', &
'  Query dynamic types for equality.', &
'', &
'ARGUMENTS', &
'  o  A : Shall be an object of extensible declared type or unlimited', &
'     polymorphic.', &
'', &
'  o  B : Shall be an object of extensible declared type or unlimited', &
'     polymorphic.', &
'', &
'RETURNS', &
'  The return value is a scalar of type default logical. It is true if and only', &
'  if the dynamic type of A is the same as the dynamic type of B.', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  EXTENDS_TYPE_OF(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022        same_type_as(3fortran)', &
'']

shortname="same_type_as"
call process()


case('171','scale')

textblock=[character(len=256) :: &
'', &
'scale(3fortran)                                                scale(3fortran)', &
'', &
'NAME', &
'  SCALE(3) - [MODEL_COMPONENTS] Scale a real value by a whole power of the', &
'  radix', &
'', &
'SYNTAX', &
'  result = scale(x, i)', &
'', &
'         real(kind=KIND),intent(in) :: x', &
'         integer,intent(in)         :: i', &
'', &
'DESCRIPTION', &
'  SCALE(X,I) returns x * RADIX(X)**I.', &
'', &
'ARGUMENTS', &
'  o  X : The type of the argument shall be a real.', &
'', &
'  o  I : The type of the argument shall be a integer.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as X. Its value is X *', &
'  RADIX(X)**I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_scale', &
'      implicit none', &
'      real :: x = 178.1387e-4', &
'      integer :: i = 5', &
'         print *, scale(x,i), x*radix(x)**i', &
'      end program demo_scale', &
'', &
'  Results:', &
'', &
'          0.570043862      0.570043862', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               scale(3fortran)', &
'']

shortname="scale"
call process()


case('172','scan')

textblock=[character(len=256) :: &
'', &
'scan(3fortran)                                                  scan(3fortran)', &
'', &
'NAME', &
'  SCAN(3) - [CHARACTER:SEARCH] Scan a string for the presence of a set of', &
'  characters', &
'', &
'SYNTAX', &
'  result = scan(string, set[, back [, kind]])', &
'', &
'DESCRIPTION', &
'  Scans a STRING for any of the characters in a SET of characters.', &
'', &
'  If BACK is either absent or equals .false., this function returns the', &
'  position of the leftmost character of STRING that is in SET. If BACK equals', &
'  .true., the rightmost position is returned. If no character of SET is found', &
'  in STRING, the result is zero.', &
'', &
'ARGUMENTS', &
'  o  STRING : Shall be of type character.', &
'', &
'  o  SET : Shall be of type character.', &
'', &
'  o  BACK : (Optional) shall be of type logical.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_scan', &
'      implicit none', &
'         write(*,*) scan("fortran", "ao")          ! 2, found ''o''', &
'         write(*,*) scan("fortran", "ao", .true.)  ! 6, found ''a''', &
'         write(*,*) scan("fortran", "c++")         ! 0, found none', &
'      end program demo_scan', &
'', &
'  Results:', &
'', &
'    2 6 0', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument - Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                scan(3fortran)', &
'']

shortname="scan"
call process()


case('173','selected_char_kind')

textblock=[character(len=256) :: &
'', &
'selected_char_kind(3fortran)                      selected_char_kind(3fortran)', &
'', &
'NAME', &
'  SELECTED_CHAR_KIND(3) - [KIND] Choose character kind such as "Unicode"', &
'', &
'SYNTAX', &
'  result = selected_char_kind(name)', &
'', &
'DESCRIPTION', &
'  SELECTED_CHAR_KIND(NAME) returns the kind value for the character set named', &
'  NAME, if a character set with such a name is supported, or -1 otherwise.', &
'  Currently, supported character sets include "ASCII" and "DEFAULT" (iwhich', &
'  are equivalent), and "ISO_10646" (Universal Character Set, UCS-4) which is', &
'  commonly known as "Unicode".', &
'', &
'ARGUMENTS', &
'  o  NAME : Shall be a scalar and of the default character type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_selected_char_kind', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer, parameter :: ascii = selected_char_kind ("ascii")', &
'      integer, parameter :: ucs4  = selected_char_kind (''ISO_10646'')', &
'', &
'      character(kind=ascii, len=26) :: alphabet', &
'      character(kind=ucs4,  len=30) :: hello_world', &
'', &
'         alphabet = ascii_"abcdefghijklmnopqrstuvwxyz"', &
'         hello_world = ucs4_''Hello World and Ni Hao -- '' &', &
'                       // char (int (z''4F60''), ucs4)     &', &
'                       // char (int (z''597D''), ucs4)', &
'', &
'         write (*,*) alphabet', &
'', &
'         open (output_unit, encoding=''UTF-8'')', &
'         write (*,*) trim (hello_world)', &
'      end program demo_selected_char_kind', &
'', &
'  Results:', &
'', &
'          abcdefghijklmnopqrstuvwxyz', &
'          Hello World and Ni Hao --', &
'', &
'STANDARD', &
'  Fortran 2003 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022  selected_char_kind(3fortran)', &
'']

shortname="selected_char_kind"
call process()


case('174','selected_int_kind')

textblock=[character(len=256) :: &
'', &
'selected_int_kind(3fortran)                        selected_int_kind(3fortran)', &
'', &
'NAME', &
'  SELECTED_INT_KIND(3) - [KIND] Choose integer kind', &
'', &
'SYNTAX', &
'  result = selected_int_kind(r)', &
'', &
'DESCRIPTION', &
'  SELECTED_INT_KIND(R) return the kind value of the smallest integer type that', &
'  can represent all values ranging from -10**R (exclusive) to 10**R', &
'  (exclusive). If there is no integer kind that accommodates this range,', &
'  selected_int_kind returns -1.', &
'', &
'ARGUMENTS', &
'  o  R : Shall be a scalar and of type integer.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_selected_int_kind', &
'      implicit none', &
'      integer,parameter :: k5 = selected_int_kind(5)', &
'      integer,parameter :: k15 = selected_int_kind(15)', &
'      integer(kind=k5) :: i5', &
'      integer(kind=k15) :: i15', &
'', &
'          print *, huge(i5), huge(i15)', &
'', &
'          ! the following inequalities are always true', &
'          print *, huge(i5) >= 10_k5**5-1', &
'          print *, huge(i15) >= 10_k15**15-1', &
'      end program demo_selected_int_kind', &
'', &
'  Results:', &
'', &
'           2147483647  9223372036854775807', &
'', &
'   T', &
'   T', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  AINT(3), ANINT(3), INT(3), NINT(3), CEILING(3), FLOOR(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022   selected_int_kind(3fortran)', &
'']

shortname="selected_int_kind"
call process()


case('175','selected_real_kind')

textblock=[character(len=256) :: &
'', &
'selected_real_kind(3fortran)                      selected_real_kind(3fortran)', &
'', &
'NAME', &
'  SELECTED_REAL_KIND(3) - [KIND] Choose real kind', &
'', &
'SYNTAX', &
'  result = selected_real_kind(p, r, radix)', &
'', &
'DESCRIPTION', &
'  SELECTED_REAL_KIND(P, R, RADIX) return the kind value of a real data type', &
'  with decimal precision of at least P digits, exponent range of at least R,', &
'  and with a radix of RADIX.', &
'', &
'ARGUMENTS', &
'  o  P : (Optional) shall be a scalar and of type integer.', &
'', &
'  o  R : (Optional) shall be a scalar and of type integer.', &
'', &
'  o  RADIX : (Optional) shall be a scalar and of type integer.', &
'', &
'  Before FORTRAN 2008, at least one of the arguments R or P shall be present;', &
'  since FORTRAN 2008, they are assumed to be zero if absent.', &
'', &
'RETURNS', &
'  selected_real_kind returns the value of the kind type parameter of a real', &
'  data type with decimal precision of at least P digits, a decimal exponent', &
'  range of at least R, and with the requested RADIX. If the RADIX parameter is', &
'  absent, real kinds with any radix can be returned. If more than one real', &
'  data type meet the criteria, the kind of the data type with the smallest', &
'  decimal precision is returned. If no real data type matches the criteria,', &
'  the result is', &
'', &
'  o  -1 : if the processor does not support a real data type with a precision', &
'     greater than or equal to P, but the R and RADIX requirements can be', &
'     fulfilled', &
'', &
'  o  -2 : if the processor does not support a real type with an exponent range', &
'     greater than or equal to R, but P and RADIX are fulfillable', &
'', &
'  o  -3 : if RADIX but not P and R requirements are fulfillable', &
'', &
'  o  -4 : if RADIX and either P or R requirements are fulfillable', &
'', &
'  o  -5 : if there is no real type with the given RADIX', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_selected_real_kind', &
'      implicit none', &
'      integer,parameter :: p6 = selected_real_kind(6)', &
'      integer,parameter :: p10r100 = selected_real_kind(10,100)', &
'      integer,parameter :: r400 = selected_real_kind(r=400)', &
'      real(kind=p6) :: x', &
'      real(kind=p10r100) :: y', &
'      real(kind=r400) :: z', &
'', &
'         print *, precision(x), range(x)', &
'         print *, precision(y), range(y)', &
'         print *, precision(z), range(z)', &
'      end program demo_selected_real_kind', &
'', &
'  Results:', &
'', &
'    6 37', &
'', &
'  15', &
'    307', &
'', &
'    18', &
'      4931', &
'', &
'STANDARD', &
'  Fortran 95 and later; with RADIX - Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  PRECISION(3), RANGE(3), RADIX(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022  selected_real_kind(3fortran)', &
'']

shortname="selected_real_kind"
call process()


case('176','set_exponent')

textblock=[character(len=256) :: &
'', &
'set_exponent(3fortran)                                  set_exponent(3fortran)', &
'', &
'NAME', &
'  SET_EXPONENT(3) - [MODEL_COMPONENTS] Set the exponent of the model', &
'', &
'SYNTAX', &
'  result = set_exponent(x, i)', &
'', &
'DESCRIPTION', &
'  SET_EXPONENT(X, I) returns the real number whose fractional part is that of', &
'  X and whose exponent part is I.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real.', &
'', &
'  o  I : Shall be of type integer.', &
'', &
'RETURNS', &
'  The return value is of the same type and kind as X. The real number whose', &
'  fractional part is that that of X and whose exponent part if I is returned;', &
'  it is FRACTION(X) * RADIX(X)**I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_setexp', &
'      implicit none', &
'      real :: x = 178.1387e-4', &
'      integer :: i = 17', &
'         print *, set_exponent(x, i), fraction(x) * radix(x)**i', &
'      end program demo_setexp', &
'', &
'  Results:', &
'', &
'            74716.7891       74716.7891', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SPACING(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022        set_exponent(3fortran)', &
'']

shortname="set_exponent"
call process()


case('177','shape')

textblock=[character(len=256) :: &
'', &
'shape(3fortran)                                                shape(3fortran)', &
'', &
'NAME', &
'  SHAPE(3) - [ARRAY INQUIRY] Determine the shape of an array', &
'', &
'SYNTAX', &
'  result = shape(source, kind)', &
'', &
'DESCRIPTION', &
'  Determines the shape of an array.', &
'', &
'ARGUMENTS', &
'  o  SOURCE : Shall be an array or scalar of any type. If SOURCE is a pointer', &
'     it must be associated and allocatable arrays must be allocated.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  An integer array of rank one with as many elements as SOURCE has dimensions.', &
'  The elements of the resulting array correspond to the extend of SOURCE along', &
'  the respective dimensions. If SOURCE is a scalar, the result is the rank one', &
'  array of size zero. If KIND is absent, the return value has the default', &
'  integer kind otherwise the specified kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shape', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      integer, dimension(-1:1, -1:2) :: a', &
'         print all, ''shape of array='',shape(a)', &
'         print all, ''shape of constant='',shape(42)', &
'         print all, ''size of shape of constant='',size(shape(42))', &
'         print all, ''ubound of array='',ubound(a)', &
'         print all, ''lbound of array='',lbound(a)', &
'      end program demo_shape', &
'', &
'  Results:', &
'', &
'         shape of array= 3 4', &
'         shape of constant=', &
'         size of shape of constant= 0', &
'         ubound of array= 1 2', &
'         lbound of array= -1 -1', &
'', &
'STANDARD', &
'  Fortran 95 and later; with KIND argument Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  RESHAPE(3), SIZE(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022               shape(3fortran)', &
'']

shortname="shape"
call process()


case('178','shifta')

textblock=[character(len=256) :: &
'', &
'shifta(3fortran)                                              shifta(3fortran)', &
'', &
'NAME', &
'  SHIFTA(3) - [BIT:SHIFT] shift bits right with fill', &
'', &
'SYNTAX', &
'  elemental integer(kind=KIND) function shifta(i, shift)', &
'', &
'            integer(kind=KIND),intent(in) :: i', &
'            integer(kind=SHIFTKIND,intent(in) :: shift', &
'', &
'  where KIND and SHIFTKIND may be any supported integer kind, but where the', &
'  kind for I dictates the kind of the returned value.', &
'', &
'DESCRIPTION', &
'  Returns a value corresponding to I with all of the bits shifted right by', &
'  SHIFT places and the vacated bits on the left filled with the value of the', &
'  original left-most bit..', &
'', &
'ARGUMENTS', &
'  o  I : The initial value to shift and fill', &
'', &
'  o  SHIFT : how many bits to shift right. It shall be nonnegative and less', &
'     than or equal to BIT_SIZE(I). or the value is undefined.', &
'', &
'RETURNS', &
'  The result characteristics (kind, type, rank, shape, ....) are the same as', &
'  I.', &
'', &
'  The result has the value obtained by shifting the bits of I to the right', &
'  SHIFT bits and replicating the leftmost bit of I in the left SHIFT bits (the', &
'  leftmost bit in "two''s complement" representation is the sign bit).', &
'', &
'  Bits shifted out from the right end are lost.', &
'', &
'  If SHIFT is zero the result is I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shifta', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: ival', &
'      integer             :: shift', &
'      integer(kind=int32) :: oval', &
'      integer(kind=int32),allocatable :: ivals(:)', &
'      integer             :: i', &
'      integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])', &
'', &
'        ! basic usage', &
'        write(*,*)shifta(100,3)', &
'', &
'        ! loop through some interesting values', &
'         shift=5', &
'', &
'         ivals=[ -1, -0, +0, +1, &', &
'         & int(b"01010101010101010101010101010101"), &', &
'         & int(b"10101010101010101010101010101010"), &', &
'         & int(b"00000000000000000000000000011111") ]', &
'', &
'         ! does your platform distinguish betwee +0 and -0?', &
'         ! note the original leftmost bit is used to fill in the vacated bits', &
'', &
'         write(*,''(/,"SHIFT =  ",i0)'') shift', &
'         do i=1,size(ivals)', &
'            ival=ivals(i)', &
'            write(*,''(  "I =      ",b32.32," == ",i0)'') ival,ival', &
'            oval=shifta(ival,shift)', &
'            write(*,''(  "RESULT = ",b32.32," == ",i0)'') oval,oval', &
'         enddo', &
'         ! elemental', &
'         write(*,*)"characteristics of the result are the same as input"', &
'         write(*,''(*(g0,1x))'') &', &
'           & "kind=",kind(shifta(arr,3)), "shape=",shape(shifta(arr,3)), &', &
'           & "size=",size(shifta(arr,3)) !, "rank=",rank(shifta(arr,3))', &
'', &
'      end program demo_shifta', &
'', &
'  Results:', &
'', &
'       >           12', &
'       >', &
'       > SHIFT =  5', &
'       > I =      11111111111111111111111111111111 == -1', &
'       > RESULT = 11111111111111111111111111111111 == -1', &
'       > I =      00000000000000000000000000000000 == 0', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       > I =      00000000000000000000000000000000 == 0', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       > I =      00000000000000000000000000000001 == 1', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       > I =      01010101010101010101010101010101 == 1431655765', &
'       > RESULT = 00000010101010101010101010101010 == 44739242', &
'       > I =      10101010101010101010101010101010 == -1431655766', &
'       > RESULT = 11111101010101010101010101010101 == -44739243', &
'       > I =      00000000000000000000000000011111 == 31', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       >  characteristics of the result are the same as input', &
'       > kind= 1 shape= 2 2 size= 4', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  SHIFTL(3), SHIFTR(3), ISHFT(3), ISHFTC(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              shifta(3fortran)', &
'']

shortname="shifta"
call process()


case('179','shiftl')

textblock=[character(len=256) :: &
'', &
'shiftl(3fortran)                                              shiftl(3fortran)', &
'', &
'NAME', &
'  SHIFTL(3) - [BIT:SHIFT] shift bits left', &
'', &
'SYNTAX', &
'  elemental integer(kind=KIND) function shiftl(i, shift)', &
'', &
'       integer(kind=KIND),intent(in) :: i', &
'       integer(kind=SHIFTKIND,intent(in) :: shift', &
'', &
'  where KIND and SHIFTKIND may be any supported integer kind, but where the', &
'  kind for I dictates the kind of the returned value.', &
'', &
'DESCRIPTION', &
'  Returns a value corresponding to I with all of the bits shifted left by', &
'  SHIFT places.', &
'', &
'  Bits shifted out from the left end are lost, and bits shifted in from the', &
'  right end are set to 0.', &
'', &
'  If the absolute value of SHIFT is greater than BIT_SIZE(I), the value is', &
'  undefined.', &
'', &
'  Note the value of the result is the same as ISHFT (I, SHIFT).', &
'', &
'ARGUMENTS', &
'  o  I : The initial value to shift and fill in with zeros', &
'', &
'  o  SHIFT : how many bits to shift left. It shall be nonnegative and less', &
'     than or equal to BIT_SIZE(I).', &
'', &
'RETURNS', &
'  The return value is of type integer and of the same kind as I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shiftl', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer             :: shift', &
'      integer(kind=int32) :: oval', &
'      integer(kind=int32) :: ival', &
'      integer(kind=int32),allocatable :: ivals(:)', &
'      integer             :: i', &
'', &
'       ! basic usage', &
'        ival=100', &
'        write(*,*)ival, shiftl(100,3)', &
'', &
'       ! elemental (input values may be conformant arrays)', &
'        ! shifting is often equivalent to multiplying be a power of two', &
'        write(*,*) shiftl(-1,[(i,i=1,bit_size(0))])', &
'        write(*,*)', &
'        write(*,*) shiftl(+3,[(i,i=1,bit_size(0))])', &
'', &
'       ! loop through some ivalues', &
'         shift=9', &
'         ivals=[ &', &
'         & int(b"01010101010101010101010101010101"), &', &
'         & int(b"10101010101010101010101010101010"), &', &
'         & int(b"11111111111111111111111111111111") ]', &
'', &
'         write(*,''(/,"SHIFT =  ",i0)'') shift', &
'         do i=1,size(ivals)', &
'            ! print initial value as binary and decimal', &
'            write(*,''(  "I =      ",b32.32," == ",i0)'') ivals(i),ivals(i)', &
'            ! print shifted value as binary and decimal', &
'            oval=shiftl(ivals(i),shift)', &
'            write(*,''(  "RESULT = ",b32.32," == ",i0)'') oval,oval', &
'         enddo', &
'', &
'        ! elemental (input values may be conformant arrays)', &
'         ELEM : block', &
'         integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])', &
'         write(*,*)"characteristics of the result are the same as input"', &
'         write(*,''(*(g0,1x))'') &', &
'           & "kind=",kind(shiftl(arr,3)), "shape=",shape(shiftl(arr,3)), &', &
'           & "size=",size(shiftl(arr,3)) !, "rank=",rank(shiftl(arr,3))', &
'         endblock ELEM', &
'', &
'      end program demo_shiftl', &
'', &
'  Results:', &
'', &
'      >         100         800', &
'      >', &
'      >           -2          -4          -8         -16         -32         -64', &
'      >         -128        -256        -512       -1024       -2048       -4096', &
'      >        -8192      -16384      -32768      -65536     -131072     -262144', &
'      >      -524288    -1048576    -2097152    -4194304    -8388608   -16777216', &
'      >    -33554432   -67108864  -134217728  -268435456  -536870912 -1073741824', &
'      >  -2147483648           0', &
'      >', &
'      >            6          12          24          48          96         192', &
'      >          384         768        1536        3072        6144       12288', &
'      >        24576       49152       98304      196608      393216      786432', &
'      >      1572864     3145728     6291456    12582912    25165824    50331648', &
'      >    100663296   201326592   402653184   805306368  1610612736 -1073741824', &
'      >  -2147483648           0', &
'      >', &
'      >   SHIFT =  9', &
'      >   I =      01010101010101010101010101010101 == 1431655765', &
'      >   RESULT = 10101010101010101010101000000000 == -1431655936', &
'      >   I =      10101010101010101010101010101010 == -1431655766', &
'      >   RESULT = 01010101010101010101010000000000 == 1431655424', &
'      >   I =      11111111111111111111111111111111 == -1', &
'      >   RESULT = 11111111111111111111111000000000 == -512', &
'      >    characteristics of the result are the same as input', &
'      >   kind= 1 shape= 2 2 size= 4', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  SHIFTA(3), SHIFTR(3), ISHFT(3), ISHFTC(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              shiftl(3fortran)', &
'']

shortname="shiftl"
call process()


case('180','shiftr')

textblock=[character(len=256) :: &
'', &
'shiftr(3fortran)                                              shiftr(3fortran)', &
'', &
'NAME', &
'  SHIFTR(3) - [BIT:SHIFT] shift bits right', &
'', &
'SYNTAX', &
'  elemental integer(kind=KIND) function shiftr(i, shift)', &
'', &
'       integer(kind=KIND),intent(in) :: i', &
'       integer(kind=SHIFTKIND,intent(in) :: shift', &
'', &
'  where KIND and SHIFTKIND may be any supported integer kind, but where the', &
'  kind for I dictates the kind of the returned value.', &
'', &
'DESCRIPTION', &
'  Returns a value corresponding to I with all of the bits shifted right by', &
'  SHIFT places. If the absolute value of SHIFT is greater than BIT_SIZE(I),', &
'  the value is undefined. Bits shifted out from the right end are lost, and', &
'  bits shifted in from the left end are set to 0.', &
'', &
'  Note the value of the result is the same as ISHFT (I, -SHIFT).', &
'', &
'ARGUMENTS', &
'  o  I : The initial value to shift and fill in with zeros', &
'', &
'  o  SHIFT : how many bits to shift right. It shall be nonnegative and less', &
'     than or equal to BIT_SIZE(I).', &
'', &
'RETURNS', &
'  The return value is of type integer and of the same kind as I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shiftr', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer             :: shift', &
'      integer(kind=int32) :: oval', &
'      integer(kind=int32) :: ival', &
'      integer(kind=int32),allocatable :: ivals(:)', &
'      integer             :: i', &
'', &
'        ! basic usage', &
'        ival=100', &
'        write(*,*)ival, shiftr(100,3)', &
'', &
'        ! elemental (input values may be conformant arrays)', &
'        write(*,*) shiftr(-1,[(i,i=1,bit_size(0))])', &
'', &
'        ! loop through some ivalues', &
'         shift=9', &
'         ivals=[ &', &
'         & int(b"01010101010101010101010101010101"), &', &
'         & int(b"10101010101010101010101010101010"), &', &
'         & int(b"11111111111111111111111111111111") ]', &
'', &
'         write(*,''(/,"SHIFT =  ",i0)'') shift', &
'         do i=1,size(ivals)', &
'            ! print initial value as binary and decimal', &
'            write(*,''(  "I =      ",b32.32," == ",i0)'') ivals(i),ivals(i)', &
'            ! print shifted value as binary and decimal', &
'            oval=shiftr(ivals(i),shift)', &
'            write(*,''(  "RESULT = ",b32.32," == ",i0)'') oval,oval', &
'         enddo', &
'', &
'         ! more on elemental (input values may be conformant arrays)', &
'         ELEM : block', &
'         integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])', &
'         write(*,*)"characteristics of the result are the same as input"', &
'         write(*,''(*(g0,1x))'') &', &
'           & "kind=",kind(shiftr(arr,3)), "shape=",shape(shiftr(arr,3)), &', &
'           & "size=",size(shiftr(arr,3)) !, "rank=",rank(shiftr(arr,3))', &
'         endblock ELEM', &
'', &
'      end program demo_shiftr', &
'', &
'  Results:', &
'', &
'      >          100          12', &
'      >   2147483647  1073741823   536870911   268435455   134217727    67108863', &
'      >     33554431    16777215     8388607     4194303     2097151     1048575', &
'      >       524287      262143      131071       65535       32767       16383', &
'      >         8191        4095        2047        1023         511         255', &
'      >          127          63          31          15           7           3', &
'      >            1           0', &
'      >', &
'      >  SHIFT =  9', &
'      >  I =      01010101010101010101010101010101 == 1431655765', &
'      >  RESULT = 00000000001010101010101010101010 == 2796202', &
'      >  I =      10101010101010101010101010101010 == -1431655766', &
'      >  RESULT = 00000000010101010101010101010101 == 5592405', &
'      >  I =      11111111111111111111111111111111 == -1', &
'      >  RESULT = 00000000011111111111111111111111 == 8388607', &
'      >   characteristics of the result are the same as input', &
'      >  kind= 1 shape= 2 2 size= 4', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  SHIFTA(3), SHIFTL(3), ISHFT(3), ISHFTC(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              shiftr(3fortran)', &
'']

shortname="shiftr"
call process()


case('181','sign')

textblock=[character(len=256) :: &
'', &
'sign(3fortran)                                                  sign(3fortran)', &
'', &
'NAME', &
'  SIGN(3) - [NUMERIC] Sign copying function', &
'', &
'SYNTAX', &
'  result = sign(a, b)', &
'', &
'          elemental function sign(a, b)', &
'          type(TYPE(kind=KIND))            :: sign', &
'          type(TYPE(kind=KIND)),intent(in) :: a, b', &
'', &
'  where TYPE may be real or integer and KIND is any supported kind for the', &
'  type.', &
'', &
'DESCRIPTION', &
'  SIGN(a,b) return a value with the magnitude of A but with the sign of B.', &
'', &
'  For processors that distinguish between positive and negative zeros SIGN()', &
'  may be used to distinguish between REAL values 0.0 and -0.0. SIGN (1.0,', &
'  -0.0) will return -1.0 when a negative zero is distinguishable.', &
'', &
'ARGUMENTS', &
'  o  A : The value whos magnitude will be returned. Shall be of type integer', &
'     or real', &
'', &
'  o  B : The value whose sign will be returned. Shall be of the same type and', &
'     kind as A', &
'', &
'RETURNS', &
'  The kind of the return value is the magnitude of A with the sign of B.  That', &
'  is,', &
'', &
'  o  If B >= 0 then the result is ABS(A)', &
'', &
'  o  else if B < 0 it is -ABS(A).', &
'', &
'  o  if B is real and the processor distinguishes between -0.0 and 0.0 then', &
'     the result is -ABS(A)', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_sign', &
'      implicit none', &
'         print *,  sign( -12,  1 )', &
'         print *,  sign( -12,  0 )', &
'         print *,  sign( -12, -1 )', &
'', &
'         print *,  sign( -12.0, [1.0, 0.0, -1.0] )', &
'', &
'         print *,  ''can I distinguish 0 from -0? '', &', &
'         &  sign( 1.0, -0.0 ) .ne. sign( 1.0, 0.0 )', &
'      end program demo_sign', &
'', &
'  Results:', &
'', &
'                   12', &
'                   12', &
'  -12', &
'', &
'    12.00000', &
'      12.00000      -12.00000', &
'', &
'  can I distinguish 0 from -0?', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                sign(3fortran)', &
'']

shortname="sign"
call process()


case('182','sin')

textblock=[character(len=256) :: &
'', &
'sin(3fortran)                                                    sin(3fortran)', &
'', &
'NAME', &
'  SIN(3) - [MATHEMATICS:TRIGONOMETRIC] Sine function', &
'', &
'SYNTAX', &
'  result = sin(x)', &
'', &
'          elemental TYPE(kind=KIND) function sin(x)', &
'          TYPE(kind=KIND) :: x', &
'', &
'  Where the returned value has the kind of the input value and TYPE may be', &
'  real or complex', &
'', &
'DESCRIPTION', &
'  SIN(X) computes the sine of an angle given the size of the angle in radians.', &
'', &
'  The sine of an angle in a right-angled triangle is the ratio of the length', &
'  of the side opposite the given angle divided by the length of the', &
'  hypotenuse.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex in radians.', &
'', &
'RETURNS', &
'  o  RESULT : The return value has the same type and kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program sample_sin', &
'      implicit none', &
'      real :: x = 0.0', &
'         x = sin(x)', &
'      end program sample_sin', &
'', &
'HAVERSINE FORMULA', &
'  From the article on "Haversine formula" in Wikipedia:', &
'', &
'      The haversine formula is an equation important in navigation,', &
'      giving great-circle distances between two points on a sphere from', &
'      their longitudes and latitudes.', &
'', &
'  So to show the great-circle distance between the Nashville International', &
'  Airport (BNA) in TN, USA, and the Los Angeles International Airport (LAX) in', &
'  CA, USA you would start with their latitude and longitude, commonly given as', &
'', &
'      BNA: N 36 degrees 7.2'',   W 86 degrees 40.2''', &
'      LAX: N 33 degrees 56.4'',  W 118 degrees 24.0''', &
'', &
'  which converted to floating-point values in degrees is:', &
'', &
'           Latitude Longitude', &
'', &
'    o  BNA 36.12, -86.67', &
'', &
'    o  LAX 33.94, -118.40', &
'', &
'  And then use the haversine formula to roughly calculate the distance along', &
'  the surface of the Earth between the locations:', &
'', &
'  Sample program:', &
'', &
'      program demo_sin', &
'      implicit none', &
'      real :: d', &
'          d = haversine(36.12,-86.67, 33.94,-118.40) ! BNA to LAX', &
'          print ''(A,F9.4,A)'', ''distance: '',d,'' km''', &
'      contains', &
'      function haversine(latA,lonA,latB,lonB) result (dist)', &
'      !', &
'      ! calculate great circle distance in kilometers', &
'      ! given latitude and longitude in degrees', &
'      !', &
'      real,intent(in) :: latA,lonA,latB,lonB', &
'      real :: a,c,dist,delta_lat,delta_lon,lat1,lat2', &
'      real,parameter :: radius = 6371 ! mean earth radius in kilometers,', &
'      ! recommended by the International Union of Geodesy and Geophysics', &
'', &
'      ! generate constant pi/180', &
'      real, parameter :: deg_to_rad = atan(1.0)/45.0', &
'         delta_lat = deg_to_rad*(latB-latA)', &
'         delta_lon = deg_to_rad*(lonB-lonA)', &
'         lat1 = deg_to_rad*(latA)', &
'         lat2 = deg_to_rad*(latB)', &
'         a = (sin(delta_lat/2))**2 + &', &
'                & cos(lat1)*cos(lat2)*(sin(delta_lon/2))**2', &
'         c = 2*asin(sqrt(a))', &
'         dist = radius*c', &
'      end function haversine', &
'      end program demo_sin', &
'', &
'  Results:', &
'', &
'          distance: 2886.4446 km', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:sine and cosine', &
'', &
'  ASIN(3), COS(3), TAN(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                 sin(3fortran)', &
'']

shortname="sin"
call process()


case('183','sinh')

textblock=[character(len=256) :: &
'', &
'sinh(3fortran)                                                  sinh(3fortran)', &
'', &
'NAME', &
'  SINH(3) - [MATHEMATICS:TRIGONOMETRIC] Hyperbolic sine function', &
'', &
'SYNTAX', &
'  result = sinh(x)', &
'', &
'          elemental TYPE(kind=KIND) function sinh(x)', &
'          TYPE(kind=KIND) :: x', &
'', &
'  Where the returned value has the kind of the input value and TYPE may be', &
'  real or complex', &
'', &
'DESCRIPTION', &
'  SINH(X) computes the hyperbolic sine of X.', &
'', &
'  The hyperbolic sine of x is defined mathematically as:', &
'', &
'  SINH(X) = (EXP(X) - EXP(-X)) / 2.0', &
'', &
'  If X is of type complex its imaginary part is regarded as a value in', &
'  radians.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value has same type and kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_sinh', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'      & real_kinds, real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = - 1.0_real64', &
'      real(kind=real64) :: nan, inf', &
'      character(len=20) :: line', &
'', &
'         print *, sinh(x)', &
'         print *, (exp(x)-exp(-x))/2.0', &
'', &
'         ! sinh(3) is elemental and can handle an array', &
'         print *, sinh([x,2.0*x,x/3.0])', &
'', &
'         ! a NaN input returns NaN', &
'         line=''NAN''', &
'         read(line,*) nan', &
'         print *, sinh(nan)', &
'', &
'         ! a Inf input returns Inf', &
'         line=''Infinity''', &
'         read(line,*) inf', &
'         print *, sinh(inf)', &
'', &
'         ! an overflow returns Inf', &
'         x=huge(0.0d0)', &
'         print *, sinh(x)', &
'', &
'      end program demo_sinh', &
'', &
'  Results:', &
'', &
'        -1.1752011936438014', &
'        -1.1752011936438014', &
'        -1.1752011936438014       -3.6268604078470190      -0.33954055725615012', &
'                             NaN', &
'                        Infinity', &
'                        Infinity', &
'', &
'STANDARD', &
'  Fortran 95 and later, for a complex argument Fortran 2008 or later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  ASINH(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                sinh(3fortran)', &
'']

shortname="sinh"
call process()


case('184','size')

textblock=[character(len=256) :: &
'', &
'size(3fortran)                                                  size(3fortran)', &
'', &
'NAME', &
'  SIZE(3) - [ARRAY INQUIRY] Determine the size of an array', &
'', &
'SYNTAX', &
'  result = size(array, dim, kind)', &
'', &
'DESCRIPTION', &
'  Determine the extent of ARRAY along a specified dimension DIM, or the total', &
'  number of elements in ARRAY if DIM is absent.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : be an array of any type. If ARRAY is a pointer it must be', &
'     associated and allocatable arrays must be allocated.', &
'', &
'  o  DIM : shall be a scalar of type integer and its value shall be in the', &
'     range from 1 to n, where n equals the rank of ARRAY.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_size', &
'      implicit none', &
'      integer :: i, j', &
'      integer :: arr(0:2,-5:5)=reshape([(((i-1)*11+j,i=1,3),j=1,11)],[3,11])', &
'         write(*,*) ''SIZE of simple one-dimensional array='', &', &
'         & size([ 11, 22, 33 ])    ! 3', &
'', &
'         write(*,*)''body''', &
'         write(*,*)''SHAPE(arr)       :'',shape(arr)', &
'         write(*,*)''SIZE(arr)        :'',size(arr)', &
'         write(*,*)''SIZE(arr,DIM=1)  :'',size(arr,dim=1)', &
'         write(*,*)''SIZE(arr,DIM=2)  :'',size(arr,dim=2)', &
'         write(*,*)''note lower bound is not "1"''', &
'         write(*,*)''LBOUND(arr)      :'',lbound(arr)', &
'         write(*,*)''UBOUND(arr)      :'',ubound(arr)', &
'         write(*,*)''LBOUND(arr,DIM=1):'',lbound(arr,dim=1)', &
'         write(*,*)''UBOUND(arr,DIM=1):'',ubound(arr,dim=1)', &
'         write(*,*)''LBOUND(arr,DIM=2):'',lbound(arr,dim=2)', &
'         write(*,*)''UBOUND(arr,DIM=2):'',ubound(arr,dim=2)', &
'', &
'         call interfaced(arr,arr)', &
'         call nointerface(arr)', &
'      contains', &
'', &
'      subroutine interfaced(arr,arr2)', &
'      integer,intent(in)  :: arr(:,:)', &
'      integer,intent(in)  :: arr2(2,*)', &
'         !', &
'         write(*,*)''interfaced assumed-shape arr2ay''', &
'         !', &
'         ! source argument of shape intrinsic at (1) must not be', &
'         ! an assumed size array', &
'         !!write(*,*)''SHAPE(arr2)       :'',shape(arr2)', &
'         ! The upper bound in the last dimension must appear in the reference', &
'         ! to the assumed size array    arr2    at (1)', &
'         !!write(*,*)''SIZE(arr2)        :'',size(arr2)', &
'         write(*,*)''SIZE(arr2,DIM=1)  :'',size(arr2,dim=1)', &
'         !    dim    argument of    size    intrinsic at (1) is not', &
'         !a valid dimension index', &
'         !!write(*,*)''SIZE(arr2,DIM=2)  :'',size(arr2,dim=2)', &
'         write(*,*)''note lower bound is "1"''', &
'         write(*,*)''LBOUND(arr2)      :'',lbound(arr2)', &
'         write(*,*)''LBOUND(arr2)      :'',lbound(arr2)', &
'         ! The upper bound in the last dimension must appear in the', &
'         ! reference to the assumed size array    arr2    at (1)', &
'         !!write(*,*)''UBOUND(arr2)      :'',ubound(arr2)', &
'         write(*,*)''LBOUND(arr2,DIM=1):'',lbound(arr2,dim=1)', &
'         write(*,*)''UBOUND(arr2,DIM=1):'',ubound(arr2,dim=1)', &
'         write(*,*)''LBOUND(arr2,DIM=2):'',lbound(arr2,dim=2)', &
'         !    dim    argument of    ubound    intrinsic at (1) is not', &
'         ! a valid dimension index', &
'         !!write(*,*)''UBOUND(arr2,DIM=2):'',ubound(arr2,dim=2)', &
'         !', &
'         write(*,*)''interfaced''', &
'         !', &
'         write(*,*)''SHAPE(arr)       :'',shape(arr)', &
'         write(*,*)''SIZE(arr)        :'',size(arr)', &
'         write(*,*)''SIZE(arr,DIM=1)  :'',size(arr,dim=1)', &
'         write(*,*)''SIZE(arr,DIM=2)  :'',size(arr,dim=2)', &
'         write(*,*)''note lower bound is "1"''', &
'         write(*,*)''LBOUND(arr)      :'',lbound(arr)', &
'         write(*,*)''LBOUND(arr)      :'',lbound(arr)', &
'         write(*,*)''UBOUND(arr)      :'',ubound(arr)', &
'         write(*,*)''LBOUND(arr,DIM=1):'',lbound(arr,dim=1)', &
'         write(*,*)''UBOUND(arr,DIM=1):'',ubound(arr,dim=1)', &
'         write(*,*)''LBOUND(arr,DIM=2):'',lbound(arr,dim=2)', &
'         write(*,*)''UBOUND(arr,DIM=2):'',ubound(arr,dim=2)', &
'         !', &
'      end subroutine interfaced', &
'      !!', &
'      ! NOTE: If NOINTERFACE(3) had an assumed-shape argument with :', &
'      !       for dimensions it could only be properly called with', &
'      !       an explicit interface', &
'      !!', &
'      subroutine nointerface(arr)', &
'      integer,intent(in) :: arr(3,*)', &
'         write(*,*)''nointerface''', &
'       ! SHAPE(3) CANNOT BE USED ON AN ASSUMED SIZE ARRAY', &
'       !!write(*,*)''SHAPE(arr)       :'',shape(arr)', &
'       !!write(*,*)''SIZE(arr)        :'',size(arr)', &
'         write(*,*)''SIZE(arr,DIM=1)  :'',size(arr,dim=1)', &
'       ! CANNOT DETERMINE SIZE OF ASSUMED SIZE ARRAY LAST DIMENSION', &
'       !!write(*,*)''SIZE(arr,DIM=2)  :'',size(arr,dim=2)', &
'         write(*,*)''note lower bound is "1"''', &
'         write(*,*)''LBOUND(arr)      :'',lbound(arr)', &
'       !!write(*,*)''UBOUND(arr)      :'',ubound(arr)', &
'         write(*,*)''LBOUND(arr,DIM=1):'',lbound(arr,dim=1)', &
'         write(*,*)''UBOUND(arr,DIM=1):'',ubound(arr,dim=1)', &
'         write(*,*)''LBOUND(arr,DIM=2):'',lbound(arr,dim=2)', &
'       !!write(*,*)''UBOUND(arr,DIM=2):'',ubound(arr,dim=2)', &
'      end subroutine nointerface', &
'      !!', &
'      end program demo_size', &
'', &
'  Results:', &
'', &
'          SIZE of simple one-dimensional array=           3', &
'          body', &
'          SHAPE(arr)       :           3          11', &
'          SIZE(arr)        :          33', &
'          SIZE(arr,DIM=1)  :           3', &
'          SIZE(arr,DIM=2)  :          11', &
'          note lower bound is not "1"', &
'          LBOUND(arr)      :           0          -5', &
'          UBOUND(arr)      :           2           5', &
'          LBOUND(arr,DIM=1):           0', &
'          UBOUND(arr,DIM=1):           2', &
'          LBOUND(arr,DIM=2):          -5', &
'          UBOUND(arr,DIM=2):           5', &
'          interfaced assumed-shape arr2ay', &
'          SIZE(arr2,DIM=1)  :           2', &
'          note lower bound is "1"', &
'          LBOUND(arr2)      :           1           1', &
'          LBOUND(arr2)      :           1           1', &
'          LBOUND(arr2,DIM=1):           1', &
'          UBOUND(arr2,DIM=1):           2', &
'          LBOUND(arr2,DIM=2):           1', &
'          interfaced', &
'          SHAPE(arr)       :           3          11', &
'          SIZE(arr)        :          33', &
'          SIZE(arr,DIM=1)  :           3', &
'          SIZE(arr,DIM=2)  :          11', &
'          note lower bound is "1"', &
'          LBOUND(arr)      :           1           1', &
'          LBOUND(arr)      :           1           1', &
'          UBOUND(arr)      :           3          11', &
'          LBOUND(arr,DIM=1):           1', &
'          UBOUND(arr,DIM=1):           3', &
'          LBOUND(arr,DIM=2):           1', &
'          UBOUND(arr,DIM=2):          11', &
'          nointerface', &
'          SIZE(arr,DIM=1)  :           3', &
'          note lower bound is "1"', &
'          LBOUND(arr)      :           1           1', &
'          LBOUND(arr,DIM=1):           1', &
'          UBOUND(arr,DIM=1):           3', &
'          LBOUND(arr,DIM=2):           1', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument - Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  SHAPE(3), [RESHAPE(3)])(RESHAPE)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                size(3fortran)', &
'']

shortname="size"
call process()


case('185','spacing')

textblock=[character(len=256) :: &
'', &
'spacing(3fortran)                                            spacing(3fortran)', &
'', &
'NAME', &
'  SPACING(3) - [MODEL_COMPONENTS] Smallest distance between two numbers of a', &
'  given type', &
'', &
'SYNTAX', &
'  result = spacing(x)', &
'', &
'DESCRIPTION', &
'  Determines the distance between the argument X and the nearest adjacent', &
'  number of the same type.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real.', &
'', &
'RETURNS', &
'  The result is of the same type as the input argument X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_spacing', &
'      implicit none', &
'      integer, parameter :: sgl = selected_real_kind(p=6, r=37)', &
'      integer, parameter :: dbl = selected_real_kind(p=13, r=200)', &
'', &
'         write(*,*) spacing(1.0_sgl)      ! "1.1920929e-07"          on i686', &
'         write(*,*) spacing(1.0_dbl)      ! "2.220446049250313e-016" on i686', &
'      end program demo_spacing', &
'', &
'  Results:', &
'', &
'            1.19209290E-07', &
'            2.2204460492503131E-016', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), TINY(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022             spacing(3fortran)', &
'']

shortname="spacing"
call process()


case('186','spread')

textblock=[character(len=256) :: &
'', &
'spread(3fortran)                                              spread(3fortran)', &
'', &
'NAME', &
'  SPREAD(3) - [ARRAY CONSTRUCTION] Add a dimension to an array', &
'', &
'SYNTAX', &
'  result = spread(source, dim, ncopies)', &
'', &
'        TYPE(kind=KIND) function spread(source, dim, ncopies)', &
'', &
'         TYPE(kind=KIND)    :: source(..)', &
'         integer,intent(in) :: dim', &
'         integer,intent(in) :: ncopies', &
'', &
'DESCRIPTION', &
'  Replicates a SOURCE array NCOPIES times along a specified dimension DIM.', &
'', &
'  If SOURCE is scalar, the shape of the result is (MAX (NCOPIES, 0)). and each', &
'  element of the result has a value equal to SOURCE.', &
'', &
'ARGUMENTS', &
'  o  SOURCE : Shall be a scalar or an array of any type and a rank less than', &
'     fifteen.', &
'', &
'  o  DIM : Shall be a scalar of type integer with a value in the range from 1', &
'     to N+1, where N equals the rank of SOURCE.', &
'', &
'  o  NCOPIES : Shall be a scalar of type integer.', &
'', &
'RETURNS', &
'  The result is an array of the same type as SOURCE and has rank N+1 where N', &
'  equals the rank of SOURCE.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_spread', &
'      implicit none', &
'      integer :: a = 1, b(2) = [ 1, 2 ]', &
'', &
'         write(*,*) spread(a, 1, 2)            ! "1 1"', &
'         write(*,*) spread(b, 1, 2)            ! "1 1 2 2"', &
'', &
'      end program demo_spread', &
'', &
'      program example_spread', &
'      !  Author:', &
'      !    John Burkardt, 03 July 2006', &
'      implicit none', &
'', &
'      integer ( kind = 4 ) a1(4,3)', &
'      integer ( kind = 4 ) a2(3,4)', &
'      integer i', &
'      integer ( kind = 4 ) s', &
'      integer ( kind = 4 ) v(4)', &
'', &
'         write(*,''(a)'' ) '' ''', &
'         write(*,''(a)'' ) ''TEST_SPREAD''', &
'         write(*,''(a)'' ) ''  SPREAD is a FORTRAN90 function which replicates''', &
'         write(*,''(a)'' ) ''  an array by adding a dimension.''', &
'         write(*,''(a)'' ) '' ''', &
'', &
'         s = 99', &
'', &
'         write(*, ''(a,i6)'' ) ''  Suppose we have a scalar S = '', s', &
'         write(*, ''(a)'' ) '' ''', &
'', &
'         v = spread ( s, 1, 4 )', &
'', &
'         write(*,''(a)'' ) ''  V = spread ( s, 1, 4 )''', &
'         write(*,''(a)'' ) '' ''', &
'         write(*,''(a)'' ) ''  adds a new dimension (1) of extent 4''', &
'         write(*,''(a)'' ) '' ''', &
'         write(*,''(4i6)'' ) v(1:4)', &
'         write(*,''(a)'' ) '' ''', &
'         write(*,''(a)'' ) ''  Now first reset V to (1,2,3,4)''', &
'         v = [ 1, 2, 3, 4 ]', &
'', &
'         a1 = spread ( v, 2, 3 )', &
'', &
'         write (*, ''(a)'' ) '' ''', &
'         write (*, ''(a)'' ) ''  A1 = spread ( v, 2, 3 )''', &
'         write (*, ''(a)'' ) '' ''', &
'         write (*, ''(a)'' ) ''  adds a new dimension (2) of extent 3''', &
'         write (*, ''(a)'' ) '' ''', &
'         do i = 1, 4', &
'           write ( *, ''(3i6)'' ) a1(i,1:3)', &
'         end do', &
'', &
'         a2 = spread ( v, 1, 3 )', &
'', &
'         write (*, ''(a)'' ) '' ''', &
'         write (*, ''(a)'' ) ''  A2 = spread ( v, 1, 3 )''', &
'         write (*, ''(a)'' ) '' ''', &
'         write (*, ''(a)'' ) ''  adds a new dimension (1) of extent 3''', &
'         write (*, ''(a)'' ) '' ''', &
'         do i = 1, 3', &
'           write(*, ''(4i6)'' ) a2(i,1:4)', &
'         end do', &
'      end program example_spread', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  MERGE(3), PACK(3), UNPACK(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              spread(3fortran)', &
'']

shortname="spread"
call process()


case('187','sqrt')

textblock=[character(len=256) :: &
'', &
'sqrt(3fortran)                                                  sqrt(3fortran)', &
'', &
'NAME', &
'  SQRT(3) - [MATHEMATICS] Square-root function', &
'', &
'SYNTAX', &
'  result = sqrt(x)', &
'', &
'         TYPE(kind=KIND) elemental function sqrt(x) result(value)', &
'         TYPE(kind=KIND),intent(in) :: x', &
'         TYPE(kind=KIND) :: value', &
'', &
'  Where TYPE may be real or complex and KIND may be any kind valid for the', &
'  declared type.', &
'', &
'DESCRIPTION', &
'  SQRT(X) computes the principal square root of X.', &
'', &
'  In mathematics, a square root of a number X is a number Y such that Y*Y = X.', &
'', &
'  The number whose square root is being considered is known as the radicand.', &
'', &
'  Every nonnegative number x has two square roots of the same unique', &
'  magnitude, one positive and one negative. The nonnegative square root is', &
'  called the principal square root.', &
'', &
'  The principal square root of 9 is 3, for example, even though (-3)*(-3) is', &
'  also 9.', &
'', &
'  A real radicand must be positive.', &
'', &
'  Square roots of negative numbers are a special case of complex numbers,', &
'  where the components of the radicand need not be positive in order to have a', &
'  valid square root.', &
'', &
'ARGUMENTS', &
'  o  X : If X is real its value must be greater than or equal to zero.  The', &
'     type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value is of type real or complex. The kind type parameter is the', &
'  same as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_sqrt', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'       & real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x, x2', &
'      complex :: z, z2', &
'', &
'         x = 2.0_real64', &
'         z = (1.0, 2.0)', &
'         write(*,*)x,z', &
'', &
'         x2 = sqrt(x)', &
'         z2 = sqrt(z)', &
'         write(*,*)x2,z2', &
'', &
'         x2 = x**0.5', &
'         z2 = z**0.5', &
'         write(*,*)x2,z2', &
'', &
'      end program demo_sqrt', &
'', &
'  Results:', &
'', &
'        2.0000000000000000    (1.00000000,2.00000000)', &
'        1.4142135623730951    (1.27201962,0.786151350)', &
'        1.4142135623730951    (1.27201962,0.786151350)', &
'', &
'STANDARD', &
'  FORTRAN 77 and later', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022                sqrt(3fortran)', &
'']

shortname="sqrt"
call process()


case('188','storage_size')

textblock=[character(len=256) :: &
'', &
'storage_size(3fortran)                                  storage_size(3fortran)', &
'', &
'NAME', &
'  STORAGE_SIZE(3) - [BIT:INQUIRY] Storage size in bits', &
'', &
'SYNTAX', &
'  result = storage_size(a, kind)', &
'', &
'DESCRIPTION', &
'  Returns the storage size of argument A in bits.', &
'', &
'ARGUMENTS', &
'  o  A : Shall be a scalar or array of any type.', &
'', &
'  o  KIND : (Optional) shall be a scalar integer constant expression.', &
'', &
'RETURNS', &
'  The result is a scalar integer with the kind type parameter specified by', &
'  KIND (or default integer type if KIND is missing). The result value is the', &
'  size expressed in bits for an element of an array that has the dynamic type', &
'  and type parameters of A.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_storage_size', &
'      implicit none', &
'         write(*,*)''size of integer       '',storage_size(0)', &
'         write(*,*)''size of real          '',storage_size(0.0)', &
'         write(*,*)''size of logical       '',storage_size(.true.)', &
'         write(*,*)''size of complex       '',storage_size((0.0,0.0))', &
'         write(*,*)''size of integer array '',storage_size([0,1,2,3,4,5,6,7,8,9])', &
'      end program demo_storage_size', &
'', &
'  Results:', &
'', &
'          size of integer                 32', &
'          size of real                    32', &
'          size of logical                 32', &
'          size of complex                 64', &
'          size of integer array           32', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  C_SIZEOF(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022        storage_size(3fortran)', &
'']

shortname="storage_size"
call process()


case('189','sum')

textblock=[character(len=256) :: &
'', &
'sum(3fortran)                                                    sum(3fortran)', &
'', &
'NAME', &
'  SUM(3) - [ARRAY REDUCTION] sum the elements of an array', &
'', &
'SYNTAX', &
'  result = sum(array[, mask]) result = sum(array, dim[, mask])', &
'', &
'DESCRIPTION', &
'  Adds the elements of ARRAY along dimension DIM if the corresponding element', &
'  in MASK is TRUE.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array of type integer, real or complex.', &
'', &
'  o  DIM : (Optional) shall be a scalar of type integer with a value in the', &
'     range from 1 to n, where n equals the rank of ARRAY.', &
'', &
'  o  MASK : (Optional) shall be of type logical and either be a scalar or an', &
'     array of the same shape as ARRAY.', &
'', &
'RETURNS', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM(3) is absent, a scalar with the sum of all elements in ARRAY is', &
'  returned. Otherwise, an array of rank n-1, where n equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program simple_sum', &
'      implicit none', &
'      integer :: x(5) = [ 1, 2, 3, 4, 5 ]', &
'         print *, sum(x)                        ! all elements, sum = 15', &
'         print *, sum(x, mask=mod(x, 2)==1)     ! odd elements, sum = 9', &
'      end program simple_sum', &
'', &
'  Demonstrate Fortran 90 SUM function with MASK option', &
'', &
'      program demo_sum', &
'      ! John Mahaffy  2/16/96', &
'      implicit none', &
'      integer nd, ndh, nduh, j', &
'      parameter (nd=10,ndh=nd/2, nduh=nd-ndh)', &
'      real csum, cpsum, cbpsum', &
'      real, dimension(nd):: c=[(j, j=-1,nd-2)], b', &
'      data b/ndh*-1.0, nduh*2.0/', &
'         csum= sum(c(1:nd))', &
'         cpsum= sum (c(1:nd), mask=c.gt.0)', &
'         cbpsum= sum(c(1:nd), mask=b.gt.0.0)', &
'         print *, ''Sum of all elements in c = '', csum', &
'         print *, ''Sum of Positive elements in c = '', cpsum', &
'         print *, ''Sum of elements in c when corresponding elements in b>0'', &', &
'         & '' ='', cbpsum', &
'      end program demo_sum', &
'', &
'  Results:', &
'', &
'       Sum of all elements in c =    35.0000000', &
'       Sum of Positive elements in c =    36.0000000', &
'       Sum of elements in c when corresponding elements in b>0 =   30.0000000', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  intrinsics', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 sum(3fortran)', &
'']

shortname="sum"
call process()


case('190','system_clock')

textblock=[character(len=256) :: &
'', &
'system_clock(3fortran)                                  system_clock(3fortran)', &
'', &
'NAME', &
'  SYSTEM_CLOCK(3) - [SYSTEM:TIME] Return numeric data from a real-time clock.', &
'', &
'SYNTAX', &
'  subroutine system_clock(count, count_rate, count_max)', &
'', &
'         integer,intent(out),optional  :: count', &
'         integer,intent(out),optional  :: count_rate', &
'          ! or !', &
'         real,intent(out),optional     :: count_rate', &
'         integer,intent(out),optional  :: count_max', &
'', &
'DESCRIPTION', &
'  SYSTEM_CLOCK lets you measure durations of time with the precision of the', &
'  smallest time increment generally available on a system by returning', &
'  processor-dependent values based on the current value of the processor', &
'  clock. The CLOCK value is incremented by one for each clock count until the', &
'  value COUNT_MAX is reached and is then reset to zero at the next count.', &
'  CLOCK therefore is a modulo value that lies in the range 0 TO COUNT_MAX.', &
'  COUNT_RATE and COUNT_MAX are assumed constant (even though CPU rates can', &
'  vary on a single platform).', &
'', &
'  COUNT_RATE is system dependent and can vary depending on the kind of the', &
'  arguments.', &
'', &
'  If there is no clock, or querying the clock fails, COUNT is set to', &
'  -HUGE(COUNT), and COUNT_RATE and COUNT_MAX are set to zero.', &
'', &
'  SYSTEM_CLOCK is typically used to measure short time intervals (system', &
'  clocks may be 24-hour clocks or measure processor clock ticks since boot,', &
'  for example). It is most often used for measuring or tracking the time spent', &
'  in code blocks in lieu of using profiling tools.', &
'', &
'ARGUMENTS', &
'  o  COUNT : (optional) shall be an integer scalar. It is assigned a', &
'     processor-dependent value based on the current value of the processor', &
'     clock, or -HUGE(COUNT) if there is no clock. The processor-dependent', &
'     value is incremented by one for each clock count until the value', &
'     COUNT_MAX is reached and is reset to zero at the next count. It lies in', &
'     the range 0 to COUNT_MAX if there is a clock.', &
'', &
'  o  COUNT_RATE : (optional) shall be an integer or real scalar. It is', &
'     assigned a processor-dependent approximation to the number of processor', &
'     clock counts per second, or zero if there is no clock.', &
'', &
'  o  COUNT_MAX : (optional) shall be an integer scalar. It is assigned the', &
'     maximum value that COUNT can have, or zero if there is no clock.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_system_clock', &
'      implicit none', &
'      integer, parameter :: wp = kind(1.0d0)', &
'      integer :: count, count_rate, count_max', &
'      integer :: start, finish', &
'      real    :: time_read', &
'', &
'         call system_clock(count, count_rate, count_max)', &
'         write(*,*) count, count_rate, count_max', &
'', &
'         call system_clock(start, count_rate)', &
'         ! <<<< code to time', &
'         call system_clock(finish)', &
'         time_read=(finish-start)/real(count_rate,wp)', &
'         write(*,''(a30,1x,f7.4,1x,a)'') ''time * : '', time_read, '' seconds''', &
'', &
'      end program demo_system_clock', &
'', &
'  If the processor clock is a 24-hour clock that registers time at', &
'  approximately 18.20648193 ticks per second, at 11:30 A.M. the reference', &
'', &
'            call system_clock (count = c, count_rate = r, count_max = m)', &
'', &
'  defines', &
'', &
'            C = (11*3600+30*60)*18.20648193 = 753748,', &
'            R = 18.20648193, and', &
'            M = 24*3600*18.20648193-1 = 1573039.', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DATE_AND_TIME(3), CPU_TIME(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022        system_clock(3fortran)', &
'']

shortname="system_clock"
call process()


case('191','tan')

textblock=[character(len=256) :: &
'', &
'tan(3fortran)                                                    tan(3fortran)', &
'', &
'NAME', &
'  TAN(3) - [MATHEMATICS:TRIGONOMETRIC] Tangent function', &
'', &
'SYNTAX', &
'  result = tan(x)', &
'', &
'DESCRIPTION', &
'  TAN(X) computes the tangent of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value has the same type and kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_tan', &
'      use, intrinsic :: iso_fortran_env, only : real_kinds, &', &
'      & real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 0.165_real64', &
'           write(*,*)x, tan(x)', &
'      end program demo_tan', &
'', &
'  Results:', &
'', &
'           0.16500000000000001       0.16651386310913616', &
'', &
'STANDARD', &
'  FORTRAN 77 and later. For a complex argument, Fortran 2008 or later.', &
'', &
'SEE ALSO', &
'  ATAN(3), COS(3), SIN(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                 tan(3fortran)', &
'']

shortname="tan"
call process()


case('192','tanh')

textblock=[character(len=256) :: &
'', &
'tanh(3fortran)                                                  tanh(3fortran)', &
'', &
'NAME', &
'  TANH(3) - [MATHEMATICS:TRIGONOMETRIC] Hyperbolic tangent function', &
'', &
'SYNTAX', &
'  x = tanh(x)', &
'', &
'DESCRIPTION', &
'  TANH(X) computes the hyperbolic tangent of X.', &
'', &
'ARGUMENTS', &
'  o  X : The type shall be real or complex.', &
'', &
'RETURNS', &
'  The return value has same type and kind as X. If X is complex, the imaginary', &
'  part of the result is in radians. If X is real, the return value lies in the', &
'  range', &
'', &
'            -1 <= tanh(x) <= 1.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_tanh', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'      & real_kinds, real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 2.1_real64', &
'         write(*,*)x, tanh(x)', &
'      end program demo_tanh', &
'', &
'  Results:', &
'', &
'            2.1000000000000001       0.97045193661345386', &
'', &
'STANDARD', &
'  FORTRAN 77 and later, for a complex argument Fortran 2008 or later', &
'', &
'SEE ALSO', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  ATANH(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                tanh(3fortran)', &
'']

shortname="tanh"
call process()


case('193','this_image')

textblock=[character(len=256) :: &
'', &
'this_image(3fortran)                                      this_image(3fortran)', &
'', &
'NAME', &
'  THIS_IMAGE(3) - [COLLECTIVE] Cosubscript index of this image', &
'', &
'SYNTAX', &
'  result = this_image()', &
'', &
'  or', &
'', &
'      ```fortran', &
'      result = this_image(distance)', &
'', &
'  or', &
'', &
'      result = this_image(coarray, dim)', &
'', &
'DESCRIPTION', &
'  Returns the cosubscript for this image.', &
'', &
'ARGUMENTS', &
'  o  DISTANCE : (optional, INTENT(IN)) Nonnegative scalar integer (not', &
'     permitted together with COARRAY).', &
'', &
'  o  COARRAY : Coarray of any type (optional; if DIM present, required).', &
'', &
'  o  DIM : default integer scalar (optional). If present, DIM shall be between', &
'     one and the corank of COARRAY.', &
'', &
'RETURNS', &
'  Default integer. If COARRAY is not present, it is scalar; if DISTANCE is not', &
'  present or has value 0, its value is the image index on the invoking image', &
'  for the current team, for values smaller or equal distance to the initial', &
'  team, it returns the image index on the ancestor team which has a distance', &
'  of DISTANCE from the invoking team. If DISTANCE is larger than the distance', &
'  to the initial team, the image index of the initial team is returned.', &
'  Otherwise when the COARRAY is present, if DIM is not present, a rank-1 array', &
'  with corank elements is returned, containing the cosubscripts for COARRAY', &
'  specifying the invoking image. If DIM is present, a scalar is returned, with', &
'  the value of the DIM element of THIS_IMAGE(COARRAY).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_this_image', &
'      implicit none', &
'      integer :: value[*]', &
'      integer :: i', &
'         value = this_image()', &
'         sync all', &
'         if (this_image() == 1) then', &
'            do i = 1, num_images()', &
'               write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]', &
'            end do', &
'         endif', &
'      end program demo_this_image', &
'', &
'  Results:', &
'', &
'         value[1] is 1', &
'', &
'STANDARD', &
'  Fortran 2008 and later. With DISTANCE argument, TS 18508 or later', &
'', &
'SEE ALSO', &
'  NUM_IMAGES(3), IMAGE_INDEX(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022          this_image(3fortran)', &
'']

shortname="this_image"
call process()


case('194','tiny')

textblock=[character(len=256) :: &
'', &
'tiny(3fortran)                                                  tiny(3fortran)', &
'', &
'NAME', &
'  TINY(3) - [NUMERIC MODEL] Smallest positive number of a real kind', &
'', &
'SYNTAX', &
'  result = tiny(x) real(kind=KIND) function(x) real(kind=KIND) :: x', &
'', &
'  where KIND may be any kind supported by type real', &
'', &
'DESCRIPTION', &
'  TINY(X) returns the smallest positive (non zero) number of the type and kind', &
'  of X.', &
'', &
'ARGUMENTS', &
'  o  X : Shall be of type real.', &
'', &
'RETURNS', &
'  The smallest positive value for the real type of the specified kind.', &
'', &
'  The return value is of the same type and kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_tiny', &
'      implicit none', &
'         print *, ''default real is from'', tiny(0.0), ''to'',huge(0.0)', &
'         print *, ''doubleprecision is from '', tiny(0.0d0), ''to'',huge(0.0d0)', &
'      end program demo_tiny', &
'', &
'  Results:', &
'', &
'       default real is from 1.17549435E-38 to 3.40282347E+38', &
'       doubleprecision is from 2.2250738585072014E-308 to', &
'       1.7976931348623157E+308', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                tiny(3fortran)', &
'']

shortname="tiny"
call process()


case('195','trailz')

textblock=[character(len=256) :: &
'', &
'trailz(3fortran)                                              trailz(3fortran)', &
'', &
'NAME', &
'  TRAILZ(3) - [BIT:COUNT] Number of trailing zero bits of an integer', &
'', &
'SYNTAX', &
'  result = trailz(i) integer :: result integer(kind=NNN),intent(in) :: i', &
'', &
'DESCRIPTION', &
'  TRAILZ(3) returns the number of trailing zero bits of an integer value', &
'', &
'ARGUMENTS', &
'  o  I : Shall be of type integer.', &
'', &
'RETURNS', &
'  The type of the return value is the default integer. If all the bits of I', &
'  are zero, the result value is BIT_SIZE(I).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_trailz', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'      & int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int64) :: i, value', &
'         write(*,*)''Default integer:''', &
'         write(*,*)''bit_size='',bit_size(0)', &
'         write(*,''(1x,i3,1x,i3,1x,b0)'')-1,trailz(1),-1', &
'         write(*,''(1x,i3,1x,i3,1x,b0)'')0,trailz(0),0', &
'         write(*,''(1x,i3,1x,i3,1x,b0)'')1,trailz(1),1', &
'         write(*,''(" huge(0)=",i0,1x,i0,1x,b0)'') &', &
'         & huge(0),trailz(huge(0)),huge(0)', &
'         write(*,*)', &
'         write(*,*)''integer(kind=int64):''', &
'', &
'         do i=-1,62,5', &
'            value=2**i', &
'            write(*,''(1x,i19,1x,i3)'')value,trailz(value)', &
'         enddo', &
'         value=huge(i)', &
'         write(*,''(1x,i19,1x,i3,"(huge(0_int64))")'')value,trailz(value)', &
'', &
'         do i=-1,62,5', &
'            value=2**i', &
'            write(*,''(1x,i3,2x,b64.64)'')i,value', &
'         enddo', &
'         value=huge(i)', &
'         write(*,''(1x,a,1x,b64.64)'') "huge",value', &
'', &
'      end program demo_trailz', &
'', &
'  Results:', &
'', &
'       Default integer:', &
'       bit_size=          32', &
'        -1   0 11111111111111111111111111111111', &
'         0  32 0', &
'         1   0 1', &
'       huge(0)=2147483647 0 1111111111111111111111111111111', &
'', &
'       integer(kind=int64):', &
'                         0  64', &
'                        16   4', &
'                       512   9', &
'                     16384  14', &
'                    524288  19', &
'                  16777216  24', &
'                 536870912  29', &
'               17179869184  34', &
'              549755813888  39', &
'            17592186044416  44', &
'           562949953421312  49', &
'         18014398509481984  54', &
'        576460752303423488  59', &
'       9223372036854775807   0(huge(0_int64))', &
'        -1  0000000000000000000000000000000000000000000000000000000000000000', &
'         4  0000000000000000000000000000000000000000000000000000000000010000', &
'         9  0000000000000000000000000000000000000000000000000000001000000000', &
'        14  0000000000000000000000000000000000000000000000000100000000000000', &
'        19  0000000000000000000000000000000000000000000010000000000000000000', &
'        24  0000000000000000000000000000000000000001000000000000000000000000', &
'        29  0000000000000000000000000000000000100000000000000000000000000000', &
'        34  0000000000000000000000000000010000000000000000000000000000000000', &
'        39  0000000000000000000000001000000000000000000000000000000000000000', &
'        44  0000000000000000000100000000000000000000000000000000000000000000', &
'        49  0000000000000010000000000000000000000000000000000000000000000000', &
'        54  0000000001000000000000000000000000000000000000000000000000000000', &
'        59  0000100000000000000000000000000000000000000000000000000000000000', &
'       huge 0111111111111111111111111111111111111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008 and later', &
'', &
'SEE ALSO', &
'  BIT_SIZE(3), POPCNT(3), POPPAR(3), LEADZ(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              trailz(3fortran)', &
'']

shortname="trailz"
call process()


case('196','transfer')

textblock=[character(len=256) :: &
'', &
'transfer(3fortran)                                          transfer(3fortran)', &
'', &
'NAME', &
'  TRANSFER(3) - [TYPE:MOLD] Transfer bit patterns', &
'', &
'SYNTAX', &
'  result = transfer(source, mold, size)', &
'', &
'DESCRIPTION', &
'  Interprets the bitwise representation of SOURCE in memory as if it is the', &
'  representation of a variable or array of the same type and type parameters', &
'  as MOLD.', &
'', &
'  This is approximately equivalent to the C concept of "casting" one type to', &
'  another.', &
'', &
'ARGUMENTS', &
'  o  SOURCE : Shall be a scalar or an array of any type.', &
'', &
'  o  MOLD : Shall be a scalar or an array of any type.', &
'', &
'  o  SIZE : (Optional) shall be a scalar of type integer.', &
'', &
'RETURNS', &
'  The result has the same type as MOLD, with the bit level representation of', &
'  SOURCE. If SIZE is present, the result is a one-dimensional array of length', &
'  SIZE. If SIZE is absent but MOLD is an array (of any size or shape), the', &
'  result is a one-dimensional array of the minimum length needed to contain', &
'  the entirety of the bitwise representation of SOURCE.  If SIZE is absent and', &
'  MOLD is a scalar, the result is a scalar.', &
'', &
'  If the bitwise representation of the result is longer than that of SOURCE,', &
'  then the leading bits of the result correspond to those of SOURCE and any', &
'  trailing bits are filled arbitrarily.', &
'', &
'  When the resulting bit representation does not correspond to a valid', &
'  representation of a variable of the same type as MOLD, the results are', &
'  undefined, and subsequent operations on the result cannot be guaranteed to', &
'  produce sensible behavior. For example, it is possible to create logical', &
'  variables for which VAR and .not. var both appear to be true.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_transfer', &
'      use,intrinsic :: iso_fortran_env, only : int32, real32', &
'      integer(kind=int32) :: i = 2143289344', &
'      real(kind=real32)   :: x', &
'      character(len=10)   :: string', &
'      character(len=1)    :: chars(10)', &
'         x=transfer(i, 1.0)    ! prints "nan" on i686', &
'         ! the bit patterns are the same', &
'         write(*,''(b0,1x,g0)'')x,x ! create a NaN', &
'         write(*,''(b0,1x,g0)'')i,i', &
'', &
'         ! a string to an array of characters', &
'         string=''abcdefghij''', &
'         chars=transfer(string,chars)', &
'         write(*,''(*("[",a,"]":,1x))'')string', &
'         write(*,''(*("[",a,"]":,1x))'')chars', &
'      end program demo_transfer', &
'', &
'  Results:', &
'', &
'         1111111110000000000000000000000 NaN', &
'         1111111110000000000000000000000 2143289344', &
'         [abcdefghij]', &
'         [a] [b] [c] [d] [e] [f] [g] [h] [i] [j]', &
'', &
'COMMENTS', &
'  Joe Krahn: Fortran uses MOLDING rather than CASTING.', &
'', &
'  Casting, as in C, is an in-place reinterpretation. A cast is a device that', &
'  is built around an object to change its shape.', &
'', &
'  Fortran TRANSFER reinterprets data out-of-place. It can be considered', &
'  MOLDING rather than casting. A MOLD is a device that confers a shape onto an', &
'  object placed into it.', &
'', &
'  The advantage of molding is that data is always valid in the context of the', &
'  variable that holds it. For many cases, a decent compiler should optimize', &
'  TRANSFER into a simple assignment.', &
'', &
'  There are disadvantages of this approach. It is problematic to define a', &
'  union of data types because you must know the largest data object, which can', &
'  vary by compiler or compile options. In many cases, an EQUIVALENCE would be', &
'  far more effective, but Fortran Standards committees seem oblivious to the', &
'  benefits of EQUIVALENCEs when used sparingly.', &
'', &
'STANDARD', &
'  Fortran 90 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022            transfer(3fortran)', &
'']

shortname="transfer"
call process()


case('197','transpose')

textblock=[character(len=256) :: &
'', &
'transpose(3fortran)                                        transpose(3fortran)', &
'', &
'NAME', &
'  TRANSPOSE(3) - [ARRAY MANIPULATION] Transpose an array of rank two', &
'', &
'SYNTAX', &
'  result = transpose(matrix)', &
'', &
'DESCRIPTION', &
'  Transpose an array of rank two.', &
'', &
'  A array is transposed by interchanging the rows and columns of the given', &
'  matrix. That is, element (i, j) of the result has the value of element(j, i)', &
'  for all (i, j).', &
'', &
'ARGUMENTS', &
'  o  MATRIX : The array to transpose, which shall be of any type and have a', &
'     rank of two.', &
'', &
'RETURNS', &
'  The transpose of the input array. The result has the same type as MATRIX,', &
'  and has shape [ m, n ] if MATRIX has shape [ n, m ].', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_transpose', &
'      implicit none', &
'      integer,save :: xx(3,5)= reshape([&', &
'          1,  2,  3,  4,  5,    &', &
'         10, 20, 30, 40, 50,    &', &
'         11, 22, 33, 44, -1055  &', &
'       ],shape(xx),order=[2,1])', &
'', &
'      call print_matrix_int(''xx array:'',xx)', &
'      call print_matrix_int(''xx array transposed:'',transpose(xx))', &
'', &
'      contains', &
'', &
'      subroutine print_matrix_int(title,arr)', &
'      ! print small 2d integer arrays in row-column format', &
'      implicit none', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)           :: arr(:,:)', &
'      integer                      :: i', &
'      character(len=:),allocatable :: biggest', &
'         write(*,*)trim(title)  ! print title', &
'         biggest=''           ''  ! make buffer to write integer into', &
'         ! find how many characters to use for integers', &
'         write(biggest,''(i0)'')ceiling(log10(real(maxval(abs(arr)))))+2', &
'         ! use this format to write a row', &
'         biggest=''(" > [",*(i''//trim(biggest)//'':,","))''', &
'         ! print one row of array at a time', &
'         do i=1,size(arr,dim=1)', &
'            write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'            write(*,''(" ]")'')', &
'         enddo', &
'      end subroutine print_matrix_int', &
'', &
'      end program demo_transpose', &
'', &
'  Results:', &
'', &
'          xx array:', &
'          > [     1,     2,     3,     4,     5 ]', &
'          > [    10,    20,    30,    40,    50 ]', &
'          > [    11,    22,    33,    44, -1055 ]', &
'          xx array transposed:', &
'          > [     1,    10,    11 ]', &
'          > [     2,    20,    22 ]', &
'          > [     3,    30,    33 ]', &
'          > [     4,    40,    44 ]', &
'          > [     5,    50, -1055 ]', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022           transpose(3fortran)', &
'']

shortname="transpose"
call process()


case('198','trim')

textblock=[character(len=256) :: &
'', &
'trim(3fortran)                                                  trim(3fortran)', &
'', &
'NAME', &
'  TRIM(3) - [CHARACTER:WHITESPACE] Remove trailing blank characters of a', &
'  string', &
'', &
'SYNTAX', &
'  result = trim(string)', &
'', &
'DESCRIPTION', &
'  Removes trailing blank characters of a string.', &
'', &
'ARGUMENTS', &
'  o  STRING : Shall be a scalar of type character.', &
'', &
'RETURNS', &
'  A scalar of type character which length is that of STRING less the number of', &
'  trailing blanks.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_trim', &
'      implicit none', &
'      character(len=10), parameter :: s = "gfortran  "', &
'         write(*,*) len(s), len(trim(s))  ! "10 8", with/without trailing blanks', &
'', &
'         ! with/without trailing blanks', &
'         write(*,*) len(s), len(trim(''   leading''))', &
'         write(*,*) len(s), len(trim(''   trailing    ''))', &
'         write(*,*) len(s), len(trim(''               ''))', &
'', &
'      end program demo_trim', &
'', &
'  Results:', &
'', &
'            10           8', &
'            10          10', &
'            10          11', &
'            10           0', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022                trim(3fortran)', &
'']

shortname="trim"
call process()


case('199','ubound')

textblock=[character(len=256) :: &
'', &
'ubound(3fortran)                                              ubound(3fortran)', &
'', &
'NAME', &
'  UBOUND(3) - [ARRAY INQUIRY] Upper dimension bounds of an array', &
'', &
'SYNTAX', &
'  result = ubound(array, dim, kind)', &
'', &
'DESCRIPTION', &
'  Returns the upper bounds of an array, or a single upper bound along the DIM', &
'  dimension.', &
'', &
'ARGUMENTS', &
'  o  ARRAY : Shall be an array, of any type.', &
'', &
'  o  DIM : (Optional) Shall be a scalar integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'  If DIM is absent, the result is an array of the upper bounds of ARRAY.', &
'', &
'  If DIM is present, the result is a scalar corresponding to the upper bound', &
'  of the array along that dimension.', &
'', &
'  If ARRAY is an expression rather than a whole array or array structure', &
'  component, or if it has a zero extent along the relevant dimension, the', &
'  upper bound is taken to be the number of elements along the relevant', &
'  dimension.', &
'', &
'EXAMPLES', &
'  Note this function should not be used on assumed-size arrays or in any', &
'  function without an explicit interface. Errors can occur if there is no', &
'  interface defined.', &
'', &
'  Sample program', &
'', &
'      ! program demo_ubound', &
'      module m2_bounds', &
'      implicit none', &
'', &
'      contains', &
'', &
'      subroutine msub(arr)', &
'      !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array', &
'      integer,intent(in) :: arr(:)', &
'         write(*,*)''MSUB: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'         & ''SIZE='',size(arr)', &
'      end subroutine msub', &
'', &
'      end module m2_bounds', &
'', &
'      use m2_bounds, only : msub', &
'      implicit none', &
'      interface', &
'         subroutine esub(arr)', &
'         integer,intent(in) :: arr(:)', &
'         end subroutine esub', &
'      end interface', &
'      integer :: arr(-10:10)', &
'         write(*,*)''MAIN: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'         & ''SIZE='',size(arr)', &
'         call csub()', &
'         call msub(arr)', &
'         call esub(arr)', &
'      contains', &
'      subroutine csub', &
'         write(*,*)''CSUB: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'         & ''SIZE='',size(arr)', &
'      end subroutine csub', &
'', &
'      end', &
'', &
'      subroutine esub(arr)', &
'      implicit none', &
'      integer,intent(in) :: arr(:)', &
'         ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE', &
'         ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)', &
'         write(*,*)''ESUB: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'         & ''SIZE='',size(arr)', &
'      end subroutine esub', &
'      !end program demo_ubound', &
'', &
'  Results:', &
'', &
'        MAIN: LOWER=         -10 UPPER=          10 SIZE=          21', &
'        CSUB: LOWER=         -10 UPPER=          10 SIZE=          21', &
'        MSUB: LOWER=           1 UPPER=          21 SIZE=          21', &
'        ESUB: LOWER=           1 UPPER=          21 SIZE=          21', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument Fortran 2003 and later', &
'', &
'SEE ALSO', &
'                              September 19, 2022              ubound(3fortran)', &
'']

shortname="ubound"
call process()


case('200','unpack')

textblock=[character(len=256) :: &
'', &
'unpack(3fortran)                                              unpack(3fortran)', &
'', &
'NAME', &
'  UNPACK(3) - [ARRAY CONSTRUCTION] scatter the elements of a vector into an', &
'  array using a mask', &
'', &
'SYNTAX', &
'  result = unpack(vector, mask, field)', &
'', &
'       type(TYPE(kind=KIND)),intent(in) :: vector(:)', &
'       logical,intent(in)               :: mask(..)', &
'       type(TYPE(kind=KIND)),intent(in) :: field(..)', &
'       type(TYPE(kind=KIND))            :: result(..)', &
'', &
'DESCRIPTION', &
'  Scatter the elements of VECTOR into a copy of an array FIELD of any rank', &
'  using .true. values from MASK in array element order to specify placement of', &
'  the VECTOR values.', &
'', &
'  So a copy of FIELD is generated with select elements replaced with values', &
'  from VECTOR. This allows for complex replacement patterns that would be', &
'  difficult when using array syntax or multiple assignment statements,', &
'  particularly when the replacements are conditional.', &
'', &
'ARGUMENTS', &
'  o  VECTOR : New values to place into specified locations in FIELD.  Shall be', &
'     an array of any type and rank one. It shall have at least as many', &
'     elements as MASK has .true. values.', &
'', &
'  o  MASK : Shall be an array of type logical that specifies which values in', &
'     FIELD are to be replaced with values from VECTOR.', &
'', &
'  o  FIELD : The original data to be edited. Shall be of the same type and', &
'     type parameters as VECTOR and shall be conformable with MASK.', &
'', &
'RETURNS', &
'  The result is an array of the same type and type parameters as VECTOR and', &
'  the same shape as MASK.', &
'', &
'  The element of the result that corresponds to the ith true element of MASK,', &
'  in array element order, has the value VECTOR (i) for i = 1, 2, . .  \., t,', &
'  where t is the number of true values in MASK. Each other element has a value', &
'  equal to FIELD if FIELD is scalar or to the corresponding element of FIELD', &
'  if it is an array.', &
'', &
'  The resulting array corresponds to FIELD with .true. elements of MASK', &
'  replaced by values from VECTOR in array element order.', &
'', &
'EXAMPLES', &
'  Particular values may be "scattered" to particular positions in an array by', &
'  using', &
'', &
'    1 0 0', &
'', &
'  If M is the array', &
'    0 1 0 0 0 1', &
'', &
'    V is the array [1, 2, 3],', &
'', &
'    and Q is the logical mask', &
'      T . .  where "T" represents true and "." represents false, then the', &
'      result of', &
'', &
'    UNPACK (V, MASK = Q, FIELD = M) has the value', &
'', &
'      1 2 0 1 1 0 0 0 3', &
'', &
'    and the result of UNPACK (V, MASK = Q, FIELD = 0) has the value', &
'', &
'      0 2 0 1 0 0 0 0 3', &
'', &
'  Sample program:', &
'', &
'      program demo_unpack', &
'      implicit none', &
'      logical,parameter :: T=.true., F=.false.', &
'', &
'      integer :: vector(2)  = [1,1]', &
'', &
'      ! mask and field must conform', &
'      integer,parameter :: r=2, c=2', &
'      logical :: mask(r,c)  = reshape([ T,F,F,T ],[2,2])', &
'      integer :: field(r,c) = 0, unity(2,2)', &
'', &
'         ! basic usage', &
'         unity = unpack( vector, mask, field )', &
'         call print_matrix_int(''unity='', unity)', &
'', &
'         ! if FIELD is a scalar it is used to fill all the elements', &
'         ! not assigned to by the vector and mask.', &
'         call print_matrix_int(''scalar field'',         &', &
'         & unpack(                                     &', &
'         & vector=[ 1, 2, 3, 4 ],                      &', &
'         & mask=reshape([ T,F,T,F,F,F,T,F,T ], [3,3]), &', &
'         & field=0) )', &
'', &
'      contains', &
'', &
'         subroutine print_matrix_int(title,arr)', &
'         ! convenience routine:', &
'         ! just prints small integer arrays in row-column format', &
'         implicit none', &
'         character(len=*),intent(in)  :: title', &
'         integer,intent(in)           :: arr(:,:)', &
'         integer                      :: i', &
'         character(len=:),allocatable :: biggest', &
'', &
'              write(*,*)trim(title)', &
'              ! make buffer to write integer into', &
'              biggest=''           ''', &
'              ! find how many characters to use for integers', &
'              write(biggest,''(i0)'')ceiling(log10(real(maxval(abs(arr)))))+2', &
'              ! use this format to write a row', &
'              biggest=''("  [",*(i''//trim(biggest)//'':,","))''', &
'              ! print one row of array at a time', &
'              do i=1,size(arr,dim=1)', &
'                 write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'                 write(*,''(" ]")'')', &
'              enddo', &
'         end subroutine print_matrix_int', &
'', &
'      end program demo_unpack', &
'', &
'  Results:', &
'', &
'         > unity=', &
'         >  [ 1, 0 ]', &
'         >  [ 0, 1 ]', &
'         > scalar field', &
'         >  [  1,  0,  3 ]', &
'         >  [  0,  0,  0 ]', &
'         >  [  2,  0,  4 ]', &
'', &
'STANDARD', &
'  Fortran 95 and later', &
'', &
'SEE ALSO', &
'  MERGE(3), PACK(3), SPREAD(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                              September 19, 2022              unpack(3fortran)', &
'']

shortname="unpack"
call process()


case('201','verify')

textblock=[character(len=256) :: &
'', &
'verify(3fortran)                                              verify(3fortran)', &
'', &
'NAME', &
'  VERIFY(3) - [CHARACTER:SEARCH] Scan a string for the absence of a set of', &
'  characters', &
'', &
'SYNTAX', &
'  result = verify(string, set, back, kind)', &
'', &
'        integer(kind=KIND) elemental function verify(string,set,back,kind)', &
'', &
'         character(len=*),intent(in) :: string', &
'         character(len=*),intent(in) :: set', &
'         logical,intent(in),optional :: back', &
'         integer,intent(in),optional :: KIND', &
'', &
'DESCRIPTION', &
'  Verifies that all the characters in STRING belong to the set of characters', &
'  in SET by identifying the first character in the string(s) that is not in', &
'  the set(s).', &
'', &
'  If BACK is either absent or equals .false., this function returns the', &
'  position of the leftmost character of STRING that is not in SET.', &
'', &
'  If BACK equals .true., the rightmost position is returned.', &
'', &
'  If all characters of STRING are found in SET, the result is zero.', &
'', &
'  This makes it easy to verify strings are all uppercase or lowercase, follow', &
'  a basic syntax, only contain printable characters, and many of the', &
'  conditions tested for with the C routines ISALNUM(3c), ISALPHA(3c),', &
'  ISASCII(3c), ISBLANK(3c), ISCNTRL(3c), ISDIGIT(3c), ISGRAPH(3c),', &
'  ISLOWER(3c), ISPRINT(3c), ISPUNCT(3c), ISSPACE(3c), ISUPPER(3c), and', &
'  ISXDIGIT(3c); but for a string as well an an array of characters.', &
'', &
'ARGUMENTS', &
'  o  STRING : Shall be of type character.', &
'', &
'  o  SET : Shall be of type character.', &
'', &
'  o  BACK : shall be of type logical.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RETURNS', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'EXAMPLES', &
'  Sample program I:', &
'', &
'      program demo_verify', &
'      implicit none', &
'      character(len=*),parameter :: int=''0123456789''', &
'      character(len=*),parameter :: hex=''abcdef0123456789''', &
'      character(len=*),parameter :: low=''abcdefghijklmnopqrstuvwxyz''', &
'      character(len=*),parameter :: upp=''ABCDEFGHIJKLMNOPQRSTUVWXYZ''', &
'      character(len=20):: string=''   Howdy There!''', &
'      character(len=6) :: strings(2)=["Howdy ","there!"]', &
'      character(len=2) :: sets(2)=["de","gh"]', &
'', &
'         write(*,*)''first non-blank character '',verify(string, '' '')', &
'         ! NOTE: same as len_trim(3)', &
'         write(*,*)''last non-blank character'',verify(string, '' '',back=.true.)', &
'', &
'         ! first non-lowercase non-blank character', &
'         write(*,*) verify(string,low//'' '')', &
'', &
'         !! elemental -- using arrays for both strings and for sets', &
'', &
'         ! first character in "Howdy" not in "de", and first letter in "there!"', &
'         ! not in "gh"', &
'         write(*,*) verify(strings,sets)', &
'', &
'         ! check each string from right to left for non-letter', &
'         write(*,*) ''last non-letter'',verify(strings,upp//low,back=.true.)', &
'', &
'         ! note character variables in an array have to be of same length', &
'         ! find last non-uppercase character in "Howdy"', &
'         ! and first non-lowercase in "There!"', &
'         write(*,*) verify(strings,[upp,low],back=[.true.,.false.])', &
'', &
'         write(*,*) verify("fortran", "", .true.)  ! 7, found ''n''', &
'         ! 0'' found none unmatched', &
'         write(*,*) verify("fortran", "nartrof")', &
'', &
'          !! CHECK IF STRING IS OF FORM NN-HHHHH', &
'          CHECK : block', &
'             logical                    :: lout', &
'             character(len=80)          :: chars', &
'', &
'             chars=''32-af43d''', &
'             lout=.true.', &
'', &
'             ! are the first two characters integer characters?', &
'             lout = lout.and.(verify(chars(1:2), int) == 0)', &
'', &
'             ! is the third character a dash?', &
'             lout = lout.and.(verify(chars(3:3), ''-'') == 0)', &
'', &
'             ! is remaining string a valid representation of a hex value?', &
'             lout = lout.and.(verify(chars(4:8), hex) == 0)', &
'', &
'             if(lout)then', &
'                write(*,*)trim(chars),'' passed''', &
'             endif', &
'', &
'          endblock CHECK', &
'      end program demo_verify', &
'', &
'  Results:', &
'', &
'          first non-blank character            4', &
'          last non-blank character          15', &
'                    4', &
'                    1           1', &
'          last non-letter           6           6', &
'                    6           6', &
'                    7', &
'                    0', &
'          32-af43d passed', &
'', &
'  Sample program II:', &
'', &
'  Determine if strings are valid integer representations', &
'', &
'      program fortran_ints', &
'      implicit none', &
'      integer :: i', &
'      character(len=*),parameter :: ints(*)=[character(len=10) :: &', &
'       ''+1 '', &', &
'       ''3044848 '', &', &
'       ''30.40 '', &', &
'       ''September '', &', &
'       ''1 2 3'', &', &
'       ''  -3000 '', &', &
'       '' '']', &
'', &
'         write(*,''("|",*(g0,"|"))'') ints', &
'         write(*,''("|",*(1x,l1,8x,"|"))'') isint(ints)', &
'', &
'      contains', &
'', &
'      elemental function isint(line) result (lout)', &
'      !', &
'      ! determine if string is a valid integer representation', &
'      ! ignoring trailing spaces and leading spaces', &
'      !', &
'      character(len=*),parameter   :: digits=''0123456789''', &
'      character(len=*),intent(in)  :: line', &
'      character(len=:),allocatable :: name', &
'      logical                      :: lout', &
'         lout=.false.', &
'         ! make sure at least two characters long to simplify tests', &
'         name=adjustl(line)//''  ''', &
'         ! blank string', &
'         if( name .eq. '''' )return', &
'         ! allow one leading sign', &
'         if( verify(name(1:1),''+-'') == 0 ) name=name(2:)', &
'         ! was just a sign', &
'         if( name .eq. '''' )return', &
'         lout=verify(trim(name), digits)  == 0', &
'      end function isint', &
'', &
'      end program fortran_ints', &
'', &
'  Results:', &
'', &
'      |+1       |3044848  |30.40    |September|1 2 3    |  -3000  |         |', &
'      | T       | T       | F       | F       | F       | T       | F       |', &
'', &
'  Sample program III:', &
'', &
'  Determine if strings represent valid Fortran symbol names', &
'', &
'      program fortran_symbol_name', &
'      implicit none', &
'      integer :: i', &
'      character(len=*),parameter :: symbols(*)=[character(len=10) :: &', &
'       ''A_ '', &', &
'       ''10 '', &', &
'       ''September '', &', &
'       ''A B'', &', &
'       ''_A '', &', &
'       '' '']', &
'', &
'         write(*,''("|",*(g0,"|"))'') symbols', &
'         write(*,''("|",*(1x,l1,8x,"|"))'') fortran_name(symbols)', &
'', &
'      contains', &
'', &
'      elemental function fortran_name(line) result (lout)', &
'      !', &
'      ! determine if a string is a valid Fortran name', &
'      ! ignoring trailing spaces (but not leading spaces)', &
'      !', &
'      character(len=*),parameter   :: int=''0123456789''', &
'      character(len=*),parameter   :: lower=''abcdefghijklmnopqrstuvwxyz''', &
'      character(len=*),parameter   :: upper=''ABCDEFGHIJKLMNOPQRSTUVWXYZ''', &
'      character(len=*),parameter   :: allowed=upper//lower//int//''_''', &
'', &
'      character(len=*),intent(in)  :: line', &
'      character(len=:),allocatable :: name', &
'      logical                      :: lout', &
'         name=trim(line)', &
'         if(len(name).ne.0)then', &
'            ! first character is alphameric', &
'            lout = verify(name(1:1), lower//upper) == 0  &', &
'             ! other characters are allowed in a symbol name', &
'             & .and. verify(name,allowed) == 0           &', &
'             ! allowable length', &
'             & .and. len(name) <= 63', &
'         else', &
'            lout = .false.', &
'         endif', &
'      end function fortran_name', &
'', &
'      end program fortran_symbol_name', &
'', &
'  Results:', &
'', &
'      |A_        |10        |September |A B       |_A        |          |', &
'      | T        | F        | T        | F        | F        | F        |', &
'', &
'STANDARD', &
'  Fortran 95 and later, with KIND argument - Fortran 2003 and later', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  fortran-lang intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                              September 19, 2022              verify(3fortran)', &
'']

shortname="verify"
call process()

case default
   allocate (character(len=256) :: textblock(0))
end select
contains
subroutine process()
if(present(topic))then
   if(topic)then
      textblock=[shortname]
   endif
endif

if(present(prefix))then
   if(prefix)then
      do i=1,size(textblock)
         textblock(i)= shortname//':'//trim(textblock(i))
      enddo
   endif
endif

if(present(m_help))then
   if(m_help)then
      textblock=[character(len=len(textblock)+1) :: ' ',textblock] ! add blank line to put shortname into
      textblock=' '//textblock                                     ! shift to right by one character
      textblock(1)=shortname
   endif
endif
end subroutine process
end function help_intrinsics_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine sort_name(lines)
!@(#) sort_name(3fp):sort strings(a-z) over specified field using shell sort starting with [ character
character(len = *)                :: lines(:)
   character(len = :),allocatable :: ihold
   integer                        :: n, igap, i, j, k, jg
   n = size(lines)
   if(n.gt.0)then
      allocate(character(len = len(lines(1))) :: ihold)
   else
      ihold = ''
   endif
   igap = n
   INFINITE: do
      igap = igap/2
      if(igap.eq.0) exit INFINITE
      k = n-igap
      i = 1
      INNER: do
         j = i
         INSIDE: do
            jg = j+igap
            if( lle( lower(lines(j)), lower(lines(jg)) ) )exit INSIDE
            ihold = lines(j)
            lines(j) = lines(jg)
            lines(jg) = ihold
            j = j-igap
            if(j.lt.1) exit INSIDE
         enddo INSIDE
         i = i+1
         if(i.gt.k) exit INNER
      enddo INNER
   enddo INFINITE
end subroutine sort_name
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
elemental pure function lower(str) result (string)
!@(#) M_strings::lower(3f): Changes a string to lowercase over specified range
character(*), intent(In)     :: str
character(len(str))          :: string
integer                      :: i
   string = str
   do i = 1, len_trim(str)     ! step thru each letter in the string
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32) ! change letter to miniscule
      case default
      end select
   end do
end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_intrinsics
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
 
 
!>>>>> build/dependencies/M_CLI2/src/M_CLI2.F90
!VERSION 1.0 20200115
!VERSION 2.0 20200802
!VERSION 3.0 20201021  LONG:SHORT syntax
!VERSION 3.1 20201115  LONG:SHORT:: syntax
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     M_CLI2(3fm) - [ARGUMENTS::M_CLI2::INTRO] command line argument
!!     parsing using a prototype command
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!   Available procedures and variables:
!!
!!      use M_CLI2, only : set_args, get_args, unnamed, remaining, args
!!      use M_CLI2, only : get_args_fixed_length, get_args_fixed_size
!!      use M_CLI2, only : specified
!!      ! convenience functions
!!      use M_CLI2, only : dget, iget, lget, rget, sget, cget
!!      use M_CLI2, only : dgets, igets, lgets, rgets, sgets, cgets
!!
!!##DESCRIPTION
!!    Allow for command line parsing much like standard Unix command line
!!    parsing using a simple prototype.
!!
!!    Typically one call to SET_ARGS(3f) is made to define the command
!!    arguments, set default values and parse the command line. Then a call
!!    is made to the convenience commands based on GET_ARGS(3f) for each
!!    command keyword to obtain the argument values.
!!
!!    The documentation for SET_ARGS(3f) and GET_ARGS(3f) provides further
!!    details.
!!
!!##EXAMPLE
!!
!! Sample program using type conversion routines
!!
!!     program demo_M_CLI2
!!     use M_CLI2,  only : set_args, get_args
!!     use M_CLI2,  only : filenames=>unnamed
!!     use M_CLI2,  only : get_args_fixed_length, get_args_fixed_size
!!     implicit none
!!     integer                      :: i
!!     integer,parameter            :: dp=kind(0.0d0)
!!     !
!!     ! DEFINE ARGS
!!     real                         :: x, y, z
!!     real(kind=dp),allocatable    :: point(:)
!!     logical                      :: l, lbig
!!     logical,allocatable          :: logicals(:)
!!     character(len=:),allocatable :: title    ! VARIABLE LENGTH
!!     character(len=40)            :: label    ! FIXED LENGTH
!!     real                         :: p(3)     ! FIXED SIZE
!!     logical                      :: logi(3)  ! FIXED SIZE
!!     !
!!     ! DEFINE AND PARSE (TO SET INITIAL VALUES) COMMAND LINE
!!     !   o set a value for all keywords.
!!     !   o double-quote strings
!!     !   o set all logical values to F or T.
!!     !   o value delimiter is comma, colon, or space
!!     call set_args('                         &
!!             & -x 1 -y 2 -z 3                &
!!             & -p -1 -2 -3                   &
!!             & --point 11.11, 22.22, 33.33e0 &
!!             & --title "my title" -l F -L F  &
!!             & --logicals  F F F F F         &
!!             & -logi F T F                   &
!!             & --label " " &
!!             ! note space between quotes is required
!!             & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!     call get_args('x',x)         ! SCALARS
!!     call get_args('y',y)
!!     call get_args('z',z)
!!     call get_args('l',l)
!!     call get_args('L',lbig)
!!     call get_args('title',title) ! ALLOCATABLE STRING
!!     call get_args('point',point) ! ALLOCATABLE ARRAYS
!!     call get_args('logicals',logicals)
!!     !
!!     ! for NON-ALLOCATABLE VARIABLES
!!
!!     ! for non-allocatable string
!!     call get_args_fixed_length('label',label)
!!
!!     ! for non-allocatable arrays
!!     call get_args_fixed_size('p',p)
!!     call get_args_fixed_size('logi',logi)
!!     !
!!     ! USE VALUES
!!     write(*,*)'x=',x, 'y=',y, 'z=',z, x+y+z
!!     write(*,*)'p=',p
!!     write(*,*)'point=',point
!!     write(*,*)'title=',title
!!     write(*,*)'label=',label
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     write(*,*)'logicals=',logicals
!!     write(*,*)'logi=',logi
!!     !
!!     ! unnamed strings
!!     !
!!     if(size(filenames).gt.0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!     !
!!     end program demo_M_CLI2
!!
!!##AUTHOR
!!     John S. Urban, 2019
!!##LICENSE
!!     Public Domain
!===================================================================================================================================
module M_CLI2
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT, warn=>OUTPUT_UNIT

! copied to M_CLI2 for a stand-alone version
!use M_strings,                     only : upper, lower, quote, replace_str=>replace, unquote, split, string_to_value, atleast
!use M_list,                        only : insert, locate, remove, replace
!use M_args,                        only : longest_command_argument
!use M_journal,                     only : journal

implicit none
integer,parameter,private :: dp=kind(0.0d0)
integer,parameter,private :: sp=kind(0.0)
private
!logical,save :: debug_m_cli2=.true.
logical,public,save :: debug_m_cli2=.false.
!===================================================================================================================================
character(len=*),parameter          :: gen='(*(g0))'
character(len=:),allocatable,public :: unnamed(:)
character(len=:),allocatable,public :: args(:)
character(len=:),allocatable,public :: remaining
public                              :: set_args
public                              :: get_subcommand
public                              :: get_args
public                              :: get_args_fixed_size
public                              :: get_args_fixed_length
public                              :: specified
public                              :: print_dictionary

public                              :: dget, iget, lget, rget, sget, cget
public                              :: dgets, igets, lgets, rgets, sgets, cgets
public                              :: CLI_RESPONSE_FILE

private :: check_commandline
private :: wipe_dictionary
private :: prototype_to_dictionary
private :: update
private :: prototype_and_cmd_args_to_nlist
private :: get

type option
   character(:),allocatable :: shortname
   character(:),allocatable :: longname
   character(:),allocatable :: value
   integer                  :: length
   logical                  :: present_in
   logical                  :: mandatory
end type option
!===================================================================================================================================
character(len=:),allocatable,save :: keywords(:)
character(len=:),allocatable,save :: shorts(:)
character(len=:),allocatable,save :: values(:)
integer,allocatable,save          :: counts(:)
logical,allocatable,save          :: present_in(:)
logical,allocatable,save          :: mandatory(:)

logical,save                      :: G_keyword_single_letter=.true.
character(len=:),allocatable,save :: G_passed_in
logical,save                      :: G_remaining_on, G_remaining_option_allowed
character(len=:),allocatable,save :: G_remaining
character(len=:),allocatable,save :: G_subcommand              ! possible candidate for a subcommand
character(len=:),allocatable,save :: G_STOP_MESSAGE
integer,save                      :: G_STOP
logical,save                      :: G_QUIET
logical,save                      :: G_STRICT                  ! strict short and long rules or allow -longname and --shortname
!----------------------------------------------
! try out response files
logical,save                      :: CLI_RESPONSE_FILE=.false. ! allow @name abbreviations
logical,save                      :: G_APPEND                  ! whether to append or replace when duplicate keywords found
logical,save                      :: G_OPTIONS_ONLY            ! process response file only looking for options for get_subcommand()
logical,save                      :: G_RESPONSE                ! allow @name abbreviations
character(len=:),allocatable,save :: G_RESPONSE_IGNORED
!----------------------------------------------
!===================================================================================================================================
! return allocatable arrays
interface  get_args;  module  procedure  get_anyarray_d;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_i;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_r;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_x;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_c;  end interface  ! any size array and any length
interface  get_args;  module  procedure  get_anyarray_l;  end interface  ! any size array

! return scalars
interface  get_args;  module  procedure  get_scalar_d;               end interface
interface  get_args;  module  procedure  get_scalar_i;               end interface
interface  get_args;  module  procedure  get_scalar_real;            end interface
interface  get_args;  module  procedure  get_scalar_complex;         end interface
interface  get_args;  module  procedure  get_scalar_logical;         end interface
interface  get_args;  module  procedure  get_scalar_anylength_c;     end interface  ! any length
! multiple scalars
interface  get_args;  module  procedure  many_args;               end  interface
!==================================================================================================================================
! return non-allocatable arrays
! said in conflict with get_args_*. Using class to get around that.
! that did not work either. Adding size parameter as optional parameter works; but using a different name
interface  get_args_fixed_size;  module procedure get_fixedarray_class;            end interface ! any length, fixed size array
!interface   get_args;           module procedure get_fixedarray_d;                end interface
!interface   get_args;           module procedure get_fixedarray_i;                end interface
!interface   get_args;           module procedure get_fixedarray_r;                end interface
!interface   get_args;           module procedure get_fixedarray_l;                end interface
!interface   get_args;           module procedure get_fixedarray_fixed_length_c;   end interface

interface   get_args_fixed_length;  module  procedure  get_args_fixed_length_a_array; end interface  ! fixed length any size array
interface   get_args_fixed_length;  module  procedure  get_args_fixed_length_scalar_c;  end interface       ! fixed length
!===================================================================================================================================
!intrinsic findloc
!===================================================================================================================================

! ident_1="@(#)M_CLI2::str(3f): {msg_scalar,msg_one}"

private str
interface str
   module procedure msg_scalar, msg_one
end interface str
!===================================================================================================================================

private locate        ! [M_CLI2] find PLACE in sorted character array where value can be found or should be placed
   private locate_c
private insert        ! [M_CLI2] insert entry into a sorted allocatable array at specified position
   private insert_c
   private insert_i
   private insert_l
private replace       ! [M_CLI2] replace entry by index from a sorted allocatable array if it is present
   private replace_c
   private replace_i
   private replace_l
private remove        ! [M_CLI2] delete entry by index from a sorted allocatable array if it is present
   private remove_c
   private remove_i
   private remove_l

! Generic subroutine inserts element into allocatable array at specified position
interface  locate;   module procedure locate_c                            ; end interface
interface  insert;   module procedure insert_c,      insert_i,  insert_l  ; end interface
interface  replace;  module procedure replace_c,     replace_i, replace_l ; end interface
interface  remove;   module procedure remove_c,      remove_i,  remove_l  ; end interface
!-----------------------------------------------------------------------------------------------------------------------------------
! convenience functions
interface cgets;module procedure cgs, cg;end interface
interface dgets;module procedure dgs, dg;end interface
interface igets;module procedure igs, ig;end interface
interface lgets;module procedure lgs, lg;end interface
interface rgets;module procedure rgs, rg;end interface
interface sgets;module procedure sgs, sg;end interface
!-----------------------------------------------------------------------------------------------------------------------------------
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     check_commandline(3f) - [ARGUMENTS:M_CLI2]check command and process
!!     pre-defined options
!!
!!##SYNOPSIS
!!
!!      subroutine check_commandline(help_text,version_text,ierr,errmsg)
!!
!!       character(len=*),intent(in),optional :: help_text(:)
!!       character(len=*),intent(in),optional :: version_text(:)
!!
!!##DESCRIPTION
!!     Checks the commandline  and processes the implicit --help, --version,
!!     --verbose, and --usage parameters.
!!
!!     If the optional text values are supplied they will be displayed by
!!     --help and --version command-line options, respectively.
!!
!!##OPTIONS
!!
!!     HELP_TEXT     if present, will be displayed if program is called with
!!                   --help switch, and then the program will terminate. If
!!                   not supplied, the command line initialized string will be
!!                   shown when --help is used on the commandline.
!!
!!     VERSION_TEXT  if present, will be displayed if program is called with
!!                   --version switch, and then the program will terminate.
!!
!!        If the first four characters of each line are "@(#)" this prefix
!!        will not be displayed and the last non-blank letter will be
!!        removed from each line. This if for support of the SCCS what(1)
!!        command. If you do not have the what(1) command on GNU/Linux and
!!        Unix platforms you can probably see how it can be used to place
!!        metadata in a binary by entering:
!!
!!         strings demo_commandline|grep '@(#)'|tr '>' '\n'|sed -e 's/  */ /g'
!!
!!##EXAMPLE
!!
!!
!! Typical usage:
!!
!!      program check_commandline
!!      use M_CLI2,  only : unnamed, set_args, get_args
!!      implicit none
!!      integer                      :: i
!!      character(len=:),allocatable :: version_text(:), help_text(:)
!!      real               :: x, y, z
!!      character(len=*),parameter :: cmd='-x 1 -y 2 -z 3'
!!         version_text=[character(len=80) :: "version 1.0","author: me"]
!!         help_text=[character(len=80) :: &
!!                 & "wish I put instructions","here","I suppose?"]
!!         call set_args(cmd,help_text,version_text)
!!         call get_args('x',x,'y',y,'z',z)
!!         ! All done cracking the command line. Use the values in your program.
!!         write (*,*)x,y,z
!!         ! the optional unnamed values on the command line are
!!         ! accumulated in the character array "UNNAMED"
!!         if(size(unnamed).gt.0)then
!!            write (*,'(a)')'files:'
!!            write (*,'(i6.6,3a)') (i,'[',unnamed(i),']',i=1,size(unnamed))
!!         endif
!!      end program check_commandline
!===================================================================================================================================
subroutine check_commandline(help_text,version_text)
character(len=*),intent(in),optional :: help_text(:)
character(len=*),intent(in),optional :: version_text(:)
character(len=:),allocatable         :: line
integer                              :: i
integer                              :: istart
integer                              :: iback
   if(get('usage').eq.'T')then
      call print_dictionary('USAGE:')
      !x!call default_help()
      call mystop(32)
      return
   endif
   if(present(help_text))then
      if(get('help').eq.'T')then
         do i=1,size(help_text)
            call journal('sc',help_text(i))
         enddo
         call mystop(1,'displayed help text')
         return
      endif
   elseif(get('help').eq.'T')then
      call default_help()
      call mystop(2,'displayed default help text')
      return
   endif
   if(present(version_text))then
      if(get('version').eq.'T')then
         istart=1
         iback=0
         if(size(version_text).gt.0)then
            if(index(version_text(1),'@'//'(#)').eq.1)then ! allow for what(1) syntax
               istart=5
               iback=1
            endif
         endif
         do i=1,size(version_text)
            !xINTEL BUG*!call journal('sc',version_text(i)(istart:len_trim(version_text(i))-iback))
            line=version_text(i)(istart:len_trim(version_text(i))-iback)
            call journal('sc',line)
         enddo
         call mystop(3,'displayed version text')
         return
      endif
   elseif(get('version').eq.'T')then

      if(G_QUIET)then
         G_STOP_MESSAGE = 'no version text'
      else
         call journal('sc','*check_commandline* no version text')
      endif
      call mystop(4,'displayed default version text')
      return
   endif
contains
subroutine default_help()
character(len=:),allocatable :: cmd_name
integer :: ilength
   call get_command_argument(number=0,length=ilength)
   if(allocated(cmd_name))deallocate(cmd_name)
   allocate(character(len=ilength) :: cmd_name)
   call get_command_argument(number=0,value=cmd_name)
   G_passed_in=G_passed_in//repeat(' ',len(G_passed_in))
   call substitute(G_passed_in,' --',NEW_LINE('A')//' --')
   if(.not.G_QUIET)then
      call journal('sc',cmd_name,G_passed_in) ! no help text, echo command and default options
   endif
   deallocate(cmd_name)
end subroutine default_help
end subroutine check_commandline
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     set_args(3f) - [ARGUMENTS:M_CLI2] command line argument parsing
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     subroutine set_args(definition,help_text,version_text,ierr,errmsg)
!!
!!      character(len=*),intent(in),optional              :: definition
!!      character(len=*),intent(in),optional              :: help_text(:)
!!      character(len=*),intent(in),optional              :: version_text(:)
!!      integer,intent(out),optional                      :: ierr
!!      character(len=:),intent(out),allocatable,optional :: errmsg
!!##DESCRIPTION
!!
!!     SET_ARGS(3f) requires a unix-like command prototype for defining
!!     arguments and default command-line options. Argument values are then
!!     read using GET_ARGS(3f).
!!
!!     The --help and --version options require the optional
!!     help_text and version_text values to be provided.
!!
!!##OPTIONS
!!
!!    DEFINITION  composed of all command arguments concatenated
!!                into a Unix-like command prototype string. For
!!                example:
!!
!!                 call set_args('-L F -ints 10,20,30 -title "my title" -R 10.3')
!!
!!                DEFINITION is pre-defined to act as if started with
!!                the reserved options '--verbose F --usage F --help
!!                F --version F'. The --usage option is processed when
!!                the set_args(3f) routine is called. The same is true
!!                for --help and --version if the optional help_text
!!                and version_text options are provided.
!!
!!                see "DEFINING THE PROTOTYPE" in the next section for
!!                further details.
!!
!!    HELP_TEXT   if present, will be displayed if program is called with
!!                --help switch, and then the program will terminate. If
!!                not supplied, the command line initialization string
!!                will be shown when --help is used on the commandline.
!!
!!      VERSION_TEXT  if present, will be displayed if program is called with
!!                    --version switch, and then the program will terminate.
!!      IERR          if present a non-zero option is returned when an
!!                    error occurs instead of program execution being
!!                    terminated
!!      ERRMSG        a description of the error if ierr is present
!!
!!##DEFINING THE PROTOTYPE
!!         o all keywords on the prototype MUST get a value.
!!
!!         o logicals MUST be set to F or T.
!!
!!         o strings MUST be delimited with double-quotes and
!!           must be at least one space. Internal double-quotes
!!           are represented with two double-quotes.
!!
!!         o numeric keywords are not allowed; but this allows
!!           negative numbers to be used as values.
!!
!!         o lists of values should be comma-delimited unless a
!!           user-specified delimiter is used. The prototype
!!           must use the same array delimiters as the call to
!!           the family of get_args*(3f) called.
!!
!!         o long names (--keyword) should be all lowercase
!!
!!         o The simplest way to have short names is to suffix the long
!!           name with :LETTER If this syntax is used then logical shorts
!!           may be combined on the command line and -- and - prefixes are
!!           strictly enforced.
!!
!!           mapping of short names to long names not using the
!!           --LONGNAME:SHORTNAME syntax is demonstrated in the manpage
!!           for SPECIFIED(3f).
!!
!!         o A very special behavior occurs if the keyword name ends in ::.
!!           The next parameter is taken as a value even if it starts with -.
!!           This is not generally recommended but is noted here for
!!           completeness.
!!
!!         o to define a zero-length allocatable array make the
!!           value a delimiter (usually a comma).
!!
!!         o all unused values go into the character array UNNAMED
!!
!!         o If the prototype ends with "--" a special mode is turned
!!           on where anything after "--" on input goes into the variable
!!           REMAINING and the array ARGS instead of becoming elements in
!!           the UNNAMED array. This is not needed for normal processing.
!!
!!##USAGE
!!      When invoking the program line note that (subject to change) the
!!      following variations from other common command-line parsers:
!!
!!         o Long names should be all lowercase and always more than one
!!           character.
!!
!!         o values for duplicate keywords are appended together with a space
!!           separator when a command line is executed.
!!
!!         o numeric keywords are not allowed; but this allows
!!           negative numbers to be used as values.
!!
!!         o Although not generally recommended you can equivalence
!!           keywords (usually for multi-lingual support). Be aware that
!!           specifying both names of an equivalenced keyword on a command
!!           line will have undefined results (currently, their ASCII
!!           alphabetical order will define what the Fortran variable
!!           values become).
!!
!!           The second of the names should only be called with a
!!           GET_ARGS*(3f) routine if the SPECIFIED(3f) function is .TRUE.
!!           for that name.
!!
!!           Note that allocatable arrays cannot be EQUIVALENCEd in Fortran.
!!
!!         o short keywords cannot be combined unless they were defined
!!           using the --LONGNAME:SHORTNAME syntax. Even then -a -b -c
!!           is required not -abc unless all the keywords are logicals
!!           (Boolean keys).
!!
!!         o shuffling is not supported. Values should follow their
!!           keywords.
!!
!!         o if a parameter value of just "-" is supplied it is
!!           converted to the string "stdin".
!!
!!         o values not matching a keyword go into the character
!!           array "UNUSED".
!!
!!         o if the keyword "--" is encountered the rest of the
!!           command arguments go into the character array "UNUSED".
!!##EXAMPLE
!!
!! Sample program:
!!
!!     program demo_set_args
!!     use M_CLI2,  only : filenames=>unnamed, set_args, get_args
!!     use M_CLI2,  only : get_args_fixed_size
!!     implicit none
!!     integer                      :: i
!!     ! DEFINE ARGS
!!     real                         :: x, y, z
!!     real                         :: p(3)
!!     character(len=:),allocatable :: title
!!     logical                      :: l, lbig
!!     integer,allocatable          :: ints(:)
!!     !
!!     !  DEFINE COMMAND (TO SET INITIAL VALUES AND ALLOWED KEYWORDS)
!!     !  AND READ COMMAND LINE
!!     call set_args(' &
!!        ! reals
!!        & -x 1 -y 2.3 -z 3.4e2 &
!!        ! integer array
!!        & -p -1,-2,-3 &
!!        ! always double-quote strings
!!        & --title "my title" &
!!        ! set all logical values to F or T.
!!        & -l F -L F &
!!        ! set allocatable size to zero if you like by using a delimiter
!!        & -ints , &
!!        ! string should be a single character at a minimum
!!        & --label " " &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!     !     SCALARS
!!     call get_args('x',x)
!!     call get_args('y',y)
!!     call get_args('z',z)
!!     call get_args('l',l)
!!     call get_args('L',lbig)
!!     call get_args('ints',ints)      ! ALLOCATABLE ARRAY
!!     call get_args('title',title)    ! ALLOCATABLE STRING
!!     call get_args_fixed_size('p',p) ! NON-ALLOCATABLE ARRAY
!!     ! USE VALUES
!!     write(*,*)'x=',x
!!     write(*,*)'y=',y
!!     write(*,*)'z=',z
!!     write(*,*)'p=',p
!!     write(*,*)'title=',title
!!     write(*,*)'ints=',ints
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     ! UNNAMED VALUES
!!     if(size(filenames).gt.0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!     end program demo_set_args
!!
!!##RESPONSE FILES
!!
!!  If you have no interest in using external files as abbreviations
!!  you can ignore this section. Otherwise, before calling set_args(3f)
!!  add:
!!
!!     use M_CLI2, only : CLI_response_file
!!     CLI_response_file=.true.
!!
!!  M_CLI2 Response files are small files containing CLI (Command Line
!!  Interface) arguments that end with ".rsp" that can be used when command
!!  lines are so long that they would exceed line length limits or so complex
!!  that it is useful to have a platform-independent method of creating
!!  an abbreviation.
!!
!!  Shell aliases and scripts are often used for similar purposes (and
!!  allow for much more complex conditional execution, of course), but
!!  they generally cannot be used to overcome line length limits and are
!!  typically platform-specific.
!!
!!  Examples of commands that support similar response files are the Clang
!!  and Intel compilers, although there is no standard format for the files.
!!
!!  They are read if you add options of the syntax "@NAME" as the FIRST
!!  parameters on your program command line calls. They are not recursive --
!!  that is, an option in a response file cannot be given the value "@NAME2"
!!  to call another response file.
!!
!!  Note that more than one response name may appear on a command line.
!!
!!  They are case-sensitive names.
!!
!!   LOCATING RESPONSE FILES
!!
!!  A search for the response file always starts with the current directory.
!!  The search then proceeds to look in any additional directories specified
!!  with the colon-delimited environment variable CLI_RESPONSE_PATH.
!!
!!  The first resource file found that results in lines being processed
!!  will be used and processing stops after that first match is found. If
!!  no match is found an error occurs and the program is stopped.
!!
!!   RESPONSE FILE SECTIONS
!!
!!  A simple response file just has options for calling the program in it
!!  prefixed with the word "options".
!!  But they can also contain section headers to denote selections that are
!!  only executed when a specific OS is being used, print messages, and
!!  execute system commands.
!!
!!   SEARCHING FOR OSTYPE IN REGULAR FILES
!!
!!  So assuming the name @NAME was specified on the command line a file
!!  named NAME.rsp will be searched for in all the search directories
!!  and then in that file a string that starts with the string @OSTYPE
!!  (if the environment variables $OS and $OSTYPE are not blank. $OSTYPE
!!  takes precedence over $OS).
!!
!!   SEARCHING FOR UNLABELED DIRECTIVES IN REGULAR FILES
!!
!!  Then, the same files will be searched for lines above any line starting
!!  with "@". That is, if there is no special section for the current OS
!!  it just looks at the top of the file for unlabeled options.
!!
!!   SEARCHING FOR OSTYPE AND NAME IN THE COMPOUND FILE
!!
!!  In addition or instead of files with the same name as the @NAME option
!!  on the command line, you can have one file named after the executable
!!  name that contains multiple abbreviation names.
!!
!!  So if your program executable is named EXEC you create a single file
!!  called EXEC.rsp and can append all the simple files described above
!!  separating them with lines of the form @OSTYPE@NAME or just @NAME.
!!
!!  So if no specific file for the abbreviation is found a file called
!!  "EXEC.rsp" is searched for where "EXEC" is the name of the executable.
!!  This file is always a "compound" response file that uses the following format:
!!
!!  Any compound EXEC.rsp file found in the current or searched directories
!!  will be searched for the string @OSTYPE@NAME first.
!!
!!  Then if nothing is found, the less specific line @NAME is searched for.
!!
!!   THE SEARCH IS OVER
!!
!!  Sounds complicated but actually works quite intuitively. Make a file in
!!  the current directory and put options in it and it will be used. If that
!!  file ends up needing different cases for different platforms add a line
!!  like "@Linux" to the file and some more lines and that will only be
!!  executed if the environment variable OSTYPE or OS is "Linux". If no match
!!  is found for named sections the lines at the top before any "@" lines
!!  will be used as a default if no match is found.
!!
!!  If you end up using a lot of files like this you can combine them all
!!  together and put them into a file called "program_name".rsp and just
!!  put lines like @NAME or @OSTYPE@NAME at that top of each selection.
!!
!!  Now, back to the details on just what you can put in the files.
!!
!!##SPECIFICATION FOR RESPONSE FILES
!!
!!   SIMPLE RESPONSE FILES
!!
!!  The first word of a line is special and has the following meanings:
!!
!!    options|-  Command options following the rules of the SET_ARGS(3f)
!!               prototype. So
!!                o It is preferred to specify a value for all options.
!!                o double-quote strings.
!!                o give a blank string value as " ".
!!                o use F|T for lists of logicals,
!!                o lists of numbers should be comma-delimited.
!!    comment|#  Line is a comment line
!!    system|!   System command.
!!               System commands are executed as a simple call to
!!               system (so a cd(1) or setting a shell variable
!!               would not effect subsequent lines, for example)
!!    print|>    Message to screen
!!    stop       display message and stop program.
!!
!!  So if a program that does nothing but echos its parameters
!!
!!    program testit
!!    use M_CLI2, only : set_args, rget, sget, lget
!!    use M_CLI2, only : CLI_response_file
!!    implicit none
!!       real :: x,y                           ; namelist/args/ x,y
!!       character(len=:),allocatable :: title ; namelist/args/ title
!!       logical :: big                        ; namelist/args/ big
!!       CLI_response_file=.true.
!!       call set_args('-x 10.0 -y 20.0 --title "my title" --big F')
!!       x=rget('x')
!!       y=rget('y')
!!       title=sget('title')
!!       big=lget('big')
!!       write(*,nml=args)
!!    end program testit
!!
!!  And a file in the current directory called "a.rsp" contains
!!
!!     # defaults for project A
!!     options -x 1000 -y 9999
!!     options --title " "
!!     options --big T
!!
!!  The program could be called with
!!
!!     $myprog     # normal call
!!      X=10.0 Y=20.0 TITLE="my title"
!!
!!     $myprog @a  # change defaults as specified in "a.rsp"
!!     X=1000.0 Y=9999.0 TITLE=" "
!!
!!     # change defaults but use any option as normal to override defaults
!!     $myprog @a -y 1234
!!      X=1000.0 Y=1234.0 TITLE=" "
!!
!!   COMPOUND RESPONSE FILES
!!
!!  A compound response file has the same basename as the executable with a
!!  ".rsp" suffix added. So if your program is named "myprg" the filename
!!  must be "myprg.rsp".
!!
!!    Note that here `basename` means the last leaf  of the
!!    name of the program as returned by the Fortran intrinsic
!!    GET_COMMAND_ARGUMENT(0,...) trimmed of anything after a period ("."),
!!    so it is a good idea not to use hidden files.
!!
!!  Unlike simple response files compound response files can contain multiple
!!  setting names.
!!
!!  Specifically in a compound file
!!  if the environment variable $OSTYPE (first) or $OS is set the first search
!!  will be for a line of the form (no leading spaces should be used):
!!
!!    @OSTYPE@alias_name
!!
!!  If no match or if the environment variables $OSTYPE and $OS were not
!!  set or a match is not found then a line of the form
!!
!!    @alias_name
!!
!!  is searched for in simple or compound files. If found subsequent lines
!!  will be ignored that start with "@" until a line not starting with
!!  "@" is encountered. Lines will then be processed until another line
!!  starting with "@" is found or end-of-file is encountered.
!!
!!   COMPOUND RESPONSE FILE EXAMPLE
!!  An example compound file
!!
!!    #################
!!    @if
!!    > RUNNING TESTS USING RELEASE VERSION AND ifort
!!    options test --release --compiler ifort
!!    #################
!!    @gf
!!    > RUNNING TESTS USING RELEASE VERSION AND gfortran
!!    options test --release --compiler gfortran
!!    #################
!!    @nv
!!    > RUNNING TESTS USING RELEASE VERSION AND nvfortran
!!    options test --release --compiler nvfortran
!!    #################
!!    @nag
!!    > RUNNING TESTS USING RELEASE VERSION AND nagfor
!!    options test --release --compiler nagfor
!!    #
!!    #################
!!    # OS-specific example:
!!    @Linux@install
!!    #
!!    # install executables in directory (assuming install(1) exists)
!!    #
!!    system mkdir -p ~/.local/bin
!!    options run --release T --runner "install -vbp -m 0711 -t ~/.local/bin"
!!    @install
!!    STOP INSTALL NOT SUPPORTED ON THIS PLATFORM OR $OSTYPE NOT SET
!!    #
!!    #################
!!    @fpm@testall
!!    #
!!    !fpm test --compiler nvfortran
!!    !fpm test --compiler ifort
!!    !fpm test --compiler gfortran
!!    !fpm test --compiler nagfor
!!    STOP tests complete. Any additional parameters were ignored
!!    #################
!!
!!  Would be used like
!!
!!    fpm @install
!!    fpm @nag --
!!    fpm @testall
!!
!!   NOTES
!!
!!    The intel Fortran compiler now calls the response files "indirect
!!    files" and does not add the implied suffix ".rsp" to the files
!!    anymore. It also allows the @NAME syntax anywhere on the command
!!    line, not just at the beginning. --  20201212
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!
!!##LICENSE
!!      Public Domain

!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine set_args(prototype,help_text,version_text,string,ierr,errmsg)

! ident_2="@(#)M_CLI2::set_args(3f): parse prototype string"

character(len=*),intent(in)                       :: prototype
character(len=*),intent(in),optional              :: help_text(:)
character(len=*),intent(in),optional              :: version_text(:)
character(len=*),intent(in),optional              :: string
integer,intent(out),optional                      :: ierr
character(len=:),intent(out),allocatable,optional :: errmsg
character(len=:),allocatable                      :: hold               ! stores command line argument
integer                                           :: ibig
   G_response=CLI_RESPONSE_FILE
   G_options_only=.false.
   G_append=.true.
   G_passed_in=''
   G_STOP=0
   G_STOP_MESSAGE=''
   if(present(ierr))then
      G_QUIET=.true.
   else
      G_QUIET=.false.
   endif
   ibig=longest_command_argument() ! bug in gfortran. len=0 should be fine
   if(allocated(unnamed)) deallocate(unnamed)
   allocate(character(len=ibig) :: unnamed(0))
   if(allocated(args)) deallocate(args)
   allocate(character(len=ibig) :: args(0))

   call wipe_dictionary()
   hold='--version F --usage F --help F --version F '//adjustl(prototype)
   call prototype_and_cmd_args_to_nlist(hold,string)
   if(allocated(G_RESPONSE_IGNORED))then
      if(debug_m_cli2)write(*,gen)'<DEBUG>SET_ARGS:G_RESPONSE_IGNORED:',G_RESPONSE_IGNORED
      if(size(unnamed).ne.0)write(*,*)'LOGIC ERROR'
      call split(G_RESPONSE_IGNORED,unnamed)
   endif

   if(.not.allocated(unnamed))then
       allocate(character(len=0) :: unnamed(0))
   endif
   if(.not.allocated(args))then
       allocate(character(len=0) :: args(0))
   endif
   call check_commandline(help_text,version_text) ! process --help, --version, --usage
   if(present(ierr))then
      ierr=G_STOP
   endif
   if(present(errmsg))then
      errmsg=G_STOP_MESSAGE
   endif
end subroutine set_args
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_subcommand(3f) - [ARGUMENTS:M_CLI2] special-case routine for
!!    handling subcommands on a command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function get_subcommand()
!!
!!     character(len=:),allocatable :: get_subcommand
!!
!!##DESCRIPTION
!!    In the special case when creating a program with subcommands it
!!    is assumed the first word on the command line is the subcommand. A
!!    routine is required to handle response file processing, therefore
!!    this routine (optionally processing response files) returns that
!!    first word as the subcommand name.
!!
!!    It should not be used by programs not building a more elaborate
!!    command with subcommands.
!!
!!##RETURNS
!!    NAME   name of subcommand
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!    program demo_get_subcommand
!!    !x! SUBCOMMANDS
!!    !x! For a command with subcommands like git(1)
!!    !x! you can make separate namelists for each subcommand.
!!    !x! You can call this program which has two subcommands (run, test),
!!    !x! like this:
!!    !x!    demo_get_subcommand --help
!!    !x!    demo_get_subcommand run -x -y -z -title -l -L
!!    !x!    demo_get_subcommand test -title -l -L -testname
!!    !x!    demo_get_subcommand run --help
!!       implicit none
!!    !x! DEFINE VALUES TO USE AS ARGUMENTS WITH INITIAL VALUES
!!       real               :: x=-999.0,y=-999.0,z=-999.0
!!       character(len=80)  :: title="not set"
!!       logical            :: l=.false.
!!       logical            :: l_=.false.
!!       character(len=80)  :: testname="not set"
!!       character(len=20)  :: name
!!       call parse(name) !x! DEFINE AND PARSE COMMAND LINE
!!       !x! ALL DONE CRACKING THE COMMAND LINE.
!!       !x! USE THE VALUES IN YOUR PROGRAM.
!!       write(*,*)'command was ',name
!!       write(*,*)'x,y,z .... ',x,y,z
!!       write(*,*)'title .... ',title
!!       write(*,*)'l,l_ ..... ',l,l_
!!       write(*,*)'testname . ',testname
!!    contains
!!    subroutine parse(name)
!!    !x! PUT EVERYTHING TO DO WITH COMMAND PARSING HERE FOR CLARITY
!!    use M_CLI2, only : set_args, get_args, get_args_fixed_length
!!    use M_CLI2, only : get_subcommand
!!    use M_CLI2, only : CLI_RESPONSE_FILE
!!    character(len=*)              :: name    ! the subcommand name
!!    character(len=:),allocatable  :: help_text(:), version_text(:)
!!       CLI_RESPONSE_FILE=.true.
!!    ! define version text
!!       version_text=[character(len=80) :: &
!!          '@(#)PROGRAM:     demo_get_subcommand            >', &
!!          '@(#)DESCRIPTION: My demo program  >', &
!!          '@(#)VERSION:     1.0 20200715     >', &
!!          '@(#)AUTHOR:      me, myself, and I>', &
!!          '@(#)LICENSE:     Public Domain    >', &
!!          '' ]
!!        ! general help for "demo_get_subcommand --help"
!!        help_text=[character(len=80) :: &
!!         ' allowed subcommands are          ', &
!!         '   * run  -l -L -title -x -y -z   ', &
!!         '   * test -l -L -title            ', &
!!         '' ]
!!       ! find the subcommand name by looking for first word on command
!!       ! not starting with dash
!!       name = get_subcommand()
!!       select case(name)
!!       case('run')
!!        help_text=[character(len=80) :: &
!!         '                                  ', &
!!         ' Help for subcommand "run"        ', &
!!         '                                  ', &
!!         '' ]
!!        call set_args( &
!!        & '-x 1 -y 2 -z 3 --title "my title" -l F -L F',&
!!        & help_text,version_text)
!!        call get_args('x',x)
!!        call get_args('y',y)
!!        call get_args('z',z)
!!        call get_args_fixed_length('title',title)
!!        call get_args('l',l)
!!        call get_args('L',l_)
!!       case('test')
!!        help_text=[character(len=80) :: &
!!         '                                  ', &
!!         ' Help for subcommand "test"       ', &
!!         '                                  ', &
!!         '' ]
!!        call set_args(&
!!        & '--title "my title" -l F -L F --testname "Test"',&
!!        & help_text,version_text)
!!        call get_args_fixed_length('title',title)
!!        call get_args('l',l)
!!        call get_args('L',l_)
!!        call get_args_fixed_length('testname',testname)
!!       case default
!!        ! process help and version
!!        call set_args(' ',help_text,version_text)
!!        write(*,'(*(a))')'unknown or missing subcommand [',trim(name),']'
!!        write(*,'(a)')[character(len=80) ::  &
!!        ' allowed subcommands are          ', &
!!        '   * run  -l -L -title -x -y -z   ', &
!!        '   * test -l -L -title            ', &
!!        '' ]
!!        stop
!!       end select
!!    end subroutine parse
!!    end program demo_get_subcommand
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
function get_subcommand() result(sub)

! ident_3="@(#)M_CLI2::get_subcommand(3f): parse prototype string to get subcommand, allowing for response files"

character(len=:),allocatable  :: sub
character(len=:),allocatable  :: cmdarg
character(len=:),allocatable  :: array(:)
character(len=:),allocatable  :: prototype
integer                       :: ilongest
integer                       :: i
integer                       :: j
   G_subcommand=''
   G_options_only=.true.
   sub=''

   if(.not.allocated(unnamed))then
      allocate(character(len=0) :: unnamed(0))
   endif

   ilongest=longest_command_argument()
   allocate(character(len=max(63,ilongest)):: cmdarg)
   cmdarg(:) = ''
   ! look for @NAME if CLI_RESPONSE_FILE=.TRUE. AND LOAD THEM
   do i = 1, command_argument_count()
      call get_command_argument(i, cmdarg)
      if(adjustl(cmdarg(1:1)) .eq. '@')then
         call get_prototype(cmdarg,prototype)
         call split(prototype,array)
         ! assume that if using subcommands first word not starting with dash is the subcommand
         do j=1,size(array)
            if(adjustl(array(j)(1:1)) .ne. '-')then
            G_subcommand=trim(array(j))
            sub=G_subcommand
            exit
         endif
         enddo
      endif
   enddo

   if(G_subcommand.ne.'')then
      sub=G_subcommand
   elseif(size(unnamed).ne.0)then
      sub=unnamed(1)
   else
      cmdarg(:) = ''
      do i = 1, command_argument_count()
         call get_command_argument(i, cmdarg)
         if(adjustl(cmdarg(1:1)) .ne. '-')then
            sub=trim(cmdarg)
           exit
        endif
      enddo
   endif
   G_options_only=.false.
end function get_subcommand
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
subroutine set_usage(keyword,description,value)
character(len=*),intent(in) :: keyword
character(len=*),intent(in) :: description
character(len=*),intent(in) :: value
write(*,*)keyword
write(*,*)description
write(*,*)value
! store the descriptions in an array and then apply them when set_args(3f) is called.
! alternatively, could allow for a value as well in lieue of the prototype
end subroutine set_usage
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      prototype_to_dictionary(3f) - [ARGUMENTS:M_CLI2] parse user command
!!      and store tokens into dictionary
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     recursive subroutine prototype_to_dictionary(string)
!!
!!      character(len=*),intent(in)     ::  string
!!
!!##DESCRIPTION
!!      given a string of form
!!
!!        -var value -var value
!!
!!      define dictionary of form
!!
!!        keyword(i), value(i)
!!
!!      o  string values
!!
!!          o must be delimited with double quotes.
!!          o adjacent double quotes put one double quote into value
!!          o must not be null. A blank is specified as " ", not "".
!!
!!      o  logical values
!!
!!          o logical values must have a value
!!
!!      o  leading and trailing blanks are removed from unquoted values
!!
!!
!!##OPTIONS
!!      STRING   string is character input string to define command
!!
!!##RETURNS
!!
!!##EXAMPLE
!!
!! sample program:
!!
!!     Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
recursive subroutine prototype_to_dictionary(string)
implicit none

! ident_4="@(#)M_CLI2::prototype_to_dictionary(3f): parse user command and store tokens into dictionary"

character(len=*),intent(in)       :: string ! string is character input string of options and values

character(len=:),allocatable      :: dummy   ! working copy of string
character(len=:),allocatable      :: value
character(len=:),allocatable      :: keyword
character(len=3)                  :: delmt   ! flag if in a delimited string or not
character(len=1)                  :: currnt  ! current character being processed
character(len=1)                  :: prev    ! character to left of CURRNT
character(len=1)                  :: forwrd  ! character to right of CURRNT
integer,dimension(2)              :: ipnt
integer                           :: islen   ! number of characters in input string
integer                           :: ipoint
integer                           :: itype
integer,parameter                 :: VAL=1, KEYW=2
integer                           :: ifwd
integer                           :: ibegin
integer                           :: iend
integer                           :: place

   islen=len_trim(string)                               ! find number of characters in input string
   if(islen  ==  0)then                                 ! if input string is blank, even default variable will not be changed
      return
   endif
   dummy=adjustl(string)//'  '

   keyword=""          ! initial variable name
   value=""            ! initial value of a string
   ipoint=0            ! ipoint is the current character pointer for (dummy)
   ipnt(2)=2           ! pointer to position in keyword
   ipnt(1)=1           ! pointer to position in value
   itype=VAL           ! itype=1 for value, itype=2 for variable

   delmt="off"
   prev=" "

   G_keyword_single_letter=.true.
   do
      ipoint=ipoint+1               ! move current character pointer forward
      currnt=dummy(ipoint:ipoint)   ! store current character into currnt
      ifwd=min(ipoint+1,islen)      ! ensure not past end of string
      forwrd=dummy(ifwd:ifwd)       ! next character (or duplicate if last)

      if((currnt=="-" .and. prev==" " .and. delmt == "off" .and. index("0123456789.",forwrd) == 0).or.ipoint > islen)then
         ! beginning of a keyword
         if(forwrd.eq.'-')then                      ! change --var to -var so "long" syntax is supported
            !x!dummy(ifwd:ifwd)='_'
            ipoint=ipoint+1                         ! ignore second - instead (was changing it to _)
            G_keyword_single_letter=.false.         ! flag this is a long keyword
         else
            G_keyword_single_letter=.true.          ! flag this is a short (single letter) keyword
         endif
         if(ipnt(1)-1 >= 1)then                     ! position in value
            ibegin=1
            iend=len_trim(value(:ipnt(1)-1))
            TESTIT: do
               if(iend  ==  0)then                  ! len_trim returned 0, value is blank
                  iend=ibegin
                  exit TESTIT
               elseif(value(ibegin:ibegin) == " ")then
                  ibegin=ibegin+1
               else
                  exit TESTIT
               endif
            enddo TESTIT
            if(keyword.ne.' ')then
               call update(keyword,value)            ! store name and its value
            elseif( G_remaining_option_allowed)then  ! meaning "--" has been encountered
               call update('_args_',trim(value))
            else
               !x!write(warn,'(*(g0))')'*prototype_to_dictionary* warning: ignoring string [',trim(value),'] for ',trim(keyword)
               G_RESPONSE_IGNORED=TRIM(VALUE)
               if(debug_m_cli2)write(*,gen)'<DEBUG>PROTOTYPE_TO_DICTIONARY:G_RESPONSE_IGNORED:',G_RESPONSE_IGNORED
            endif
         else
            call locate_key(keyword,place)
            if(keyword.ne.' '.and.place.lt.0)then
               call update(keyword,'F')           ! store name and null value (first pass)
            elseif(keyword.ne.' ')then
               call update(keyword,' ')           ! store name and null value (second pass)
            elseif(.not.G_keyword_single_letter.and.ipoint-2.eq.islen) then ! -- at end of line
               G_remaining_option_allowed=.true.  ! meaning for "--" is that everything on commandline goes into G_remaining
            endif
         endif
         itype=KEYW                            ! change to expecting a keyword
         value=""                              ! clear value for this variable
         keyword=""                            ! clear variable name
         ipnt(1)=1                             ! restart variable value
         ipnt(2)=1                             ! restart variable name

      else       ! currnt is not one of the special characters
         ! the space after a keyword before the value
         if(currnt == " " .and. itype  ==  KEYW)then
            ! switch from building a keyword string to building a value string
            itype=VAL
            ! beginning of a delimited value
         elseif(currnt  ==  """".and.itype  ==  VAL)then
            ! second of a double quote, put quote in
            if(prev  ==  """")then
               if(itype.eq.VAL)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
               delmt="on"
            elseif(delmt  ==  "on")then     ! first quote of a delimited string
               delmt="off"
            else
               delmt="on"
            endif
            if(prev /= """")then  ! leave quotes where found them
               if(itype.eq.VAL)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
            endif
         else     ! add character to current keyword or value
            if(itype.eq.VAL)then
               value=value//currnt
            else
               keyword=keyword//currnt
            endif
            ipnt(itype)=ipnt(itype)+1
         endif

      endif

      prev=currnt
      if(ipoint <= islen)then
         cycle
      else
         exit
      endif
   enddo

end subroutine prototype_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    specified(3f) - [ARGUMENTS:M_CLI2] return true if keyword was present
!!    on command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental impure function specified(name)
!!
!!     character(len=*),intent(in) :: name
!!     logical :: specified
!!
!!##DESCRIPTION
!!
!!    specified(3f) returns .true. if the specified keyword was present on
!!    the command line.
!!
!!##OPTIONS
!!
!!    NAME   name of commandline argument to query the presence of
!!
!!##RETURNS
!!    SPECIFIED  returns .TRUE. if specified NAME was present on the command
!!               line when the program was invoked.
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!    program demo_specified
!!    use M_CLI2,  only : set_args, get_args, specified
!!    implicit none
!!    ! DEFINE ARGS
!!    integer                 :: flag
!!    integer,allocatable     :: ints(:)
!!    real,allocatable        :: twonames(:)
!!
!!    ! IT IS A BAD IDEA TO NOT HAVE THE SAME DEFAULT VALUE FOR ALIASED
!!    ! NAMES BUT CURRENTLY YOU STILL SPECIFY THEM
!!     call set_args('-flag 1 -f 1 -ints 1,2,3 -i 1,2,3 -twonames 11.3 -T 11.3')
!!
!!    ! ASSIGN VALUES TO ELEMENTS CONDITIONALLY CALLING WITH SHORT NAME
!!     call get_args('flag',flag)
!!     if(specified('f'))call get_args('f',flag)
!!     call get_args('ints',ints)
!!     if(specified('i'))call get_args('i',ints)
!!     call get_args('twonames',twonames)
!!     if(specified('T'))call get_args('T',twonames)
!!
!!     ! IF YOU WANT TO KNOW IF GROUPS OF PARAMETERS WERE SPECIFIED USE
!!     ! ANY(3f) and ALL(3f)
!!     write(*,*)specified(['twonames','T       '])
!!     write(*,*)'ANY:',any(specified(['twonames','T       ']))
!!     write(*,*)'ALL:',all(specified(['twonames','T       ']))
!!
!!     ! FOR MUTUALLY EXCLUSIVE
!!     if (all(specified(['twonames','T       '])))then
!!         write(*,*)'You specified both names -T and -twonames'
!!     endif
!!
!!     ! FOR REQUIRED PARAMETER
!!     if (.not.any(specified(['twonames','T       '])))then
!!         write(*,*)'You must specify -T or -twonames'
!!     endif
!!     ! USE VALUES
!!       write(*,*)'flag=',flag
!!       write(*,*)'ints=',ints
!!       write(*,*)'twonames=',twonames
!!     end program demo_specified
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!===================================================================================================================================
elemental impure function specified(key)
character(len=*),intent(in) :: key
logical                     :: specified
integer                     :: place
   call locate_key(key,place)                   ! find where string is or should be
   if(place.lt.1)then
      specified=.false.
   else
      specified=present_in(place)
   endif
end function specified
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!      update(3f) - [ARGUMENTS:M_CLI2] update internal dictionary given
!!      keyword and value
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine update(key,val)
!!
!!      character(len=*),intent(in)           :: key
!!      character(len=*),intent(in),optional  :: val
!!##DESCRIPTION
!!      Update internal dictionary in M_CLI2(3fm) module.
!!##OPTIONS
!!      key  name of keyword to add, replace, or delete from dictionary
!!      val  if present add or replace value associated with keyword. If not
!!           present remove keyword entry from dictionary.
!!
!!           If "present" is true, a value will be appended
!!##EXAMPLE
!!
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine update(key,val)
character(len=*),intent(in)           :: key
character(len=*),intent(in),optional  :: val
integer                               :: place, ii
integer                               :: iilen
character(len=:),allocatable          :: val_local
character(len=:),allocatable          :: short
character(len=:),allocatable          :: long
character(len=:),allocatable          :: long_short(:)
integer                               :: isize
logical                               :: set_mandatory
   set_mandatory=.false.
   call split(trim(key),long_short,':',nulls='return') ! split long:short keyname or long:short:: or long:: or short::
   ! check for :: on end
   isize=size(long_short)

   if(isize.gt.0)then                     ! very special-purpose syntax where if ends in :: next field is a value even
      if(long_short(isize).eq.'')then     ! if it starts with a dash, for --flags option on fpm(1).
         set_mandatory=.true.
         long_short=long_short(:isize-1)
      endif
   endif

   select case(size(long_short))
   case(0)
      long=''
      short=''
   case(1)
      long=trim(long_short(1))
      if(len_trim(long).eq.1)then
         !x!ii= findloc (shorts, long, dim=1) ! if parsing arguments on line and a short keyword look up long value
         ii=maxloc([0,merge(1, 0, shorts.eq.long)],dim=1)
         if(ii.gt.1)then
            long=keywords(ii-1)
         endif
         short=long
      else
         short=''
      endif
   case(2)
      G_STRICT=.true.  ! strict short and long rules so do not allow -longname and --shortname
      long=trim(long_short(1))
      short=trim(long_short(2))
   case default
      write(warn,*)'WARNING: incorrect syntax for key: ',trim(key)
      long=trim(long_short(1))
      short=trim(long_short(2))
   end select

   if(present(val))then
      val_local=val
      iilen=len_trim(val_local)
      call locate_key(long,place)                  ! find where string is or should be
      if(place.lt.1)then                                ! if string was not found insert it
         call insert(keywords,long,iabs(place))
         call insert(values,val_local,iabs(place))
         call insert(counts,iilen,iabs(place))
         call insert(shorts,short,iabs(place))
         call insert(present_in,.true.,iabs(place))
         call insert(mandatory,set_mandatory,iabs(place))
      else
         if(present_in(place))then                      ! if multiple keywords append values with space between them
            if(G_append)then
               if(values(place)(1:1).eq.'"')then
               ! UNDESIRABLE: will ignore previous blank entries
                  val_local='"'//trim(unquote(values(place)))//' '//trim(unquote(val_local))//'"'
               else
                  val_local=values(place)//' '//val_local
               endif
            endif
            iilen=len_trim(val_local)
         endif
         call replace(values,val_local,place)
         call replace(counts,iilen,place)
         call replace(present_in,.true.,place)
      endif
   else                                                 ! if no value is present remove the keyword and related values
      call locate_key(long,place)                       ! check name as long and short
      if(place.gt.0)then
         call remove(keywords,place)
         call remove(values,place)
         call remove(counts,place)
         call remove(shorts,place)
         call remove(present_in,place)
         call remove(mandatory,place)
      endif
   endif
end subroutine update
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      wipe_dictionary(3fp) - [ARGUMENTS:M_CLI2] reset private M_CLI2(3fm)
!!      dictionary to empty
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!      subroutine wipe_dictionary()
!!##DESCRIPTION
!!      reset private M_CLI2(3fm) dictionary to empty
!!##EXAMPLE
!!
!! Sample program:
!!
!!      program demo_wipe_dictionary
!!      use M_CLI2, only : dictionary
!!         call wipe_dictionary()
!!      end program demo_wipe_dictionary
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine wipe_dictionary()
   if(allocated(keywords))deallocate(keywords)
   allocate(character(len=0) :: keywords(0))
   if(allocated(values))deallocate(values)
   allocate(character(len=0) :: values(0))
   if(allocated(counts))deallocate(counts)
   allocate(counts(0))
   if(allocated(shorts))deallocate(shorts)
   allocate(character(len=0) :: shorts(0))
   if(allocated(present_in))deallocate(present_in)
   allocate(present_in(0))
   if(allocated(mandatory))deallocate(mandatory)
   allocate(mandatory(0))
end subroutine wipe_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get(3f) - [ARGUMENTS:M_CLI2] get dictionary value associated with
!!    key name in private M_CLI2(3fm) dictionary
!!##SYNOPSIS
!!
!!
!!##DESCRIPTION
!!    Get dictionary value associated with key name in private M_CLI2(3fm)
!!    dictionary.
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!===================================================================================================================================
function get(key) result(valout)
character(len=*),intent(in)   :: key
character(len=:),allocatable  :: valout
integer                       :: place
   ! find where string is or should be
   call locate_key(key,place)
   if(place.lt.1)then
      valout=''
   else
      valout=values(place)(:counts(place))
   endif
end function get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      prototype_and_cmd_args_to_nlist(3f) - [ARGUMENTS:M_CLI2] convert
!!      Unix-like command arguments to table
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine prototype_and_cmd_args_to_nlist(prototype)
!!
!!      character(len=*)             :: prototype
!!##DESCRIPTION
!!    create dictionary with character keywords, values, and value lengths
!!    using the routines for maintaining a list from command line arguments.
!!##OPTIONS
!!      prototype
!!##EXAMPLE
!!
!! Sample program
!!
!!      program demo_prototype_and_cmd_args_to_nlist
!!      use M_CLI2,  only : prototype_and_cmd_args_to_nlist, unnamed
!!      implicit none
!!      character(len=:),allocatable :: readme
!!      character(len=256)           :: message
!!      integer                      :: ios
!!      integer                      :: i
!!      doubleprecision              :: something
!!
!!      ! define arguments
!!      logical            :: l,h,v
!!      real               :: p(2)
!!      complex            :: c
!!      doubleprecision    :: x,y,z
!!
!!      ! uppercase keywords get an underscore to make it easier o remember
!!      logical            :: l_,h_,v_
!!      ! character variables must be long enough to hold returned value
!!      character(len=256) :: a_,b_
!!      integer            :: c_(3)
!!
!!         ! give command template with default values
!!         ! all values except logicals get a value.
!!         ! strings must be delimited with double quotes
!!         ! A string has to have at least one character as for -A
!!         ! lists of numbers should be comma-delimited.
!!         ! No spaces are allowed in lists of numbers
!!         call prototype_and_cmd_args_to_nlist('&
!!         & -l -v -h -LVH -x 0 -y 0.0 -z 0.0d0 -p 0,0 &
!!         & -A " " -B "Value B" -C 10,20,30 -c (-123,-456)',readme)
!!
!!         call get_args('x',x,'y',y,'z',z)
!!            something=sqrt(x**2+y**2+z**2)
!!            write (*,*)something,x,y,z
!!            if(size(unnamed).gt.0)then
!!               write (*,'(a)')'files:'
!!               write (*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!            endif
!!      end program demo_prototype_and_cmd_args_to_nlist
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine prototype_and_cmd_args_to_nlist(prototype,string)
implicit none

! ident_5="@(#)M_CLI2::prototype_and_cmd_args_to_nlist: create dictionary from prototype if not null and update from command line"

character(len=*),intent(in)           :: prototype
character(len=*),intent(in),optional  :: string
integer                               :: ibig
integer                               :: itrim
integer                               :: iused

   if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:START'
   G_passed_in=prototype                            ! make global copy for printing
   G_STRICT=.false.  ! strict short and long rules or allow -longname and --shortname

   ibig=longest_command_argument()                  ! bug in gfortran. len=0 should be fine
   ibig=max(ibig,1)
   if(allocated(unnamed))deallocate(unnamed)
   allocate(character(len=ibig) :: unnamed(0))
   if(allocated(args))deallocate(args)
   allocate(character(len=ibig) :: args(0))

   G_remaining_option_allowed=.false.
   G_remaining_on=.false.
   G_remaining=''
   if(prototype.ne.'')then
      call prototype_to_dictionary(prototype)       ! build dictionary from prototype

      ! if short keywords not used by user allow them for standard options

      call locate_key('h',iused)
      if(iused.le.0)then
         call update('help')
         call update('help:h','F')
      endif

      call locate_key('v',iused)
      if(iused.le.0)then
         call update('version')
         call update('version:v','F')
      endif

      call locate_key('V',iused)
      if(iused.le.0)then
         call update('verbose')
         call update('verbose:V','F')
      endif

      call locate_key('u',iused)
      if(iused.le.0)then
         call update('usage')
         call update('usage:u','F')
      endif

      present_in=.false.                            ! reset all values to false so everything gets written
   endif

   if(present(string))then                          ! instead of command line arguments use another prototype string
      if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:CALL PROTOTYPE_TO_DICTIONARY:STRING=',STRING
      call prototype_to_dictionary(string)          ! build dictionary from prototype
   else
      if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:CALL CMD_ARGS_TO_DICTIONARY:CHECK=',.true.
      call cmd_args_to_dictionary()
   endif

   if(len(G_remaining).gt.1)then                    ! if -- was in prototype then after -- on input return rest in this string
      itrim=len(G_remaining)
      if(G_remaining(itrim:itrim).eq.' ')then       ! was adding a space at end as building it, but do not want to remove blanks
         G_remaining=G_remaining(:itrim-1)
      endif
      remaining=G_remaining
   endif
   if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:NORMAL END'
end subroutine prototype_and_cmd_args_to_nlist
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine expand_response(name)
character(len=*),intent(in) :: name
character(len=:),allocatable :: prototype
logical :: hold
   if(debug_m_cli2)write(*,gen)'<DEBUG>EXPAND_RESPONSE:START:NAME=',name
   call get_prototype(name,prototype)
   if(prototype.ne.'')then
      hold=G_append
      G_append=.false.
      if(debug_m_cli2)write(*,gen)'<DEBUG>EXPAND_RESPONSE:CALL PROTOTYPE_TO_DICTIONARY:PROTOTYPE=',prototype
      call prototype_to_dictionary(prototype)       ! build dictionary from prototype
      G_append=hold
   endif
   if(debug_m_cli2)write(*,gen)'<DEBUG>EXPAND_RESPONSE:END'
end subroutine expand_response
!===================================================================================================================================
subroutine get_prototype(name,prototype) ! process @name abbreviations
character(len=*),intent(in) :: name
character(len=:),allocatable,intent(out) :: prototype
character(len=:),allocatable             :: filename
character(len=:),allocatable             :: os
character(len=:),allocatable             :: plain_name
character(len=:),allocatable             :: search_for
integer                                  :: lun
integer                                  :: ios
integer                                  :: itrim
character(len=4096)                      :: line !x! assuming input never this long
character(len=256)                       :: message
character(len=:),allocatable             :: array(:) ! output array of tokens
integer                                  :: lines_processed
   lines_processed=0
   plain_name=name//'  '
   plain_name=trim(name(2:))
   os= '@' // get_env('OSTYPE',get_env('OS'))
   if(debug_m_cli2)write(*,gen)'<DEBUG>GET_PROTOTYPE:OS=',OS

   search_for=''
   ! look for NAME.rsp and see if there is an @OS  section in it and position to it and read
   if(os.ne.'@')then
      search_for=os
      call find_and_read_response_file(plain_name)
      if(lines_processed.ne.0)return
   endif

   ! look for NAME.rsp and see if there is anything before an OS-specific section
   search_for=''
   call find_and_read_response_file(plain_name)
   if(lines_processed.ne.0)return

   ! look for ARG0.rsp  with @OS@NAME  section in it and position to it
   if(os.ne.'@')then
      search_for=os//name
      call find_and_read_response_file(basename(get_name(),suffix=.true.))
      if(lines_processed.ne.0)return
   endif

   ! look for ARG0.rsp  with a section called @NAME in it and position to it
   search_for=name
   call find_and_read_response_file(basename(get_name(),suffix=.true.))
   if(lines_processed.ne.0)return

   write(*,gen)'<ERROR> response name ['//trim(name)//'] not found'
   stop 1
contains
!===================================================================================================================================
subroutine find_and_read_response_file(rname)
! search for a simple file named the same as the @NAME field with one entry assumed in it
character(len=*),intent(in)  :: rname
character(len=:),allocatable :: paths(:)
character(len=:),allocatable :: testpath
character(len=256)           :: message
integer                      :: i
integer                      :: ios
   prototype=''
   ! look for NAME.rsp
   filename=rname//'.rsp'
   if(debug_m_cli2)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:FILENAME=',filename

   ! look for name.rsp in directories from environment variable assumed to be a colon-separated list of directories
   call split(get_env('CLI_RESPONSE_PATH'),paths)
   paths=[character(len=len(paths)) :: ' ',paths]
   if(debug_m_cli2)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:PATHS=',paths

   do i=1,size(paths)
      testpath=join_path(paths(i),filename)
      lun=fileopen(testpath,message)
      if(lun.ne.-1)then
         if(debug_m_cli2)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:SEARCH_FOR=',search_for
         if(search_for.ne.'') call position_response() ! set to end of file or where string was found
         call process_response()
         if(debug_m_cli2)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:LINES_PROCESSED=',LINES_PROCESSED
         close(unit=lun,iostat=ios)
         if(debug_m_cli2)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:CLOSE:LUN=',LUN,' IOSTAT=',IOS
         if(lines_processed.ne.0)exit
      endif
   enddo

end subroutine find_and_read_response_file
!===================================================================================================================================
subroutine position_response()
integer :: ios
   line=''
   INFINITE: do
      read(unit=lun,fmt='(a)',iostat=ios,iomsg=message)line
      if(is_iostat_end(ios))then
         if(debug_m_cli2)write(*,gen)'<DEBUG>POSITION_RESPONSE:EOF'
         backspace(lun,iostat=ios)
         exit INFINITE
      elseif(ios.ne.0)then
         write(*,gen)'<ERROR>*position_response*:'//trim(message)
         exit INFINITE
      endif
      line=adjustl(line)
      if(line.eq.search_for)return
   enddo INFINITE
end subroutine position_response
!===================================================================================================================================
subroutine process_response()
   line=''
   lines_processed=0
      INFINITE: do
      read(unit=lun,fmt='(a)',iostat=ios,iomsg=message)line
      if(is_iostat_end(ios))then
         backspace(lun,iostat=ios)
         exit INFINITE
      elseif(ios.ne.0)then
         write(*,gen)'<ERROR>*process_response*:'//trim(message)
         exit INFINITE
      endif
      line=adjustl(line)
      if(index(line//' ','#').eq.1)cycle
      if(line.ne.'')then

         if(index(line,'@').eq.1.and.lines_processed.ne.0)exit INFINITE

         call split(line,array) ! get first word
         itrim=len_trim(array(1))+2
         line=line(itrim:)

         PROCESS: select case(lower(array(1)))
         case('comment','#','')
         case('system','!','$')
            if(G_options_only)exit PROCESS
            lines_processed= lines_processed+1
            call execute_command_line(line)
         case('options','option','-')
            lines_processed= lines_processed+1
            prototype=prototype//' '//trim(line)
         case('print','>','echo')
            if(G_options_only)exit PROCESS
            lines_processed= lines_processed+1
            write(*,'(a)')trim(line)
         case('stop')
            if(G_options_only)exit PROCESS
            write(*,'(a)')trim(line)
            stop
         case default
            if(array(1)(1:1).eq.'@')cycle INFINITE !skip adjacent @ lines from first
            lines_processed= lines_processed+1
            write(*,'(*(g0))')'unknown response keyword [',array(1),'] with options of [',trim(line),']'
         end select PROCESS

      endif
      enddo INFINITE
end subroutine process_response

end subroutine get_prototype
!===================================================================================================================================
function fileopen(filename,message) result(lun)
character(len=*),intent(in)              :: filename
character(len=*),intent(out),optional    :: message
integer                                  :: lun
integer                                  :: ios
character(len=256)                       :: message_local

   ios=0
   message_local=''
   open(file=filename,newunit=lun,&
    & form='formatted',access='sequential',action='read',&
    & position='rewind',status='old',iostat=ios,iomsg=message_local)

   if(ios.ne.0)then
      lun=-1
      if(present(message))then
         message=trim(message_local)
      else
         write(*,gen)trim(message_local)
      endif
   endif
   if(debug_m_cli2)write(*,gen)'<DEBUG>FILEOPEN:FILENAME=',filename,' LUN=',lun,' IOS=',IOS,' MESSAGE=',trim(message_local)

end function fileopen
!===================================================================================================================================
function get_env(NAME,DEFAULT) result(VALUE)
implicit none
character(len=*),intent(in)          :: NAME
character(len=*),intent(in),optional :: DEFAULT
character(len=:),allocatable         :: VALUE
integer                              :: howbig
integer                              :: stat
integer                              :: length
   ! get length required to hold value
   length=0
   if(NAME.ne.'')then
      call get_environment_variable(NAME, length=howbig,status=stat,trim_name=.true.)
      select case (stat)
      case (1)
          !x!print *, NAME, " is not defined in the environment. Strange..."
          VALUE=''
      case (2)
          !x!print *, "This processor doesn't support environment variables. Boooh!"
          VALUE=''
      case default
          ! make string to hold value of sufficient size
          if(allocated(value))deallocate(value)
          allocate(character(len=max(howbig,1)) :: VALUE)
          ! get value
         call get_environment_variable(NAME,VALUE,status=stat,trim_name=.true.)
          if(stat.ne.0)VALUE=''
      end select
   else
      VALUE=''
   endif
   if(VALUE.eq.''.and.present(DEFAULT))VALUE=DEFAULT
end function get_env
!===================================================================================================================================
function join_path(a1,a2,a3,a4,a5) result(path)
   ! Construct path by joining strings with os file separator
   !
   character(len=*), intent(in)           :: a1, a2
   character(len=*), intent(in), optional :: a3, a4, a5
   character(len=:), allocatable          :: path
   character(len=1)                       :: filesep

   filesep = separator()
   if(a1.ne.'')then
      path = trim(a1) // filesep // trim(a2)
   else
      path = trim(a2)
   endif
   if (present(a3)) path = path // filesep // trim(a3)
   if (present(a4)) path = path // filesep // trim(a4)
   if (present(a5)) path = path // filesep // trim(a5)
   path=adjustl(path//'  ')
   call substitute(path,filesep//filesep,'',start=2) ! some systems allow names starting with '//' or '\\'
   path=trim(path)
end function join_path
!===================================================================================================================================
function get_name() result(name)
! get the pathname of arg0
implicit none
character(len=:),allocatable :: arg0
integer                      :: arg0_length
integer                      :: istat
character(len=4096)          :: long_name
character(len=:),allocatable :: name
   arg0_length=0
   name=''
   long_name=''
   call get_command_argument(0,length=arg0_length,status=istat)
   if(istat.eq.0)then
      if(allocated(arg0))deallocate(arg0)
      allocate(character(len=arg0_length) :: arg0)
      call get_command_argument(0,arg0,status=istat)
      if(istat.eq.0)then
         inquire(file=arg0,iostat=istat,name=long_name)
         name=trim(long_name)
      else
         name=arg0
      endif
   endif
end function get_name
!===================================================================================================================================
function basename(path,suffix) result (base)
    ! Extract filename from path with/without suffix
    !
character(*), intent(In) :: path
logical, intent(in), optional :: suffix
character(:), allocatable :: base

character(:), allocatable :: file_parts(:)
logical :: with_suffix

   if (.not.present(suffix)) then
      with_suffix = .true.
   else
      with_suffix = suffix
   endif

   if (with_suffix) then
      call split(path,file_parts,delimiters='\/')
      if(size(file_parts).gt.0)then
         base = trim(file_parts(size(file_parts)))
      else
         base = ''
      endif
   else
      call split(path,file_parts,delimiters='\/.')
      if(size(file_parts).ge.2)then
         base = trim(file_parts(size(file_parts)-1))
      else
         base = ''
      endif
   endif
end function basename
!===================================================================================================================================
function separator2() result(sep)
! use the pathname returned as arg0 to determine pathname separator
implicit none
character(len=:),allocatable :: arg0
integer                      :: arg0_length
integer                      :: istat
logical                      :: existing
character(len=1)             :: sep
character(len=4096)          :: name
character(len=:),allocatable :: fname
   arg0_length=0
   name=' '
   call get_command_argument(0,length=arg0_length,status=istat)
   if(allocated(arg0))deallocate(arg0)
   allocate(character(len=arg0_length) :: arg0)
   call get_command_argument(0,arg0,status=istat)
   ! check argument name
   if(index(arg0,'\').ne.0)then
      sep='\'
   elseif(index(arg0,'/').ne.0)then
      sep='/'
   else
      ! try name returned by INQUIRE(3f)
      existing=.false.
      name=' '
      inquire(file=arg0,iostat=istat,exist=existing,name=name)
      if(index(name,'\').ne.0)then
         sep='\'
      elseif(index(name,'/').ne.0)then
         sep='/'
      else
         ! well, try some common syntax and assume in current directory
         fname='.\'//arg0
         inquire(file=fname,iostat=istat,exist=existing)
         if(existing)then
            sep='/'
         else
            fname='./'//arg0
            inquire(file=fname,iostat=istat,exist=existing)
            if(existing)then
               sep='/'
            else
               !x!write(*,gen)'<WARNING>unknown system directory path separator'
               sep='/'
            endif
         endif
      endif
   endif
end function separator2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function separator() result(sep)
!>
!!##NAME
!!    separator(3f) - [M_io:ENVIRONMENT] try to determine pathname directory separator character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function separator() result(sep)
!!
!!     character(len=1) :: sep
!!
!!##DESCRIPTION
!!   First testing for the existence of "/.",  then if that fails a list
!!   of variable names assumed to contain directory paths {PATH|HOME} are
!!   examined first for a backslash, then a slash.  Assuming basically the
!!   choice is a ULS or MSWindows system, and users can do weird things like
!!   put a backslash in a ULS path and break it.
!!
!!   Therefore can be very system dependent. If the queries fail the
!!   default returned is "/".
!!
!!##EXAMPLE
!!
!!   sample usage
!!
!!    program demo_separator
!!    use M_io, only : separator
!!    implicit none
!!       write(*,*)'separator=',separator()
!!    end program demo_separator

! use the pathname returned as arg0 to determine pathname separator
implicit none
integer                      :: ios
integer                      :: i
logical                      :: existing=.false.
character(len=1)             :: sep
!x!IFORT BUG:character(len=1),save        :: sep_cache=' '
integer,save                 :: isep=-1
character(len=4096)          :: name
character(len=:),allocatable :: envnames(:)

    ! NOTE:  A parallel code might theoretically use multiple OS
    !x!FORT BUG:if(sep_cache.ne.' ')then  ! use cached value.
    !x!FORT BUG:    sep=sep_cache
    !x!FORT BUG:    return
    !x!FORT BUG:endif
    if(isep.ne.-1)then  ! use cached value.
        sep=char(isep)
        return
    endif
    FOUND: block
    ! simple, but does not work with ifort
    ! most MSWindows environments see to work with backslash even when
    ! using POSIX filenames to do not rely on '\.'.
    inquire(file='/.',exist=existing,iostat=ios,name=name)
    if(existing.and.ios.eq.0)then
        sep='/'
        exit FOUND
    endif
    ! check variables names common to many platforms that usually have a
    ! directory path in them although a ULS file can contain a backslash
    ! and vice-versa (eg. "touch A\\B\\C"). Removed HOMEPATH because it
    ! returned a name with backslash on CygWin, Mingw, WLS even when using
    ! POSIX filenames in the environment.
    envnames=[character(len=10) :: 'PATH', 'HOME']
    do i=1,size(envnames)
       if(index(get_env(envnames(i)),'\').ne.0)then
          sep='\'
          exit FOUND
       elseif(index(get_env(envnames(i)),'/').ne.0)then
          sep='/'
          exit FOUND
       endif
    enddo

    write(*,*)'<WARNING>unknown system directory path separator'
    sep='\'
    endblock FOUND
    !x!IFORT BUG:sep_cache=sep
    isep=ichar(sep)
end function separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine cmd_args_to_dictionary()
! convert command line arguments to dictionary entries
!x!logical                      :: guess_if_value
integer                      :: pointer
character(len=:),allocatable :: lastkeyword
integer                      :: i, jj, kk
integer                      :: ilength, istatus, imax
character(len=1)             :: letter
character(len=:),allocatable :: current_argument
character(len=:),allocatable :: current_argument_padded
character(len=:),allocatable :: dummy
character(len=:),allocatable :: oldvalue
logical                      :: nomore
logical                      :: next_mandatory
   if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:START'
   next_mandatory=.false.
   nomore=.false.
   pointer=0
   lastkeyword=' '
   G_keyword_single_letter=.true.
   i=1
   GET_ARGS: do while (get_next_argument()) ! insert and replace entries

      if( current_argument .eq. '-' .and. nomore .eqv. .true. )then   ! sort of
      elseif( current_argument .eq. '-')then                          ! sort of
         current_argument='"stdin"'
      endif
      if( current_argument .eq. '--' .and. nomore .eqv. .true. )then  ! -- was already encountered
      elseif( current_argument .eq. '--' )then                        ! everything after this goes into the unnamed array
         nomore=.true.
         pointer=0
         if(G_remaining_option_allowed)then
            G_remaining_on=.true.
         endif
         cycle GET_ARGS
      endif

      dummy=current_argument//'   '
      current_argument_padded=current_argument//'   '

      !x!guess_if_value=maybe_value()

      if(.not.next_mandatory.and..not.nomore.and.current_argument_padded(1:2).eq.'--')then    ! beginning of long word
         G_keyword_single_letter=.false.
         if(lastkeyword.ne.'')then
            call ifnull()
         endif
         call locate_key(current_argument_padded(3:),pointer)
         if(pointer.le.0)then
            if(G_QUIET)then
               lastkeyword="UNKNOWN"
               pointer=0
               cycle GET_ARGS
            endif
            call print_dictionary('UNKNOWN LONG KEYWORD: '//current_argument)
            call mystop(1)
            return
         endif
         lastkeyword=trim(current_argument_padded(3:))
         next_mandatory=mandatory(pointer)
      elseif(.not.next_mandatory &
      & .and..not.nomore &
      & .and.current_argument_padded(1:1).eq.'-' &
      & .and.index("0123456789.",dummy(2:2)).eq.0)then
      ! short word
         G_keyword_single_letter=.true.
         if(lastkeyword.ne.'')then
            call ifnull()
         endif
         call locate_key(current_argument_padded(2:),pointer)
         if(pointer.le.0)then
            jj=len(current_argument)
            if(G_STRICT.and.jj.gt.2)then  ! in strict mode this might be multiple single-character values
              do kk=2,jj
                 letter=current_argument_padded(kk:kk)
                 call locate_key(letter,pointer)
                 if(pointer.gt.0)then
                    call update(keywords(pointer),'T')
                 else
                    call print_dictionary('UNKNOWN COMPOUND SHORT KEYWORD:'//letter//' in '//current_argument)
                    if(G_QUIET)then
                       lastkeyword="UNKNOWN"
                       pointer=0
                       cycle GET_ARGS
                    endif
                    call mystop(2)
                    return
                 endif
                 current_argument='-'//current_argument_padded(jj:jj)
              enddo
            else
               call print_dictionary('UNKNOWN SHORT KEYWORD: '//current_argument)
               if(G_QUIET)then
                  lastkeyword="UNKNOWN"
                  pointer=0
                  cycle GET_ARGS
               endif
               call mystop(2)
               return
            endif
         endif
         lastkeyword=trim(current_argument_padded(2:))
         next_mandatory=mandatory(pointer)
      elseif(pointer.eq.0)then                                       ! unnamed arguments
         if(G_remaining_on)then
            if(len(current_argument).lt.1)then
               G_remaining=G_remaining//'"" '
            elseif(current_argument(1:1).eq.'-')then
               !get fancier to handle spaces and =!G_remaining=G_remaining//current_argument//' '
               G_remaining=G_remaining//'"'//current_argument//'" '
            else
               G_remaining=G_remaining//'"'//current_argument//'" '
            endif
            imax=max(len(args),len(current_argument))
            args=[character(len=imax) :: args,current_argument]
         else
            imax=max(len(unnamed),len(current_argument))
            if(index(current_argument//' ','@').eq.1.and.G_response)then
               if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:1:CALL EXPAND_RESPONSE:CURRENT_ARGUMENT=',current_argument
               call expand_response(current_argument)
            else
               unnamed=[character(len=imax) :: unnamed,current_argument]
            endif
         endif
      else
         oldvalue=get(keywords(pointer))//' '
         if(oldvalue(1:1).eq.'"')then
            current_argument=quote(current_argument(:ilength))
         endif
         if(upper(oldvalue).eq.'F'.or.upper(oldvalue).eq.'T')then  ! assume boolean parameter
            if(current_argument.ne.' ')then
               if(G_remaining_on)then
                  if(len(current_argument).lt.1)then
                        G_remaining=G_remaining//'"" '
                  elseif(current_argument(1:1).eq.'-')then
                       !get fancier to handle spaces and =!G_remaining=G_remaining//current_argument//' '
                        G_remaining=G_remaining//'"'//current_argument//'" '
                  else
                        G_remaining=G_remaining//'"'//current_argument//'" '
                  endif
                  imax=max(len(args),len(current_argument))
                  args=[character(len=imax) :: args,current_argument]
               else
                  imax=max(len(unnamed),len(current_argument))
                  if(index(current_argument//' ','@').eq.1.and.G_response)then
               if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:2:CALL EXPAND_RESPONSE:CURRENT_ARGUMENT=',current_argument
                     call expand_response(current_argument)
                  else
                     unnamed=[character(len=imax) :: unnamed,current_argument]
                  endif
               endif
            endif
            current_argument='T'
         endif
         call update(keywords(pointer),current_argument)
         pointer=0
         lastkeyword=''
         next_mandatory=.false.
      endif
   enddo GET_ARGS
   if(lastkeyword.ne.'')then
      call ifnull()
   endif
   if(debug_m_cli2)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:NORMAL END'

contains

subroutine ifnull()
   oldvalue=get(lastkeyword)//' '
   if(upper(oldvalue).eq.'F'.or.upper(oldvalue).eq.'T')then
      call update(lastkeyword,'T')
   elseif(oldvalue(1:1).eq.'"')then
      call update(lastkeyword,'" "')
   else
      call update(lastkeyword,' ')
   endif
end subroutine ifnull

function get_next_argument()
!
! get next argument from command line into allocated variable current_argument
!
logical,save :: hadequal=.false.
character(len=:),allocatable,save :: right_hand_side
logical :: get_next_argument
integer :: iright
integer :: iequal

   if(hadequal)then  ! use left-over value from previous -NAME=VALUE syntax
      current_argument=right_hand_side
      right_hand_side=''
      hadequal=.false.
      get_next_argument=.true.
      ilength=len(current_argument)
      return
   endif

   if(i>command_argument_count())then
      get_next_argument=.false.
      return
   else
      get_next_argument=.true.
   endif

   call get_command_argument(number=i,length=ilength,status=istatus)                              ! get next argument
   if(istatus /= 0) then                                                                          ! on error
      write(warn,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
         &'status=',istatus,&
         &'length=',ilength
      get_next_argument=.false.
   else
      ilength=max(ilength,1)
      if(allocated(current_argument))deallocate(current_argument)
      allocate(character(len=ilength) :: current_argument)
      call get_command_argument(number=i,value=current_argument,length=ilength,status=istatus)    ! get next argument
      if(istatus /= 0) then                                                                       ! on error
         write(warn,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
            &'status=',istatus,&
            &'length=',ilength,&
            &'target length=',len(current_argument)
         get_next_argument=.false.
       endif

       ! if an argument keyword and an equal before a space split on equal and save right hand side for next call
       if(nomore)then
       elseif(len(current_argument).eq.0)then
       else
          iright=index(current_argument,' ')
          if(iright.eq.0)iright=len(current_argument)
          iequal=index(current_argument(:iright),'=')
          if(next_mandatory)then
          elseif(iequal.ne.0.and.current_argument(1:1).eq.'-')then
             if(iequal.ne.len(current_argument))then
                right_hand_side=current_argument(iequal+1:)
             else
                right_hand_side=''
             endif
             hadequal=.true.
             current_argument=current_argument(:iequal-1)
          endif
       endif
   endif
   i=i+1
end function get_next_argument

function maybe_value()
! if previous keyword value type is a string and it was
! given a null string because this value starts with a -
! try to see if this is a string value starting with a -
! to try to solve the vexing problem of values starting
! with a dash.
logical :: maybe_value
integer :: pointer
character(len=:),allocatable :: oldvalue

   oldvalue=get(lastkeyword)//' '
   if(current_argument_padded(1:1).ne.'-')then
      maybe_value=.true.
   elseif(oldvalue(1:1).ne.'"')then
      maybe_value=.false.
   elseif(index(current_argument,' ').ne.0)then
      maybe_value=.true.
   elseif(scan(current_argument,",:;!@#$%^&*+=()[]{}\|'""./><?").ne.0)then
      maybe_value=.true.
   else  ! the last value was a null string so see if this matches an allowed parameter
      pointer=0
      if(current_argument_padded(1:2).eq.'--')then
         call locate_key(current_argument_padded(3:),pointer)
      elseif(current_argument_padded(1:1).eq.'-')then
         call locate_key(current_argument_padded(2:),pointer)
      endif
      if(pointer.le.0)then
         maybe_value=.true.
      else                   ! matched an option name so LIKELY is not a value
         maybe_value=.false.
      endif
   endif
end function maybe_value

end subroutine cmd_args_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     print_dictionary(3f) - [ARGUMENTS:M_CLI2] print internal dictionary
!!     created by calls to set_args(3f)
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine print_dictionary(header,stop)
!!
!!      character(len=*),intent(in),optional :: header
!!      logical,intent(in),optional          :: stop
!!##DESCRIPTION
!!    Print the internal dictionary created by calls to set_args(3f).
!!    This routine is intended to print the state of the argument list
!!    if an error occurs in using the set_args(3f) procedure.
!!##OPTIONS
!!     HEADER  label to print before printing the state of the command
!!             argument list.
!!     STOP    logical value that if true stops the program after displaying
!!             the dictionary.
!!##EXAMPLE
!!
!!
!!
!! Typical usage:
!!
!!       program demo_print_dictionary
!!       use M_CLI2,  only : set_args, get_args
!!       implicit none
!!       real :: x, y, z
!!          call set_args('-x 10 -y 20 -z 30')
!!          call get_args('x',x,'y',y,'z',z)
!!          ! all done cracking the command line; use the values in your program.
!!          write(*,*)x,y,z
!!       end program demo_print_dictionary
!!
!!      Sample output
!!
!!      Calling the sample program with an unknown parameter or the --usage
!!      switch produces the following:
!!
!!         $ ./demo_print_dictionary -A
!!         UNKNOWN SHORT KEYWORD: -A
!!         KEYWORD             PRESENT  VALUE
!!         z                   F        [3]
!!         y                   F        [2]
!!         x                   F        [1]
!!         help                F        [F]
!!         version             F        [F]
!!         usage               F        [F]
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine print_dictionary(header,stop)
character(len=*),intent(in),optional :: header
logical,intent(in),optional          :: stop
integer          :: i
   if(G_QUIET)return
   if(present(header))then
      if(header.ne.'')then
         write(warn,'(a)')header
      endif
   endif
   if(allocated(keywords))then
      if(size(keywords).gt.0)then
         write(warn,'(a,1x,a,1x,a,1x,a)')atleast('KEYWORD',max(len(keywords),8)),'SHORT','PRESENT','VALUE'
         write(warn,'(*(a,1x,a5,1x,l1,8x,"[",a,"]",/))') &
         & (atleast(keywords(i),max(len(keywords),8)),shorts(i),present_in(i),values(i)(:counts(i)),i=1,size(keywords))
      endif
   endif
   if(allocated(unnamed))then
      if(size(unnamed).gt.0)then
         write(warn,'(a)')'UNNAMED'
         write(warn,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
      endif
   endif
   if(allocated(args))then
      if(size(args).gt.0)then
         write(warn,'(a)')'ARGS'
         write(warn,'(i6.6,3a)')(i,'[',args(i),']',i=1,size(args))
      endif
   endif
   if(G_remaining.ne.'')then
      write(warn,'(a)')'REMAINING'
      write(warn,'(a)')G_remaining
   endif
   if(present(stop))then
      if(stop) call mystop(5)
   endif
end subroutine print_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)
! JSU- 20151030

! ident_6="@(#)M_CLI2::strtok(3f): Tokenize a string"

character(len=*),intent(in)  :: source_string    ! Source string to tokenize.
character(len=*),intent(in)  :: delimiters       ! list of separator characters. May change between calls
integer,intent(inout)        :: itoken           ! token count since started
logical                      :: strtok_status    ! returned value
integer,intent(out)          :: token_start      ! beginning of token found if function result is .true.
integer,intent(inout)        :: token_end        ! end of token found if function result is .true.
integer                      :: isource_len
!----------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(itoken.le.0)then                           ! this is assumed to be the first call
      token_start=1
   else                                          ! increment start to previous end + 1
      token_start=token_end+1
   endif
!----------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!----------------------------------------------------------------------------------------------------------------------------
   if(token_start.gt.isource_len)then            ! user input error or at end of string
      token_end=isource_len                      ! assume end of token is end of string until proven otherwise so it is set
      strtok_status=.false.
      return
   endif
!----------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   do while (token_start .le. isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_start:token_start)) .ne. 0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end .le. isource_len-1)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_end+1:token_end+1)) .ne. 0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   if (token_start .gt. isource_len) then        ! determine if finished
      strtok_status=.false.                      ! flag that input string has been completely processed
   else
      itoken=itoken+1                            ! increment count of tokens found
      strtok_status=.true.                       ! flag more tokens may remain
   endif
!----------------------------------------------------------------------------------------------------------------------------
end function strtok
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!     get_args(3f) - [ARGUMENTS:M_CLI2] return keyword values when parsing
!!     command line arguments
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   get_args(3f) and its convenience functions:
!!
!!     use M_CLI2, only : get_args
!!     ! convenience functions
!!     use M_CLI2, only : dget, iget, lget, rget, sget, cget
!!     use M_CLI2, only : dgets, igets, lgets, rgets, sgets, cgets
!!
!!     subroutine get_args(name,value,delimiters)
!!
!!      character(len=*),intent(in) :: name
!!
!!      type(${TYPE}),allocatable,intent(out) :: value(:)
!!      ! or
!!      type(${TYPE}),allocatable,intent(out) :: value
!!
!!      character(len=*),intent(in),optional :: delimiters
!!
!!      where ${TYPE} may be from the set
!!              {real,doubleprecision,integer,logical,complex,character(len=:)}
!!##DESCRIPTION
!!
!!    GET_ARGS(3f) returns the value of keywords after SET_ARGS(3f)
!!    has been called. For fixed-length CHARACTER variables
!!    see GET_ARGS_FIXED_LENGTH(3f). For fixed-size arrays see
!!    GET_ARGS_FIXED_SIZE(3f).
!!
!!    As a convenience multiple pairs of keywords and variables may be
!!    specified if and only if all the values are scalars and the CHARACTER
!!    variables are fixed-length or pre-allocated.
!!
!!##OPTIONS
!!
!!     NAME        name of commandline argument to obtain the value of
!!     VALUE       variable to hold returned value. The kind of the value
!!                 is used to determine the type of returned value. May
!!                 be a scalar or allocatable array. If type is CHARACTER
!!                 the scalar must have an allocatable length.
!!     DELIMITERS  By default the delimiter for array values are comma,
!!                 colon, and whitespace. A string containing an alternate
!!                 list of delimiter characters may be supplied.
!!
!!##CONVENIENCE FUNCTIONS
!!
!!    There are convenience functions that are replacements for calls to
!!    get_args(3f) for each supported default intrinsic type
!!
!!      o scalars -- dget(3f), iget(3f), lget(3f), rget(3f), sget(3f),
!!                   cget(3f)
!!      o vectors -- dgets(3f), igets(3f), lgets(3f), rgets(3f),
!!                   sgets(3f), cgets(3f)
!!
!!    D is for DOUBLEPRECISION, I for INTEGER, L for LOGICAL, R for REAL,
!!    S for string (CHARACTER), and C for COMPLEX.
!!
!!    If the functions are called with no argument they will return the
!!    UNNAMED array converted to the specified type.
!!
!!##EXAMPLE
!!
!!
!! Sample program:
!!
!!     program demo_get_args
!!     use M_CLI2,  only : filenames=>unnamed, set_args, get_args
!!     implicit none
!!     integer                      :: i
!!     ! DEFINE ARGS
!!     real                         :: x, y, z
!!     real,allocatable             :: p(:)
!!     character(len=:),allocatable :: title
!!     logical                      :: l, lbig
!!     ! DEFINE AND PARSE (TO SET INITIAL VALUES) COMMAND LINE
!!     !   o only quote strings and use double-quotes
!!     !   o set all logical values to F or T.
!!     call set_args(' &
!!        &-x 1 -y 2 -z 3 &
!!        &-p -1,-2,-3 &
!!        &--title "my title" &
!!        & -l F -L F  &
!!        & --label " " &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!     ! SCALARS
!!     call get_args('x',x,'y',y,'z',z)
!!     call get_args('l',l)
!!     call get_args('L',lbig)
!!     ! ALLOCATABLE STRING
!!     call get_args('title',title)
!!     ! NON-ALLOCATABLE ARRAYS
!!     call get_args('p',p)
!!     ! USE VALUES
!!     write(*,'(1x,g0,"=",g0)')'x',x, 'y',y, 'z',z
!!     write(*,*)'p=',p
!!     write(*,*)'title=',title
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     if(size(filenames).gt.0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!     end program demo_get_args
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!>
!!##NAME
!!    get_args_fixed_length(3f) - [ARGUMENTS:M_CLI2] return keyword values
!!    for fixed-length string when parsing command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine get_args_fixed_length(name,value)
!!
!!     character(len=:),allocatable :: value
!!     character(len=*),intent(in),optional :: delimiters
!!
!!##DESCRIPTION
!!
!!    GET_ARGS_fixed_length(3f) returns the value of a string
!!    keyword when the string value is a fixed-length CHARACTER
!!    variable.
!!
!!##OPTIONS
!!
!!    NAME   name of commandline argument to obtain the value of
!!
!!    VALUE  variable to hold returned value.
!!           Must be a fixed-length CHARACTER variable.
!!
!!    DELIMITERS  By default the delimiter for array values are comma,
!!                colon, and whitespace. A string containing an alternate
!!                list of delimiter characters may be supplied.
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!     program demo_get_args_fixed_length
!!     use M_CLI2,  only : set_args, get_args_fixed_length
!!     implicit none
!!     ! DEFINE ARGS
!!     character(len=80)   :: title
!!     call set_args(' &
!!        & -title "my title" &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!        call get_args_fixed_length('title',title)
!!     ! USE VALUES
!!        write(*,*)'title=',title
!!     end program demo_get_args_fixed_length
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!>
!!##NAME
!!    get_args_fixed_size(3f) - [ARGUMENTS:M_CLI2] return keyword values
!!    for fixed-size array when parsing command line arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine get_args_fixed_size(name,value)
!!
!!     [real|doubleprecision|integer|logical|complex] :: value(NNN)
!!        or
!!     character(len=MMM) :: value(NNN)
!!
!!     character(len=*),intent(in),optional :: delimiters
!!
!!##DESCRIPTION
!!
!!    GET_ARGS_FIXED_SIZE(3f) returns the value of keywords for
!!    fixed-size arrays after SET_ARGS(3f) has been called.
!!    On input on the command line all values of the array must
!!    be specified.
!!
!!##OPTIONS
!!    NAME        name of commandline argument to obtain the value of
!!
!!    VALUE       variable to hold returned values. The kind of the value
!!                is used to determine the type of returned value. Must be
!!                a fixed-size array. If type is CHARACTER the length must
!!                also be fixed.
!!
!!    DELIMITERS  By default the delimiter for array values are comma,
!!                colon, and whitespace. A string containing an alternate
!!                list of delimiter characters may be supplied.
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!     program demo_get_args_fixed_size
!!     use M_CLI2,  only : set_args, get_args_fixed_size
!!     implicit none
!!     integer,parameter   :: dp=kind(0.0d0)
!!     ! DEFINE ARGS
!!     real                :: x(2)
!!     real(kind=dp)       :: y(2)
!!     integer             :: p(3)
!!     character(len=80)   :: title(1)
!!     logical             :: l(4), lbig(4)
!!     complex             :: cmp(2)
!!     ! DEFINE AND PARSE (TO SET INITIAL VALUES) COMMAND LINE
!!     !   o only quote strings
!!     !   o set all logical values to F or T.
!!     call set_args(' &
!!        & -x 10.0,20.0 &
!!        & -y 11.0,22.0 &
!!        & -p -1,-2,-3 &
!!        & -title "my title" &
!!        & -l F,T,F,T -L T,F,T,F  &
!!        & --cmp 111,222.0,333.0e0,4444 &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!        call get_args_fixed_size('x',x)
!!        call get_args_fixed_size('y',y)
!!        call get_args_fixed_size('p',p)
!!        call get_args_fixed_size('title',title)
!!        call get_args_fixed_size('l',l)
!!        call get_args_fixed_size('L',lbig)
!!        call get_args_fixed_size('cmp',cmp)
!!     ! USE VALUES
!!        write(*,*)'x=',x
!!        write(*,*)'p=',p
!!        write(*,*)'title=',title
!!        write(*,*)'l=',l
!!        write(*,*)'L=',lbig
!!        write(*,*)'cmp=',cmp
!!     end program demo_get_args_fixed_size
!!   Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine get_fixedarray_class(keyword,generic,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
class(*)                             :: generic(:)
character(len=*),intent(in),optional :: delimiters
   select type(generic)
    type is (character(len=*));  call get_fixedarray_fixed_length_c(keyword,generic,delimiters)
    type is (integer);           call get_fixedarray_i(keyword,generic,delimiters)
    type is (real);              call get_fixedarray_r(keyword,generic,delimiters)
    type is (complex);           call get_fixed_size_complex(keyword,generic,delimiters)
    type is (real(kind=dp));     call get_fixedarray_d(keyword,generic,delimiters)
    type is (logical);           call get_fixedarray_l(keyword,generic,delimiters)
    class default
      call mystop(-7,'*get_fixedarray_class* crud -- procedure does not know about this type')
   end select
end subroutine get_fixedarray_class
!===================================================================================================================================
! return allocatable arrays
!===================================================================================================================================
subroutine get_anyarray_l(keyword,larray,delimiters)

! ident_7="@(#)M_CLI2::get_anyarray_l(3f): given keyword fetch logical array from string in dictionary(F on err)"

character(len=*),intent(in)  :: keyword                    ! the dictionary keyword (in form VERB_KEYWORD) to retrieve
logical,allocatable          :: larray(:)                  ! convert value to an array
character(len=*),intent(in),optional   :: delimiters
character(len=:),allocatable :: carray(:)                  ! convert value to an array
character(len=:),allocatable :: val
integer                      :: i
integer                      :: place
integer                      :: iichar                     ! point to first character of word unless first character is "."
   call locate_key(keyword,place)                          ! find where string is or should be
   if(place.gt.0)then                                      ! if string was found
      val=values(place)(:counts(place))
      call split(adjustl(upper(val)),carray,delimiters=delimiters)  ! convert value to uppercase, trimmed; then parse into array
   else
      call journal('sc','*get_anyarray_l* unknown keyword '//keyword)
      call mystop(8 ,'*get_anyarray_l* unknown keyword '//keyword)
      if(allocated(larray))deallocate(larray)
      allocate(larray(0))
      return
   endif
   if(size(carray).gt.0)then                                  ! if not a null string
      if(allocated(larray))deallocate(larray)
      allocate(larray(size(carray)))                          ! allocate output array
      do i=1,size(carray)
         larray(i)=.false.                                    ! initialize return value to .false.
         if(carray(i)(1:1).eq.'.')then                        ! looking for fortran logical syntax .STRING.
            iichar=2
         else
            iichar=1
         endif
         select case(carray(i)(iichar:iichar))             ! check word to see if true or false
         case('T','Y',' '); larray(i)=.true.               ! anything starting with "T" or "Y" or a blank is TRUE (true,yes,...)
         case('F','N');     larray(i)=.false.              ! assume this is false or no
         case default
            call journal('sc',"*get_anyarray_l* bad logical expression for "//trim(keyword)//'='//carray(i))
         end select
      enddo
   else                                                       ! for a blank string return one T
      if(allocated(larray))deallocate(larray)
      allocate(larray(1))                                     ! allocate output array
      larray(1)=.true.
   endif
end subroutine get_anyarray_l
!===================================================================================================================================
subroutine get_anyarray_d(keyword,darray,delimiters)

! ident_8="@(#)M_CLI2::get_anyarray_d(3f): given keyword fetch dble value array from Language Dictionary (0 on err)"

character(len=*),intent(in)           :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp),allocatable,intent(out) :: darray(:)    ! function type
character(len=*),intent(in),optional  :: delimiters

character(len=:),allocatable          :: carray(:)    ! convert value to an array using split(3f)
integer                               :: i
integer                               :: place
integer                               :: ierr
character(len=:),allocatable          :: val
!-----------------------------------------------------------------------------------------------------------------------------------
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place.gt.0)then                                 ! if string was found
      val=values(place)(:counts(place))
      val=replace_str(val,'(','')
      val=replace_str(val,')','')
      call split(val,carray,delimiters=delimiters)    ! find value associated with keyword and split it into an array
   else
      call journal('sc','*get_anyarray_d* unknown keyword '//keyword)
      call mystop(9 ,'*get_anyarray_d* unknown keyword '//keyword)
      if(allocated(darray))deallocate(darray)
      allocate(darray(0))
      return
   endif
   if(allocated(darray))deallocate(darray)
   allocate(darray(size(carray)))                     ! create the output array
   do i=1,size(carray)
      call a2d(carray(i), darray(i),ierr) ! convert the string to a numeric value
      if(ierr.ne.0)then
         call mystop(10 ,'*get_anyarray_d* unreadable value '//carray(i)//' for keyword '//keyword)
      endif
   enddo
end subroutine get_anyarray_d
!===================================================================================================================================
subroutine get_anyarray_i(keyword,iarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
integer,allocatable                  :: iarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
   call get_anyarray_d(keyword,darray,delimiters)
   iarray=nint(darray)
end subroutine get_anyarray_i
!===================================================================================================================================
subroutine get_anyarray_r(keyword,rarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real,allocatable                     :: rarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
   call get_anyarray_d(keyword,darray,delimiters)
   rarray=real(darray)
end subroutine get_anyarray_r
!===================================================================================================================================
subroutine get_anyarray_x(keyword,xarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
complex,allocatable                  :: xarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: half,sz,i
   call get_anyarray_d(keyword,darray,delimiters)
   sz=size(darray)
   half=sz/2
   if(sz.ne.half+half)then
      call journal('sc','*get_anyarray_x* uneven number of values defining complex value '//keyword)
      call mystop(11,'*get_anyarray_x* uneven number of values defining complex value '//keyword)
      if(allocated(xarray))deallocate(xarray)
      allocate(xarray(0))
   endif

   !x!================================================================================================
   !x!IFORT,GFORTRAN OK, NVIDIA RETURNS NULL ARRAY: xarray=cmplx(real(darray(1::2)),real(darray(2::2)))
   if(allocated(xarray))deallocate(xarray)
   allocate(xarray(half))
   do i=1,sz,2
      xarray((i+1)/2)=cmplx( darray(i),darray(i+1) )
   enddo
   !x!================================================================================================

end subroutine get_anyarray_x
!===================================================================================================================================
subroutine get_anyarray_c(keyword,strings,delimiters)

! ident_8="@(#)M_CLI2::get_anyarray_c(3f): Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)          :: keyword       ! name to look up in dictionary
character(len=:),allocatable         :: strings(:)
character(len=*),intent(in),optional :: delimiters
integer                              :: place
character(len=:),allocatable         :: val
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,strings,delimiters=delimiters)   ! find value associated with keyword and split it into an array
   else
      call journal('sc','*get_anyarray_c* unknown keyword '//keyword)
      call mystop(12,'*get_anyarray_c* unknown keyword '//keyword)
      if(allocated(strings))deallocate(strings)
      allocate(character(len=0)::strings(0))
   endif
end subroutine get_anyarray_c
!===================================================================================================================================
!===================================================================================================================================
subroutine get_args_fixed_length_a_array(keyword,strings,delimiters)

! ident_9="@(#)M_CLI2::get_args_fixed_length_a_array(3f): Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)          :: keyword       ! name to look up in dictionary
character(len=*),allocatable         :: strings(:)
character(len=*),intent(in),optional :: delimiters
character(len=:),allocatable         :: strings_a(:)
integer                              :: place
character(len=:),allocatable         :: val
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,strings_a,delimiters=delimiters)   ! find value associated with keyword and split it into an array
      if(len(strings_a).le.len(strings))then
         strings=strings_a
      else
         call journal('sc','*get_args_fixed_length_a_array* values too long. Longest is',len(strings_a),'allowed is',len(strings))
         write(*,'("strings=",3x,*(a,1x))')strings
         call journal('sc','*get_args_fixed_length_a_array* keyword='//keyword)
         call mystop(13,'*get_args_fixed_length_a_array* keyword='//keyword)
         strings=[character(len=len(strings)) ::]
      endif
   else
      call journal('sc','*get_args_fixed_length_a_array* unknown keyword '//keyword)
      call mystop(14,'*get_args_fixed_length_a_array* unknown keyword '//keyword)
      strings=[character(len=len(strings)) ::]
   endif
end subroutine get_args_fixed_length_a_array
!===================================================================================================================================
! return non-allocatable arrays
!===================================================================================================================================
subroutine get_fixedarray_i(keyword,iarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
integer                              :: iarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: dsize
   call get_anyarray_d(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(iarray,dim=1).eq.dsize)then
      iarray=nint(darray)
   else
      call journal('sc','*get_fixedarray_i* wrong number of values for keyword',keyword,'got',dsize,'expected',size(iarray))
      call print_dictionary('USAGE:')
      call mystop(33)
      iarray=0
   endif
end subroutine get_fixedarray_i
!===================================================================================================================================
subroutine get_fixedarray_r(keyword,rarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real                                 :: rarray(:)
character(len=*),intent(in),optional :: delimiters
real,allocatable                     :: darray(:)    ! function type
integer                              :: dsize
   call get_anyarray_r(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(rarray,dim=1).eq.dsize)then
      rarray=darray
   else
      call journal('sc','*get_fixedarray_r* wrong number of values for keyword',keyword,'got',dsize,'expected',size(rarray))
      call print_dictionary('USAGE:')
      call mystop(33)
      rarray=0.0
   endif
end subroutine get_fixedarray_r
!===================================================================================================================================
subroutine get_fixed_size_complex(keyword,xarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
complex                              :: xarray(:)
character(len=*),intent(in),optional :: delimiters
complex,allocatable                  :: darray(:)    ! function type
integer                              :: half, sz
integer                              :: dsize
   call get_anyarray_x(keyword,darray,delimiters)
   dsize=size(darray)
   sz=dsize*2
   half=sz/2
   if(sz.ne.half+half)then
      call journal('sc','*get_fixed_size_complex* uneven number of values defining complex value '//keyword)
      call mystop(15,'*get_fixed_size_complex* uneven number of values defining complex value '//keyword)
      xarray=0
      return
   endif
   if(ubound(xarray,dim=1).eq.dsize)then
      xarray=darray
   else
      call journal('sc','*get_fixed_size_complex* wrong number of values for keyword',keyword,'got',dsize,'expected',size(xarray))
      call print_dictionary('USAGE:')
      call mystop(34)
      xarray=cmplx(0.0,0.0)
   endif
end subroutine get_fixed_size_complex
!===================================================================================================================================
subroutine get_fixedarray_d(keyword,darr,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp)                        :: darr(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: dsize
   call get_anyarray_d(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(darr,dim=1).eq.dsize)then
      darr=darray
   else
      call journal('sc','*get_fixedarray_d* wrong number of values for keyword',keyword,'got',dsize,'expected',size(darr))
      call print_dictionary('USAGE:')
      call mystop(35)
      darr=0.0d0
   endif
end subroutine get_fixedarray_d
!===================================================================================================================================
subroutine get_fixedarray_l(keyword,larray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
logical                              :: larray(:)
character(len=*),intent(in),optional :: delimiters
logical,allocatable                  :: darray(:)    ! function type
integer                              :: dsize
   call get_anyarray_l(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(larray,dim=1).eq.dsize)then
      larray=darray
   else
      call journal('sc','*get_fixedarray_l* wrong number of values for keyword',keyword,'got',dsize,'expected',size(larray))
      call print_dictionary('USAGE:')
      call mystop(36)
      larray=.false.
   endif
end subroutine get_fixedarray_l
!===================================================================================================================================
subroutine get_fixedarray_fixed_length_c(keyword,strings,delimiters)

! ident_10="@(#)M_CLI2::get_fixedarray_fixed_length_c(3f): Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*)                     :: strings(:)
character(len=*),intent(in),optional :: delimiters
character(len=:),allocatable         :: str(:)
character(len=*),intent(in)          :: keyword   ! name to look up in dictionary
integer                              :: place
integer                              :: ssize
character(len=:),allocatable         :: val
   call locate_key(keyword,place)                 ! find where string is or should be
   if(place > 0)then                              ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,str,delimiters=delimiters)   ! find value associated with keyword and split it into an array
      ssize=size(str)
      if(ssize==size(strings))then
         strings(:ssize)=str
      else
         call journal('sc','*get_fixedarray_fixed_length_c* wrong number of values for keyword',&
            & keyword,'got',ssize,'expected ',size(strings)) !,ubound(strings,dim=1)
         call print_dictionary('USAGE:')
         call mystop(30,'*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
         strings=''
      endif
   else
      call journal('sc','*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
      call mystop(16,'*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
      strings=''
   endif
end subroutine get_fixedarray_fixed_length_c
!===================================================================================================================================
! return scalars
!===================================================================================================================================
subroutine get_scalar_d(keyword,d)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp)                 :: d
real(kind=dp),allocatable     :: darray(:)    ! function type
   call get_anyarray_d(keyword,darray)
   if(size(darray).eq.1)then
      d=darray(1)
   else
      call journal('sc','*get_anyarray_d* incorrect number of values for keyword',keyword,'expected one found',size(darray))
      call print_dictionary('USAGE:')
      call mystop(31,'*get_anyarray_d* incorrect number of values for keyword'//keyword//'expected one')
   endif
end subroutine get_scalar_d
!===================================================================================================================================
subroutine get_scalar_real(keyword,r)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
real,intent(out)              :: r
real(kind=dp)                 :: d
   call get_scalar_d(keyword,d)
   r=real(d)
end subroutine get_scalar_real
!===================================================================================================================================
subroutine get_scalar_i(keyword,i)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
integer,intent(out)           :: i
real(kind=dp)                 :: d
   call get_scalar_d(keyword,d)
   i=nint(d)
end subroutine get_scalar_i
!===================================================================================================================================
subroutine get_scalar_anylength_c(keyword,string)

! ident_11="@(#)M_CLI2::get_scalar_anylength_c(3f): Fetch string value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)   :: keyword              ! name to look up in dictionary
character(len=:),allocatable,intent(out)  :: string
integer                       :: place
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return string
      string=unquote(values(place)(:counts(place)))
   else
      call mystop(17,'*get_anyarray_c* unknown keyword '//keyword)
      call journal('sc','*get_anyarray_c* unknown keyword '//keyword)
      string=''
   endif
end subroutine get_scalar_anylength_c
!===================================================================================================================================
elemental impure subroutine get_args_fixed_length_scalar_c(keyword,string)

! ident_12="@(#)M_CLI2::get_args_fixed_length_scalar_c(3f): Fetch string value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)   :: keyword              ! name to look up in dictionary
character(len=*),intent(out)  :: string
integer                       :: place
integer                       :: unlen
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return string
      string=unquote(values(place)(:counts(place)))
   else
      call mystop(18,'*get_args_fixed_length_scalar_c* unknown keyword '//keyword)
      string=''
   endif
   unlen=len_trim(unquote(values(place)(:counts(place))))
   if(unlen>len(string))then
      call journal('sc','*get_args_fixed_length_scalar_c* value too long for',keyword,'allowed is',len(string),&
      & 'input string [',values(place),'] is',unlen)
      call mystop(19,'*get_args_fixed_length_scalar_c* value too long')
      string=''
   endif
end subroutine get_args_fixed_length_scalar_c
!===================================================================================================================================
subroutine get_scalar_complex(keyword,x)
character(len=*),intent(in) :: keyword      ! keyword to retrieve value from dictionary
complex,intent(out)         :: x
real(kind=dp)               :: d(2)
   call get_fixedarray_d(keyword,d)
   if(size(d).eq.2)then
      x=cmplx(d(1),d(2),kind=sp)
   else
      call journal('sc','*get_scalar_complex* expected two values found',size(d))
      call mystop(20,'*get_scalar_complex* incorrect number of values for keyword '//keyword)
      x=cmplx(0.0,0.0)
   endif
end subroutine get_scalar_complex
!===================================================================================================================================
subroutine get_scalar_logical(keyword,l)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
logical                       :: l
logical,allocatable           :: larray(:)    ! function type
   call get_anyarray_l(keyword,larray)
   if(size(larray).eq.1)then
      l=larray(1)
   else
      call journal('sc','*get_anyarray_l* expected one value found',size(larray))
      call mystop(21,'*get_anyarray_l* incorrect number of values for keyword '//keyword)
      l=.false.
   endif
end subroutine get_scalar_logical
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! THE REMAINDER SHOULD BE ROUTINES EXTRACTED FROM OTHER MODULES TO MAKE THIS MODULE STANDALONE BY POPULAR REQUEST
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!use M_strings,                     only : UPPER, LOWER, QUOTE, REPLACE_STR=>REPLACE, UNQUOTE, SPLIT, STRING_TO_VALUE
!use M_list,                        only : insert, locate, remove, replace
!use M_journal,                     only : JOURNAL

!use M_args,                        only : LONGEST_COMMAND_ARGUMENT
! routines extracted from other modules
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_command_argument(3f) - [ARGUMENTS:M_args] length of longest
!!    argument on command line
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function longest_command_argument() result(ilongest)
!!
!!     integer :: ilongest
!!
!!##DESCRIPTION
!!    length of longest argument on command line. Useful when allocating
!!    storage for holding arguments.
!!##RESULT
!!    longest_command_argument  length of longest command argument
!!##EXAMPLE
!!
!! Sample program
!!
!!      program demo_longest_command_argument
!!      use M_args, only : longest_command_argument
!!         write(*,*)'longest argument is ',longest_command_argument()
!!      end program demo_longest_command_argument
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
function longest_command_argument() result(ilongest)
integer :: i
integer :: ilength
integer :: istatus
integer :: ilongest
   ilength=0
   ilongest=0
   GET_LONGEST: do i=1,command_argument_count()                             ! loop throughout command line arguments to find longest
      call get_command_argument(number=i,length=ilength,status=istatus)     ! get next argument
      if(istatus /= 0) then                                                 ! on error
         write(warn,*)'*prototype_and_cmd_args_to_nlist* error obtaining length for argument ',i
         exit GET_LONGEST
      elseif(ilength.gt.0)then
         ilongest=max(ilongest,ilength)
      endif
   enddo GET_LONGEST
end function longest_command_argument
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine journal(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep)
implicit none

! ident_13="@(#)M_CLI2::journal(3f): writes a message to a string composed of any standard scalar types"

character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8 ,g9
class(*),intent(in),optional  :: ga, gb, gc, gd, ge, gf, gg, gh ,gi, gj
character(len=*),intent(in),optional :: sep
if(debug_m_cli2)write(*,*)'<DEBUG>JOURNAL:',present(g1)
if(debug_m_cli2)write(*,*)'<DEBUG>JOURNAL:',present(g2)
if(debug_m_cli2)write(*,*)'<DEBUG>JOURNAL:',present(sep)
write(*,'(a)')str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep)
end subroutine journal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    str(3f) - [M_CLI2] converts any standard scalar type to a string
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep)
!!
!!     class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!     character(len=*),intent(in),optional :: sep
!!     character,len=(:),allocatable :: str
!!
!!##DESCRIPTION
!!    str(3f) builds a space-separated string from up to twenty scalar values.
!!
!!##OPTIONS
!!    g[0-9a-j]   optional value to print the value of after the message. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!
!!                Optionally, all the generic values can be
!!                single-dimensioned arrays. Currently, mixing scalar
!!                arguments and array arguments is not supported.
!!
!!    sep         separator to place between values. Defaults to a space.
!!##RETURNS
!!    str     description to print
!!##EXAMPLES
!!
!! Sample program:
!!
!!       program demo_msg
!!       use M_CLI2, only : str
!!       implicit none
!!       character(len=:),allocatable :: pr
!!       character(len=:),allocatable :: frmt
!!       integer                      :: biggest
!!
!!       pr=str('HUGE(3f) integers',huge(0),'and real',&
!!               & huge(0.0),'and double',huge(0.0d0))
!!       write(*,'(a)')pr
!!       pr=str('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) )
!!       write(*,'(a)')pr
!!       pr=str('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!       write(*,'(a)')pr
!!       pr=str('complex         :',cmplx(huge(0.0),tiny(0.0)) )
!!       write(*,'(a)')pr
!!
!!       ! create a format on the fly
!!       biggest=huge(0)
!!       frmt=str('(*(i',int(log10(real(biggest))),':,1x))',sep=' ')
!!       write(*,*)'format=',frmt
!!
!!       ! although it will often work, using str(3f) in an I/O statement
!!       ! is not recommended because if an error occurs str(3f) will try
!!       ! to write while part of an I/O statement which not all compilers
!!       ! can handle and is currently non-standard
!!       write(*,*)str('program will now stop')
!!
!!       end program demo_msg
!!
!!  Output
!!
!!     HUGE(3f) integers 2147483647 and real 3.40282347E+38 and
!!     double 1.7976931348623157E+308
!!     real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!     doubleprecision : 1.7976931348623157E+308 0.0000000000000000
!!     12345.678900000001 2.2250738585072014E-308
!!     complex         : (3.40282347E+38,1.17549435E-38)
!!      format=(*(i9:,1x))
!!      program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
implicit none

! ident_14="@(#)M_CLI2::msg_scalar(3fp): writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(debug_m_cli2)write(*,gen)'<DEBUG>:MSG_SCALAR'
   if(present(sep))then
      sep_local=sep
      increment=len(sep_local)+1
   else
      sep_local=' '
      increment=2
   endif
   if(debug_m_cli2)write(*,gen)'<DEBUG>:MSG_SCALAR'

   istart=1
   line=''
   if(debug_m_cli2)write(*,gen)'<DEBUG>:MSG_SCALAR:CALL GENERIC:GENERIC0'
   if(present(generic0))call print_generic(generic0)
   if(debug_m_cli2)write(*,gen)'<DEBUG>:MSG_SCALAR:CALL GENERIC:GENERIC1'
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   msg_scalar=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:START'
   if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:LINE',trim(line)
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64))
         if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:REAL64'
         write(line(istart:),'(1pg0)') generic
      !x! DOES NOT WORK WITH NVFORTRAN: type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
      type is (logical)
         if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:REAL64'
         write(line(istart:),'(l1)') generic
      type is (character(len=*))
         if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:CHARACTER'
         if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:ISTART:',istart
         write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:START'
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none

! ident_15="@(#)M_CLI2::msg_one(3fp): writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep_local)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
      !x! DOES NOT WORK WITH nvfortran: type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
      !x! DOES NOT WORK WITH ifort:     type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*))
         if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:CHARACTER'
         if(debug_m_cli2)write(*,gen)'<DEBUG>PRINT_GENERIC:ISTART:',istart
         write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         call mystop(-22,'unknown type in *print_generic*')
   end select
   istart=len_trim(line)+increment+1
   line=trim(line)//"]"//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function upper(str) result (string)

! ident_16="@(#)M_CLI2::upper(3f): Changes a string to uppercase"

character(*), intent(in)      :: str
character(:),allocatable      :: string
integer                       :: i
   string = str
   do i = 1, len_trim(str)
       select case (str(i:i))
       case ('a':'z')
          string(i:i) = char(iachar(str(i:i))-32)
       end select
   end do
end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function lower(str) result (string)

! ident_17="@(#)M_CLI2::lower(3f): Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(:),allocatable     :: string
integer                      :: i
   string = str
   do i = 1, len_trim(str)
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32)
      end select
   end do
end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine a2i(chars,valu,ierr)

! ident_18="@(#)M_CLI2::a2i(3fp): subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8.le.huge(valu))then
      if(valu8.le.huge(valu))then
         valu=int(valu8)
      else
         call journal('sc','*a2i*','- value too large',valu8,'>',huge(valu))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

! ident_19="@(#)M_CLI2::a2d(3fp): subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o  works with any g-format input, including integer, real, and exponential.
!  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!     IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=unquote(chars)
   msg=''
   if(len(local_chars).eq.0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd.ne.0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//i2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//i2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//i2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr.ne.0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars.ne.'eod')then                           ! print warning message except for special value "eod"
         call journal('sc','*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(msg.ne.'')then
            call journal('sc','*a2d* - ['//trim(msg)//']')
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_CLI2:TOKENS] parse string into an array using specified
!!    delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!##DESCRIPTION
!!    SPLIT(3f) parses a string using specified delimiter characters and
!!    store tokens into an allocatable array
!!
!!##OPTIONS
!!
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!
!!    NULLS IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_split
!!     use M_CLI2, only: split
!!     character(len=*),parameter     :: &
!!     & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!     character(len=:),allocatable :: array(:) ! output array of tokens
!!        write(*,*)'INPUT LINE:['//LINE//']'
!!        write(*,'(80("="))')
!!        write(*,*)'typical call:'
!!        CALL split(line,array)
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)'custom list of delimiters (colon and vertical line):'
!!        CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)&
!!      &'custom list of delimiters, reverse array order and count null fields:'
!!        CALL split(line,array,delimiters=':|',order='reverse',nulls='return')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)'INPUT LINE:['//LINE//']'
!!        write(*,*)&
!!        &'default delimiters and reverse array order and return null fields:'
!!        CALL split(line,array,delimiters='',order='reverse',nulls='return')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!     end program demo_split
!!
!!   Output
!!
!!    > INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!    > ===========================================================================
!!    >  typical call:
!!    > 1 ==> aBcdef
!!    > 2 ==> ghijklmnop
!!    > 3 ==> qrstuvwxyz
!!    > 4 ==> 1:|:2
!!    > 5 ==> 333|333
!!    > 6 ==> a
!!    > 7 ==> B
!!    > 8 ==> cc
!!    >  SIZE:           8
!!    > --------------------------------------------------------------------------
!!    >  custom list of delimiters (colon and vertical line):
!!    > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!    > 2 ==> 2     333
!!    > 3 ==> 333 a B cc
!!    >  SIZE:           3
!!    > --------------------------------------------------------------------------
!!    >  custom list of delimiters, reverse array order and return null fields:
!!    > 1 ==> 333 a B cc
!!    > 2 ==> 2     333
!!    > 3 ==>
!!    > 4 ==>
!!    > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!    >  SIZE:           5
!!    > --------------------------------------------------------------------------
!!    >  INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!    >  default delimiters and reverse array order and count null fields:
!!    > 1 ==>
!!    > 2 ==>
!!    > 3 ==>
!!    > 4 ==> cc
!!    > 5 ==> B
!!    > 6 ==> a
!!    > 7 ==> 333|333
!!    > 8 ==>
!!    > 9 ==>
!!    > 10 ==>
!!    > 11 ==>
!!    > 12 ==> 1:|:2
!!    > 13 ==>
!!    > 14 ==> qrstuvwxyz
!!    > 15 ==> ghijklmnop
!!    > 16 ==>
!!    > 17 ==>
!!    > 18 ==> aBcdef
!!    > 19 ==>
!!    > 20 ==>
!!    >  SIZE:          20
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_20="@(#)M_CLI2::split(3f): parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: iilen                  ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters.ne.'')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)//',:' ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)//',:'    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)    !x! intel compiler says allocated already ???
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   if(allocated(iterm))deallocate(iterm)      !x! intel compiler says allocated already ???
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   iilen=len(input_line)                                          ! IILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
   if(iilen.gt.0)then                                             ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,iilen,1                                  ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)).eq.0)then  ! if current character is not a delimiter
            iterm(i30)=iilen                                      ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):iilen),dlim(i10:i10))
               IF(ifound.gt.0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol.gt.iilen)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   if(allocated(array))deallocate(array)
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                       ! allocate the array to turn
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(ordr)))                              ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20).lt.ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    replace_str(3f) - [M_CLI2:EDITING] function globally replaces one
!!    substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function replace_str(targetline[,old,new|cmd],range,ierr) result (newline)
!!
!!     character(len=*)                       :: targetline
!!     character(len=*),intent(in),optional   :: old
!!     character(len=*),intent(in),optional   :: new
!!     character(len=*),intent(in),optional   :: cmd
!!     integer,intent(in),optional            :: range(2)
!!     integer,intent(out),optional           :: ierr
!!     logical,intent(in),optional            :: clip
!!     character(len=:),allocatable           :: newline
!!##DESCRIPTION
!!    Globally replace one substring for another in string.
!!    Either CMD or OLD and NEW must be specified.
!!
!!##OPTIONS
!!     targetline  input line to be changed
!!     old         old substring to replace
!!     new         new substring
!!     cmd         alternate way to specify old and new string, in
!!                 the form c/old/new/; where "/" can be any character
!!                 not in "old" or "new"
!!     range       if present, only change range(1) to range(2) of
!!                 occurrences of old string
!!     ierr        error code. iF ier = -1 bad directive, >= 0 then
!!                 count of changes made
!!     clip        whether to return trailing spaces or not. Defaults to .false.
!!##RETURNS
!!     newline     allocatable string returned
!!
!!##EXAMPLES
!!
!! Sample Program:
!!
!!       program demo_replace_str
!!       use M_CLI2, only : replace_str
!!       implicit none
!!       character(len=:),allocatable :: targetline
!!
!!       targetline='this is the input string'
!!
!!       call testit('th','TH','THis is THe input string')
!!
!!       ! a null old substring means "at beginning of line"
!!       call testit('','BEFORE:', 'BEFORE:THis is THe input string')
!!
!!       ! a null new string deletes occurrences of the old substring
!!       call testit('i','', 'BEFORE:THs s THe nput strng')
!!
!!       write(*,*)'Examples of the use of RANGE='
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','A')
!!       write(*,*)'replace a with A ['//targetline//']'
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','A',range=[3,5])
!!       write(*,*)'replace a with A instances 3 to 5 ['//targetline//']'
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','',range=[3,5])
!!       write(*,*)'replace a with null instances 3 to 5 ['//targetline//']'
!!
!!       targetline=replace_str('a b ab baaa aaaa aa aa a a a aa aaaaaa',&
!!        & 'aa','CCCC',range=[3,5])
!!       write(*,*)'replace aa with CCCC instances 3 to 5 ['//targetline//']'
!!
!!       contains
!!       subroutine testit(old,new,expected)
!!       character(len=*),intent(in) :: old,new,expected
!!       write(*,*)repeat('=',79)
!!       write(*,*)':STARTED ['//targetline//']'
!!       write(*,*)':OLD['//old//']', ' NEW['//new//']'
!!       targetline=replace_str(targetline,old,new)
!!       write(*,*)':GOT     ['//targetline//']'
!!       write(*,*)':EXPECTED['//expected//']'
!!       write(*,*)':TEST    [',targetline.eq.expected,']'
!!       end subroutine testit
!!
!!       end program demo_replace_str
!!
!!   Expected output
!!
!!     ===============================================================================
!!     STARTED [this is the input string]
!!     OLD[th] NEW[TH]
!!     GOT     [THis is THe input string]
!!     EXPECTED[THis is THe input string]
!!     TEST    [ T ]
!!     ===============================================================================
!!     STARTED [THis is THe input string]
!!     OLD[] NEW[BEFORE:]
!!     GOT     [BEFORE:THis is THe input string]
!!     EXPECTED[BEFORE:THis is THe input string]
!!     TEST    [ T ]
!!     ===============================================================================
!!     STARTED [BEFORE:THis is THe input string]
!!     OLD[i] NEW[]
!!     GOT     [BEFORE:THs s THe nput strng]
!!     EXPECTED[BEFORE:THs s THe nput strng]
!!     TEST    [ T ]
!!     Examples of the use of RANGE=
!!     replace a with A [A b Ab bAAA AAAA]
!!     replace a with A instances 3 to 5 [a b ab bAAA aaaa]
!!     replace a with null instances 3 to 5 [a b ab b aaaa]
!!     replace aa with CCCC instances 3 to 5 [a b ab baaa aaCCCC CCCC CCCC
!!     a a a aa aaaaaa]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine crack_cmd(cmd,old,new,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)              :: cmd
character(len=:),allocatable,intent(out) :: old,new                ! scratch string buffers
integer                                  :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=1)                         :: delimiters
integer                                  :: itoken
integer,parameter                        :: id=2                   ! expected location of delimiter
logical                                  :: ifok
integer                                  :: lmax                   ! length of target string
integer                                  :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr=0
   old=''
   new=''
   lmax=len_trim(cmd)                       ! significant length of change directive

   if(lmax.ge.4)then                      ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)               ! find delimiter in expected location
      itoken=0                            ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id).eq.cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token .eq. (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*crack_cmd* incorrect change directive -too short')
   endif

end subroutine crack_cmd
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function replace_str(targetline,old,new,ierr,cmd,range) result (newline)

! ident_21="@(#)M_CLI2::replace_str(3f): Globally replace one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
! parameters
character(len=*),intent(in)            :: targetline   ! input line to be changed
character(len=*),intent(in),optional   :: old          ! old substring to replace
character(len=*),intent(in),optional   :: new          ! new substring
integer,intent(out),optional           :: ierr         ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
character(len=*),intent(in),optional   :: cmd          ! contains the instructions changing the string
integer,intent(in),optional            :: range(2)     ! start and end of which changes to make
!-----------------------------------------------------------------------------------------------------------------------------------
! returns
character(len=:),allocatable  :: newline               ! output string buffer
!-----------------------------------------------------------------------------------------------------------------------------------
! local
character(len=:),allocatable  :: new_local, old_local
integer                       :: icount,ichange,ier2
integer                       :: original_input_length
integer                       :: len_old, len_new
integer                       :: ladd
integer                       :: left_margin, right_margin
integer                       :: ind
integer                       :: ic
integer                       :: iichar
integer                       :: range_local(2)
!-----------------------------------------------------------------------------------------------------------------------------------
!  get old_local and new_local from cmd or old and new
   if(present(cmd))then
      call crack_cmd(cmd,old_local,new_local,ier2)
      if(ier2.ne.0)then
         newline=targetline  ! if no changes are made return original string on error
         if(present(ierr))ierr=ier2
         return
      endif
   elseif(present(old).and.present(new))then
      old_local=old
      new_local=new
   else
      newline=targetline  ! if no changes are made return original string on error
      call journal('sc','*replace_str* must specify OLD and NEW or CMD')
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   icount=0                                            ! initialize error flag/change count
   ichange=0                                           ! initialize error flag/change count
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   len_old=len(old_local)                              ! length of old substring to be replaced
   len_new=len(new_local)                              ! length of new substring to replace old substring
   left_margin=1                                       ! left_margin is left margin of window to change
   right_margin=len(targetline)                        ! right_margin is right margin of window to change
   newline=''                                          ! begin with a blank line as output string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(range))then
      range_local=range
   else
      range_local=[1,original_input_length]
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old.eq.0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      iichar=len_new + original_input_length
      if(len_new.gt.0)then
         newline=new_local(:len_new)//targetline(left_margin:original_input_length)
      else
         newline=targetline(left_margin:original_input_length)
      endif
      ichange=1                                        ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ichange
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   iichar=left_margin                                  ! place to put characters into output string
   ic=left_margin                                      ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old_local(:len_old))+ic-1 ! try finding start of OLD in remaining part of input in change window
      if(ind.eq.ic-1.or.ind.gt.right_margin)then          ! did not find old string or found old string past edit window
         exit loop                                        ! no more changes left to make
      endif
      icount=icount+1                                  ! found an old string to change, so increment count of change candidates
      if(ind.gt.ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         newline=newline(:iichar-1)//targetline(ic:ind-1)
         iichar=iichar+ladd
      endif
      if(icount.ge.range_local(1).and.icount.le.range_local(2))then    ! check if this is an instance to change or keep
         ichange=ichange+1
         if(len_new.ne.0)then                                          ! put in new string
            newline=newline(:iichar-1)//new_local(:len_new)
            iichar=iichar+len_new
         endif
      else
         if(len_old.ne.0)then                                          ! put in copy of old string
            newline=newline(:iichar-1)//old_local(:len_old)
            iichar=iichar+len_old
         endif
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ichange)
   case (0)                                            ! there were no changes made to the window
      newline=targetline                               ! if no changes made output should be input
   case default
      if(ic.le.len(targetline))then                    ! if there is more after last change on original line add it
         newline=newline(:iichar-1)//targetline(ic:max(ic,original_input_length))
      endif
   end select
   if(present(ierr))ierr=ichange
!-----------------------------------------------------------------------------------------------------------------------------------
end function replace_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     quote(3f) - [M_CLI2:QUOTES] add quotes to string as if written with
!!     list-directed input
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!   function quote(str,mode,clip) result (quoted_str)
!!
!!    character(len=*),intent(in)          :: str
!!    character(len=*),optional,intent(in) :: mode
!!    logical,optional,intent(in)          :: clip
!!    character(len=:),allocatable         :: quoted_str
!!##DESCRIPTION
!!    Add quotes to a CHARACTER variable as if it was written using
!!    list-directed input. This is particularly useful for processing
!!    strings to add to CSV files.
!!
!!##OPTIONS
!!    str         input string to add quotes to, using the rules of
!!                list-directed input (single quotes are replaced by two
!!                adjacent quotes)
!!    mode        alternate quoting methods are supported:
!!
!!                   DOUBLE   default. replace quote with double quotes
!!                   ESCAPE   replace quotes with backslash-quote instead
!!                            of double quotes
!!
!!    clip        default is to trim leading and trailing spaces from the
!!                string. If CLIP
!!                is .FALSE. spaces are not trimmed
!!
!!##RESULT
!!    quoted_str  The output string, which is based on adding quotes to STR.
!!##EXAMPLE
!!
!! Sample program:
!!
!!     program demo_quote
!!     use M_CLI2, only : quote
!!     implicit none
!!     character(len=:),allocatable :: str
!!     character(len=1024)          :: msg
!!     integer                      :: ios
!!     character(len=80)            :: inline
!!        do
!!           write(*,'(a)',advance='no')'Enter test string:'
!!           read(*,'(a)',iostat=ios,iomsg=msg)inline
!!           if(ios.ne.0)then
!!              write(*,*)trim(inline)
!!              exit
!!           endif
!!
!!           ! the original string
!!           write(*,'(a)')'ORIGINAL     ['//trim(inline)//']'
!!
!!           ! the string processed by quote(3f)
!!           str=quote(inline)
!!           write(*,'(a)')'QUOTED     ['//str//']'
!!
!!           ! write the string list-directed to compare the results
!!           write(*,'(a)',iostat=ios,iomsg=msg) 'LIST DIRECTED:'
!!           write(*,*,iostat=ios,iomsg=msg,delim='none') inline
!!           write(*,*,iostat=ios,iomsg=msg,delim='quote') inline
!!           write(*,*,iostat=ios,iomsg=msg,delim='apostrophe') inline
!!        enddo
!!     end program demo_quote
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function quote(str,mode,clip) result (quoted_str)
character(len=*),intent(in)          :: str                ! the string to be quoted
character(len=*),optional,intent(in) :: mode
logical,optional,intent(in)          :: clip
logical                              :: clip_local
character(len=:),allocatable         :: quoted_str

character(len=1),parameter           :: double_quote = '"'
character(len=20)                    :: local_mode
!-----------------------------------------------------------------------------------------------------------------------------------
   local_mode=merge_str(mode,'DOUBLE',present(mode))
   if(present(clip))then
      clip_local=clip
   else
      clip_local=.false.
   endif
   if(clip_local)then
      quoted_str=adjustl(str)
   else
      quoted_str=str
   endif
   select case(lower(local_mode))
   case('double')
      quoted_str=double_quote//trim(replace_str(quoted_str,'"','""'))//double_quote
   case('escape')
      quoted_str=double_quote//trim(replace_str(quoted_str,'"','\"'))//double_quote
   case default
      call journal('sc','*quote* ERROR: unknown quote mode ',local_mode)
      quoted_str=str
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
end function quote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     unquote(3f) - [M_CLI2:QUOTES] remove quotes from string as if read
!!     with list-directed input
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!   pure function unquote(quoted_str,esc) result (unquoted_str)
!!
!!    character(len=*),intent(in)          :: quoted_str
!!    character(len=1),optional,intent(in) :: esc
!!    character(len=:),allocatable         :: unquoted_str
!!##DESCRIPTION
!!    Remove quotes from a CHARACTER variable as if it was read using
!!    list-directed input. This is particularly useful for processing
!!    tokens read from input such as CSV files.
!!
!!    Fortran can now read using list-directed input from an internal file,
!!    which should handle quoted strings, but list-directed input does not
!!    support escape characters, which UNQUOTE(3f) does.
!!##OPTIONS
!!    quoted_str  input string to remove quotes from, using the rules of
!!                list-directed input (two adjacent quotes inside a quoted
!!                region are replaced by a single quote, a single quote or
!!                double quote is selected as the delimiter based on which
!!                is encountered first going from left to right, ...)
!!    esc         optional character used to protect the next quote
!!                character from being processed as a quote, but simply as
!!                a plain character.
!!##RESULT
!!    unquoted_str  The output string, which is based on removing quotes
!!                  from quoted_str.
!!##EXAMPLE
!!
!! Sample program:
!!
!!       program demo_unquote
!!       use M_CLI2, only : unquote
!!       implicit none
!!       character(len=128)           :: quoted_str
!!       character(len=:),allocatable :: unquoted_str
!!       character(len=1),parameter   :: esc='\'
!!       character(len=1024)          :: msg
!!       integer                      :: ios
!!       character(len=1024)          :: dummy
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=ios,iomsg=msg)quoted_str
!!          if(ios.ne.0)then
!!             write(*,*)trim(msg)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
!!
!!          ! the string processed by unquote(3f)
!!          unquoted_str=unquote(trim(quoted_str),esc)
!!          write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
!!
!!          ! read the string list-directed to compare the results
!!          read(quoted_str,*,iostat=ios,iomsg=msg)dummy
!!          if(ios.ne.0)then
!!             write(*,*)trim(msg)
!!          else
!!             write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
!!          endif
!!       enddo
!!       end program demo_unquote
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
pure function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str              ! the string to be unquoted
character(len=1),optional,intent(in) :: esc                     ! escape character
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote                   ! whichever quote is to be used
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(esc))then                           ! select escape character as specified character or special value meaning not set
      iesc=ichar(esc)                             ! allow for an escape character
   else
      iesc=-1                                     ! set to value that matches no character
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   inlen=len(quoted_str)                          ! find length of input string
   if(allocated(unquoted_str))deallocate(unquoted_str)
   allocate(character(len=inlen) :: unquoted_str) ! initially make output string length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(inlen.ge.1)then                             ! double_quote is the default quote unless the first character is single_quote
      if(quoted_str(1:1).eq.single_quote)then
         quote=ichar(single_quote)
      else
         quote=ichar(double_quote)
      endif
   else
      quote=ichar(double_quote)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   before=-2                                      ! initially set previous character to impossible value
   unquoted_str(:)=''                             ! initialize output string to null string
   iput=1
   inside=.false.
   STEPTHROUGH: do i=1,inlen
      current=ichar(quoted_str(i:i))
      if(before.eq.iesc)then                      ! if previous character was escape use current character unconditionally
           iput=iput-1                            ! backup
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2                              ! this could be second esc or quote
      elseif(current.eq.quote)then                ! if current is a quote it depends on whether previous character was a quote
         if(before.eq.quote)then
           unquoted_str(iput:iput)=char(quote)    ! this is second quote so retain it
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before.ne.iesc)then
            inside=.true.
         else                                     ! this is first quote so ignore it except remember it in case next is a quote
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo STEPTHROUGH
!-----------------------------------------------------------------------------------------------------------------------------------
   unquoted_str=unquoted_str(:iput-1)
!-----------------------------------------------------------------------------------------------------------------------------------
end function unquote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

! ident_22="@(#)M_CLI2::i2s(3fp): private function returns string given integer value"

integer,intent(in)           :: ivalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    merge_str(3f) - [M_CLI2:LENGTH] pads strings to same length and then
!!                    calls MERGE(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function merge_str(str1,str2,expr) result(strout)
!!
!!     character(len=*),intent(in),optional :: str1
!!     character(len=*),intent(in),optional :: str2
!!     logical,intent(in)              :: expr
!!     character(len=:),allocatable    :: strout
!!##DESCRIPTION
!!    merge_str(3f) pads the shorter of str1 and str2 to the longest length
!!    of str1 and str2 and then calls MERGE(padded_str1,padded_str2,expr).
!!    It trims trailing spaces off the result and returns the trimmed
!!    string. This makes it easier to call MERGE(3f) with strings, as
!!    MERGE(3f) requires the strings to be the same length.
!!
!!    NOTE: STR1 and STR2 are always required even though declared optional.
!!          this is so the call "STR_MERGE(A,B,present(A))" is a valid call.
!!          The parameters STR1 and STR2 when they are optional parameters
!!          can be passed to a procedure if the options are optional on the
!!          called procedure.
!!
!!##OPTIONS
!!    STR1    string to return if the logical expression EXPR is true
!!    STR2    string to return if the logical expression EXPR is false
!!    EXPR    logical expression to evaluate to determine whether to return
!!            STR1 when true, and STR2 when false.
!!##RESULT
!!     MERGE_STR  a trimmed string is returned that is otherwise the value
!!                of STR1 or STR2, depending on the logical expression EXPR.
!!
!!##EXAMPLES
!!
!! Sample Program:
!!
!!     program demo_merge_str
!!     use M_CLI2, only : merge_str
!!     implicit none
!!     character(len=:), allocatable :: answer
!!        answer=merge_str('first string', 'second string is longer',10.eq.10)
!!        write(*,'("[",a,"]")') answer
!!        answer=merge_str('first string', 'second string is longer',10.ne.10)
!!        write(*,'("[",a,"]")') answer
!!     end program demo_merge_str
!!
!!   Expected output
!!
!!     [first string]
!!     [second string is longer]
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

! ident_23="@(#)M_CLI2::merge_str(3f): pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in),optional :: str1
character(len=*),intent(in),optional :: str2
character(len=:),allocatable         :: str1_local
character(len=:),allocatable         :: str2_local
logical,intent(in)                   :: expr
character(len=:),allocatable         :: strout
integer                              :: big
   if(present(str2))then
      str2_local=str2
   else
      str2_local=''
   endif
   if(present(str1))then
      str1_local=str1
   else
      str1_local=''
   endif
   big=max(len(str1_local),len(str2_local))
   ! note: perhaps it would be better to warn or fail if an optional value that is not present is returned, instead of returning ''
   strout=trim(merge(lenset(str1_local,big),lenset(str2_local,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    decodebase(3f) - [M_CLI2:BASE] convert whole number string in base
!!                     [2-36] to base 10 number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function decodebase(string,basein,out10)
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in)           :: basein
!!    integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!    Convert a numeric string representing a whole number in base BASEIN
!!    to base 10. The function returns FALSE if BASEIN is not in the range
!!    [2..36] or if string STRING contains invalid characters in base BASEIN
!!    or if result OUT10 is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##EXAMPLE
!!
!! Sample program:
!!
!!      program demo_decodebase
!!      use M_CLI2, only : codebase, decodebase
!!      implicit none
!!      integer           :: ba,bd
!!      character(len=40) :: x,y
!!      integer           :: r
!!
!!      print *,' BASE CONVERSION'
!!      write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!      write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!      INFINITE: do
!!         print *,''
!!         write(*,'("Enter number in start base: ")',advance='no'); read *, x
!!         if(x.eq.'0') exit INFINITE
!!         if(decodebase(x,bd,r)) then
!!            if(codebase(r,ba,y)) then
!!              write(*,'("In base ",I2,": ",A20)')  ba, y
!!            else
!!              print *,'Error in coding number.'
!!            endif
!!         else
!!            print *,'Error in decoding number.'
!!         endif
!!      enddo INFINITE
!!
!!      end program demo_decodebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function decodebase(string,basein,out_baseten)
implicit none

! ident_24="@(#)M_CLI2::decodebase(3f): convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein.eq.0.and.ipound.gt.1)then                                  ! split string into two values
     call a2i(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local.ge.0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch.eq.'-'.and.k.eq.1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lenset(3f) - [M_CLI2:LENGTH] return string trimmed or padded to
!!                 specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lenset(str,length) result(strout)
!!
!!     character(len=*)                     :: str
!!     character(len=length)                :: strout
!!     integer,intent(in)                   :: length
!!##DESCRIPTION
!!    lenset(3f) truncates a string or pads it with spaces to the specified
!!    length.
!!##OPTIONS
!!    str     input string
!!    length  output string length
!!##RESULTS
!!    strout  output string
!!##EXAMPLE
!!
!! Sample Program:
!!
!!     program demo_lenset
!!      use M_CLI2, only : lenset
!!      implicit none
!!      character(len=10)            :: string='abcdefghij'
!!      character(len=:),allocatable :: answer
!!         answer=lenset(string,5)
!!         write(*,'("[",a,"]")') answer
!!         answer=lenset(string,20)
!!         write(*,'("[",a,"]")') answer
!!     end program demo_lenset
!!
!!    Expected output:
!!
!!     [abcde]
!!     [abcdefghij          ]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function lenset(line,length) result(strout)

! ident_25="@(#)M_CLI2::lenset(3f): return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      value_to_string(3f) - [M_CLI2:NUMERIC] return numeric string from
!!                            a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine value_to_string(value,chars[,iilen,ierr,fmt,trimz])
!!
!!     character(len=*) :: chars  ! minimum of 23 characters required
!!     !--------
!!     ! VALUE may be any <em>one</em> of the following types:
!!     doubleprecision,intent(in)               :: value
!!     real,intent(in)                          :: value
!!     integer,intent(in)                       :: value
!!     logical,intent(in)                       :: value
!!     !--------
!!     character(len=*),intent(out)             :: chars
!!     integer,intent(out),optional             :: iilen
!!     integer,optional                         :: ierr
!!     character(len=*),intent(in),optional     :: fmt
!!     logical,intent(in)                       :: trimz
!!
!!##DESCRIPTION
!!    value_to_string(3f) returns a numeric representation of a numeric
!!    value in a string given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the string using internal writes. It
!!    then removes trailing zeros from non-zero values, and left-justifies
!!    the string.
!!
!!##OPTIONS
!!       VALUE   input value to be converted to a string
!!       FMT     You may specify a specific format that produces a string
!!               up to the length of CHARS; optional.
!!       TRIMZ   If a format is supplied the default is not to try to trim
!!               trailing zeros. Set TRIMZ to .true. to trim zeros from a
!!               string assumed to represent a simple numeric value.
!!
!!##RETURNS
!!       CHARS   returned string representing input value, must be at least
!!               23 characters long; or what is required by optional FMT
!!               if longer.
!!       IILEN   position of last non-blank character in returned string;
!!               optional.
!!       IERR    If not zero, error occurred; optional.
!!##EXAMPLE
!!
!! Sample program:
!!
!!      program demo_value_to_string
!!      use M_CLI2, only: value_to_string
!!      implicit none
!!      character(len=80) :: string
!!      integer           :: iilen
!!         call value_to_string(3.0/4.0,string,iilen)
!!         write(*,*) 'The value is [',string(:iilen),']'
!!
!!         call value_to_string(3.0/4.0,string,iilen,fmt='')
!!         write(*,*) 'The value is [',string(:iilen),']'
!!
!!         call value_to_string(3.0/4.0,string,iilen,fmt='("THE VALUE IS ",g0)')
!!         write(*,*) 'The value is [',string(:iilen),']'
!!
!!         call value_to_string(1234,string,iilen)
!!         write(*,*) 'The value is [',string(:iilen),']'
!!
!!         call value_to_string(1.0d0/3.0d0,string,iilen)
!!         write(*,*) 'The value is [',string(:iilen),']'
!!
!!      end program demo_value_to_string
!!
!!    Expected output
!!
!!     The value is [0.75]
!!     The value is [      0.7500000000]
!!     The value is [THE VALUE IS .750000000]
!!     The value is [1234]
!!     The value is [0.33333333333333331]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

! ident_26="@(#)M_CLI2::value_to_string(3fp): subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         call journal('sc','*value_to_string* UNKNOWN TYPE')
         chars=' '
      end select
      if(fmt.eq.'') then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.').ne.0) call trimzeros_(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local.ne.0)then
      !-! cannot currently do I/O from a function being called from I/O
      !-!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros_(3fp) - [M_CLI2:NUMERIC] Delete trailing zeros from numeric
!!                      `decimal string
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine trimzeros_(str)
!!
!!     character(len=*)  :: str
!!##DESCRIPTION
!!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a
!!    number. If the resulting string would end in a decimal point, one
!!    trailing zero is added.
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have
!!          trailing zeros removed
!!##EXAMPLES
!!
!! Sample program:
!!
!!       program demo_trimzeros_
!!       use M_CLI2, only : trimzeros_
!!       character(len=:),allocatable :: string
!!          write(*,*)trimzeros_('123.450000000000')
!!          write(*,*)trimzeros_('12345')
!!          write(*,*)trimzeros_('12345.')
!!          write(*,*)trimzeros_('12345.00e3')
!!       end program demo_trimzeros_
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine trimzeros_(string)

! ident_27="@(#)M_CLI2::trimzeros_(3fp): Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: expo         ! the exponent string if present
integer                      :: ipos         ! where exponent letter appears if present
integer                      :: i, ii
   str=string                                ! working copy of string
   ipos=scan(str,'eEdD')                     ! find end of real number if string uses exponent notation
   if(ipos>0) then                           ! letter was found
      expo=str(ipos:)                        ! keep exponent string so it can be added back as a suffix
      str=str(1:ipos-1)                      ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if(index(str,'.').eq.0)then               ! if no decimal character in original string add one to end of string
      ii=len_trim(str)
      str(ii+1:ii+1)='.'                     ! add decimal to end of string
   endif
   do i=len_trim(str),1,-1                   ! scanning from end find a non-zero character
      select case(str(i:i))
      case('0')                              ! found a trailing zero so keep trimming
         cycle
      case('.')                              ! found a decimal character at end of remaining string
         if(i.le.1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)                        ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if(ipos>0)then                            ! if originally had an exponent place it back on
      string=trim(str)//trim(expo)
   else
      string=str
   endif
end subroutine trimzeros_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    substitute(3f) - [M_CLI2:EDITING] subroutine globally substitutes
!!                     one substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine substitute(targetline,old,new,ierr,start,end)
!!
!!     character(len=*)              :: targetline
!!     character(len=*),intent(in)   :: old
!!     character(len=*),intent(in)   :: new
!!     integer,intent(out),optional  :: ierr
!!     integer,intent(in),optional   :: start
!!     integer,intent(in),optional   :: end
!!##DESCRIPTION
!!    Globally substitute one substring for another in string.
!!
!!##OPTIONS
!!     TARGETLINE  input line to be changed. Must be long enough to
!!                 hold altered output.
!!     OLD         substring to find and replace
!!     NEW         replacement for OLD substring
!!     IERR        error code. If IER = -1 bad directive, >= 0 then
!!                 count of changes made.
!!     START       sets the left margin to be scanned for OLD in
!!                 TARGETLINE.
!!     END         sets the right margin to be scanned for OLD in
!!                 TARGETLINE.
!!
!!##EXAMPLES
!!
!! Sample Program:
!!
!!     program demo_substitute
!!     use M_CLI2, only : substitute
!!     implicit none
!!     ! must be long enough to hold changed line
!!     character(len=80) :: targetline
!!
!!     targetline='this is the input string'
!!     write(*,*)'ORIGINAL    : '//trim(targetline)
!!
!!     ! changes the input to 'THis is THe input string'
!!     call substitute(targetline,'th','TH')
!!     write(*,*)'th => TH    : '//trim(targetline)
!!
!!     ! a null old substring means "at beginning of line"
!!     ! changes the input to 'BEFORE:this is the input string'
!!     call substitute(targetline,'','BEFORE:')
!!     write(*,*)'"" => BEFORE: '//trim(targetline)
!!
!!     ! a null new string deletes occurrences of the old substring
!!     ! changes the input to 'ths s the nput strng'
!!     call substitute(targetline,'i','')
!!     write(*,*)'i => ""     : '//trim(targetline)
!!
!!     end program demo_substitute
!!
!!   Expected output
!!
!!     ORIGINAL    : this is the input string
!!     th => TH    : THis is THe input string
!!     "" => BEFORE: BEFORE:THis is THe input string
!!     i => ""     : BEFORE:THs s THe nput strng
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine substitute(targetline,old,new,ierr,start,end)

! ident_28="@(#)M_CLI2::substitute(3f): Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: iichar
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option !-! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id.le.0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old.eq.0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      iichar=len_new + original_input_length
      if(iichar.gt.maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new.gt.0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   iichar=il                                           ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind.eq.ic-1.or.ind.gt.ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind.gt.ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(iichar-1+ladd.gt.maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(iichar:)=targetline(ic:ind-1)
         iichar=iichar+ladd
      endif
      if(iichar-1+len_new.gt.maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new.ne.0)then
         dum1(iichar:)=new(:len_new)
         iichar=iichar+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      call journal('sc','*substitute* new line will be too long')
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(iichar+ladd.gt.maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic.lt.len(targetline))then
         dum1(iichar:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    locate(3f) - [M_CLI2] finds the index where a string is found or
!!                 should be in a sorted array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine locate(list,value,place,ier,errmsg)
!!
!!    character(len=:)|doubleprecision|real|integer,allocatable :: list(:)
!!    character(len=*)|doubleprecision|real|integer,intent(in)  :: value
!!    integer, intent(out)                  :: PLACE
!!
!!    integer, intent(out),optional         :: IER
!!    character(len=*),intent(out),optional :: ERRMSG
!!
!!##DESCRIPTION
!!
!!    LOCATE(3f) finds the index where the VALUE is found or should
!!    be found in an array. The array must be sorted in descending
!!    order (highest at top). If VALUE is not found it returns the index
!!    where the name should be placed at with a negative sign.
!!
!!    The array and list must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL,INTEGER)
!!
!!##OPTIONS
!!
!!    VALUE         the value to locate in the list.
!!    LIST          is the list array.
!!
!!##RETURNS
!!    PLACE         is the subscript that the entry was found at if it is
!!                  greater than zero(0).
!!
!!                  If PLACE is negative, the absolute value of
!!                  PLACE indicates the subscript value where the
!!                  new entry should be placed in order to keep the
!!                  list alphabetized.
!!
!!    IER           is zero(0) if no error occurs.
!!                  If an error occurs and IER is not
!!                  present, the program is stopped.
!!
!!    ERRMSG        description of any error
!!
!!##EXAMPLES
!!
!!
!! Find if a string is in a sorted array, and insert the string into
!! the list if it is not present ...
!!
!!     program demo_locate
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate
!!     implicit none
!!     character(len=:),allocatable  :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, plus, ii, end
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     write(*,*)'for "'//string//'" index is ',place, size(arr)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        plus=abs(place)
!!        ii=len(arr)
!!        end=size(arr)
!!        ! empty array
!!        if(end.eq.0)then
!!           arr=[character(len=ii) :: string ]
!!        ! put in front of array
!!        elseif(plus.eq.1)then
!!           arr=[character(len=ii) :: string, arr]
!!        ! put at end of array
!!        elseif(plus.eq.end)then
!!           arr=[character(len=ii) :: arr, string ]
!!        ! put in middle of array
!!        else
!!           arr=[character(len=ii) :: arr(:plus-1), string,arr(plus:) ]
!!        endif
!!        ! show array
!!        write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     endif
!!     end subroutine update
!!     end program demo_locate
!!
!!   Results:
!!
!!     for "b" index is            2           5
!!     for "[" index is           -4           5
!!    SIZE=5 xxx,b,aaa,[,ZZZ,
!!     for "c" index is           -2           6
!!    SIZE=6 xxx,c,b,aaa,[,ZZZ,
!!     for "ZZ" index is           -7           7
!!    SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     for "ZZZZ" index is           -6           8
!!    SIZE=8 xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!     for "z" index is           -1           9
!!    SIZE=9 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine locate_c(list,value,place,ier,errmsg)

! ident_29="@(#)M_CLI2::locate_c(3f): find PLACE in sorted character array where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
character(len=:),allocatable            :: list(:)
integer,intent(out),optional            :: ier
character(len=*),intent(out),optional   :: errmsg
integer                                 :: i
character(len=:),allocatable            :: message
integer                                 :: arraysize
integer                                 :: maxtry
integer                                 :: imin, imax
integer                                 :: error
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   arraysize=size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=int(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      elseif(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   elseif(error.ne.0)then
      write(warn,*)message//' VALUE=',trim(value)//' PLACE=',place
      call mystop(-24,'(*locate_c* '//message)
   endif
   if(present(errmsg))then
      errmsg=message
   endif
end subroutine locate_c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    remove(3f) - [M_CLI2] remove entry from an allocatable array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine remove(list,place)
!!
!!    character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)
!!    integer, intent(out) :: PLACE
!!
!!##DESCRIPTION
!!
!!    Remove a value from an allocatable array at the specified index.
!!    The array is assumed to be sorted in descending order. It may be of
!!    type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!
!!##OPTIONS
!!
!!    list    is the list array.
!!    PLACE   is the subscript for the entry that should be removed
!!
!!##EXAMPLES
!!
!!
!! Sample program
!!
!!     program demo_remove
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate, remove
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!     integer                       :: end
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'Z', 'aaa', 'b', 'b', 'ab', 'bb', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,1)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,4)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end program demo_remove
!!
!!   Results:
!!
!!    Expected output
!!
!!     SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=7 bb,b,b,aaa,ZZZ,Z,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine remove_c(list,place)

! ident_30="@(#)M_CLI2::remove_c(3fp): remove string from allocatable string array at specified position"

character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii, end
   if(.not.allocated(list))then
      list=[character(len=2) :: ]
   endif
   ii=len(list)
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[character(len=ii) :: list(:place-1) ]
   else
      list=[character(len=ii) :: list(:place-1), list(place+1:) ]
   endif
end subroutine remove_c
subroutine remove_l(list,place)

! ident_31="@(#)M_CLI2::remove_l(3fp): remove value from allocatable array at specified position"

logical,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_l
subroutine remove_i(list,place)

! ident_32="@(#)M_CLI2::remove_i(3fp): remove value from allocatable array at specified position"
integer,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_CLI2] replace entry in a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine replace(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer, intent(out)          :: PLACE
!!
!!##DESCRIPTION
!!
!!    replace a value in an allocatable array at the specified index. Unless the
!!    array needs the string length to increase this is merely an assign of a value
!!    to an array element.
!!
!!    The array may be of type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER>
!!    It is assumed to be sorted in descending order without duplicate values.
!!
!!    The value and list must be of the same type.
!!
!!##OPTIONS
!!
!!    VALUE         the value to place in the array
!!    LIST          is the array.
!!    PLACE         is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!! Replace key-value pairs in a dictionary
!!
!!     program demo_replace
!!     use M_CLI2, only  : insert, locate, replace
!!     ! Find if a key is in a list and insert it
!!     ! into the key list and value list if it is not present
!!     ! or replace the associated value if the key existed
!!     implicit none
!!     character(len=20)            :: key
!!     character(len=100)           :: val
!!     character(len=:),allocatable :: keywords(:)
!!     character(len=:),allocatable :: values(:)
!!     integer                      :: i
!!     integer                      :: place
!!     call update('b','value of b')
!!     call update('a','value of a')
!!     call update('c','value of c')
!!     call update('c','value of c again')
!!     call update('d','value of d')
!!     call update('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>",a,/))')(trim(keywords(i)),trim(values(i)),i=1,size(keywords))
!!
!!     call locate_key('a',place)
!!     if(place.gt.0)then
!!        write(*,*)'The value of "a" is',trim(values(place))
!!     else
!!        write(*,*)'"a" not found'
!!     endif
!!
!!     contains
!!     subroutine update(key,val)
!!     character(len=*),intent(in)  :: key
!!     character(len=*),intent(in)  :: val
!!     integer                      :: place
!!
!!     ! find where string is or should be
!!     call locate_key(key,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(keywords,key,abs(place))
!!        call insert(values,val,abs(place))
!!     else ! replace
!!        call replace(values,val,place)
!!     endif
!!
!!     end subroutine update
!!    end program demo_replace
!!
!!   Expected output
!!
!!    d==>value of d
!!    c==>value of c again
!!    b==>value of b
!!    a==>value of a again
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine replace_c(list,value,place)

! ident_33="@(#)M_CLI2::replace_c(3fp): replace string in allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: tlen
integer                      :: end
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   tlen=len_trim(value)
   end=size(list)
   if(place.lt.0.or.place.gt.end)then
           write(warn,*)'*replace_c* error: index out of range. end=',end,' index=',place
   elseif(len_trim(value).le.len(list))then
      list(place)=value
   else  ! increase length of variable
      ii=max(tlen,len(list))
      kludge=[character(len=ii) :: list ]
      list=kludge
      list(place)=value
   endif
end subroutine replace_c
subroutine replace_l(list,value,place)

! ident_34="@(#)M_CLI2::replace_l(3fp): place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(warn,*)'*replace_l* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_l
subroutine replace_i(list,value,place)

! ident_35="@(#)M_CLI2::replace_i(3fp): place value into allocatable array at specified position"

integer,intent(in)    :: value
integer,allocatable   :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(warn,*)'*replace_i* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    insert(3f) - [M_CLI2] insert entry into a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine insert(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer,intent(in)    :: place
!!
!!##DESCRIPTION
!!
!!    Insert a value into an allocatable array at the specified index.
!!    The list and value must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL, or INTEGER)
!!
!!##OPTIONS
!!
!!    list    is the list array. Must be sorted in descending order.
!!    value   the value to place in the array
!!    PLACE   is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!! Find if a string is in a sorted array, and insert the string into
!! the list if it is not present ...
!!
!!     program demo_insert
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate, insert
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!     ! add or replace values
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, end
!!
!!     end=size(arr)
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(arr,string,abs(place))
!!     endif
!!     ! show array
!!     end=size(arr)
!!     write(*,'("array is now SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end subroutine update
!!     end program demo_insert
!!
!!   Results:
!!
!!     array is now SIZE=5 xxx,b,aaa,ZZZ,,
!!     array is now SIZE=6 xxx,b,aaa,[,ZZZ,,
!!     array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,
!!     array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!     array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine insert_c(list,value,place)

! ident_36="@(#)M_CLI2::insert_c(3fp): place string into allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: end

   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif

   ii=max(len_trim(value),len(list),2)
   end=size(list)

   if(end.eq.0)then                                          ! empty array
      list=[character(len=ii) :: value ]
   elseif(place.eq.1)then                                    ! put in front of array
      kludge=[character(len=ii) :: value, list]
      list=kludge
   elseif(place.gt.end)then                                  ! put at end of array
      kludge=[character(len=ii) :: list, value ]
      list=kludge
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      kludge=[character(len=ii) :: list(:place-1), value,list(place:) ]
      list=kludge
   else                                                      ! index out of range
      write(warn,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_c
subroutine insert_l(list,value,place)

! ident_37="@(#)M_CLI2::insert_l(3fp): place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(warn,*)'*insert_l* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_l
subroutine insert_i(list,value,place)

! ident_38="@(#)M_CLI2::insert_i(3fp): place value into allocatable array at specified position"

integer,allocatable   :: list(:)
integer,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(warn,*)'*insert_i* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine many_args(n0,g0, n1,g1, n2,g2, n3,g3, n4,g4, n5,g5, n6,g6, n7,g7, n8,g8, n9,g9, &
                   & na,ga, nb,gb, nc,gc, nd,gd, ne,ge, nf,gf, ng,gg, nh,gh, ni,gi, nj,gj )
implicit none

! ident_39="@(#)M_CLI2::many_args(3fp): allow for multiple calls to get_args(3f)"

character(len=*),intent(in)          :: n0, n1
character(len=*),intent(in),optional ::         n2, n3, n4, n5, n6, n7, n8, n9, na, nb, nc, nd, ne, nf, ng, nh, ni, nj
class(*),intent(out)           :: g0, g1
class(*),intent(out),optional  ::         g2, g3, g4, g5, g6, g7, g8, g9
class(*),intent(out),optional  :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
   call get_generic(n0,g0)
   call get_generic(n1,g1)
   if( present(n2) .and. present(g2) )call get_generic(n2,g2)
   if( present(n3) .and. present(g3) )call get_generic(n3,g3)
   if( present(n4) .and. present(g4) )call get_generic(n4,g4)
   if( present(n5) .and. present(g5) )call get_generic(n5,g5)
   if( present(n6) .and. present(g6) )call get_generic(n6,g6)
   if( present(n7) .and. present(g7) )call get_generic(n7,g7)
   if( present(n8) .and. present(g8) )call get_generic(n8,g8)
   if( present(n9) .and. present(g9) )call get_generic(n9,g9)
   if( present(na) .and. present(ga) )call get_generic(na,ga)
   if( present(nb) .and. present(gb) )call get_generic(nb,gb)
   if( present(nc) .and. present(gc) )call get_generic(nc,gc)
   if( present(nd) .and. present(gd) )call get_generic(nd,gd)
   if( present(ne) .and. present(ge) )call get_generic(ne,ge)
   if( present(nf) .and. present(gf) )call get_generic(nf,gf)
   if( present(ng) .and. present(gg) )call get_generic(ng,gg)
   if( present(nh) .and. present(gh) )call get_generic(nh,gh)
   if( present(ni) .and. present(gi) )call get_generic(ni,gi)
   if( present(nj) .and. present(gj) )call get_generic(nj,gj)
contains
!===================================================================================================================================
function c(generic)
class(*),intent(in) :: generic
character(len=:),allocatable :: c
   select type(generic)
      type is (character(len=*)); c=trim(generic)
      class default
         c='unknown'
         stop 'get_many:: parameter name is not character'
   end select
end function c
!===================================================================================================================================
subroutine get_generic(name,generic)
use,intrinsic :: iso_fortran_env, only : real64
character(len=*),intent(in)  :: name
class(*),intent(out)         :: generic
   select type(generic)
      type is (integer);                        call get_args(name,generic)
      type is (real);                           call get_args(name,generic)
      type is (real(kind=real64));              call get_args(name,generic)
      type is (logical);                        call get_args(name,generic)
      !x!type is (character(len=:),allocatable ::);   call get_args(name,generic)
      type is (character(len=*));
      call get_args_fixed_length(name,generic)
      type is (complex);                        call get_args(name,generic)
      class default
         stop 'unknown type in *get_generic*'
   end select
end subroutine get_generic
!===================================================================================================================================
end subroutine many_args
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function iget(n); integer                      :: iget; character(len=*),intent(in) :: n; call get_args(n,iget); end function iget
function rget(n); real                         :: rget; character(len=*),intent(in) :: n; call get_args(n,rget); end function rget
function dget(n); real(kind=dp)                :: dget; character(len=*),intent(in) :: n; call get_args(n,dget); end function dget
function sget(n); character(len=:),allocatable :: sget; character(len=*),intent(in) :: n; call get_args(n,sget); end function sget
function cget(n); complex                      :: cget; character(len=*),intent(in) :: n; call get_args(n,cget); end function cget
function lget(n); logical                      :: lget; character(len=*),intent(in) :: n; call get_args(n,lget); end function lget

function igs(n); integer,allocatable          :: igs(:); character(len=*),intent(in) :: n; call get_args(n,igs); end function igs
function rgs(n); real,allocatable             :: rgs(:); character(len=*),intent(in) :: n; call get_args(n,rgs); end function rgs
function dgs(n); real(kind=dp),allocatable    :: dgs(:); character(len=*),intent(in) :: n; call get_args(n,dgs); end function dgs
function sgs(n,delims)
character(len=:),allocatable         :: sgs(:)
character(len=*),optional,intent(in) :: delims
character(len=*),intent(in)          :: n
   call get_args(n,sgs,delims)
end function sgs
function cgs(n); complex,allocatable          :: cgs(:); character(len=*),intent(in) :: n; call get_args(n,cgs); end function cgs
function lgs(n); logical,allocatable          :: lgs(:); character(len=*),intent(in) :: n; call get_args(n,lgs); end function lgs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function ig()
integer,allocatable :: ig(:)
integer             :: i, ierr
   if(allocated(ig))deallocate(ig)
   allocate(ig(size(unnamed)))
   do i=1,size(ig)
      call a2i(unnamed(i),ig(i),ierr)
   enddo
end function ig
!===================================================================================================================================
function rg()
real,allocatable :: rg(:)
   rg=real(dg())
end function rg
!===================================================================================================================================
function dg()
real(kind=dp),allocatable :: dg(:)
integer                   :: i
integer                   :: ierr
   if(allocated(dg))deallocate(dg)
   allocate(dg(size(unnamed)))
   do i=1,size(dg)
      call a2d(unnamed(i),dg(i),ierr)
   enddo
end function dg
!===================================================================================================================================
function lg()
logical,allocatable   :: lg(:)
integer               :: i
integer               :: iichar
character,allocatable :: hold
   if(allocated(lg))deallocate(lg)
   allocate(lg(size(unnamed)))
   do i=1,size(lg)
      hold=trim(upper(adjustl(unnamed(i))))
      if(hold(1:1).eq.'.')then                 ! looking for fortran logical syntax .STRING.
         iichar=2
      else
         iichar=1
      endif
      select case(hold(iichar:iichar))         ! check word to see if true or false
      case('T','Y',' '); lg(i)=.true.          ! anything starting with "T" or "Y" or a blank is TRUE (true,yes,...)
      case('F','N');     lg(i)=.false.         ! assume this is false or no
      case default
         call journal('sc',"*lg* bad logical expression for element",i,'=',hold)
      end select
   enddo
end function lg
!===================================================================================================================================
function cg()
complex,allocatable :: cg(:)
integer             :: i, ierr
real(kind=dp)       :: rc, ic
   if(allocated(cg))deallocate(cg)
   allocate(cg(size(unnamed)))
   do i=1,size(cg),2
      call a2d(unnamed(i),rc,ierr)
      call a2d(unnamed(i+1),ic,ierr)
      cg(i)=cmplx(rc,ic,kind=sp)
   enddo
end function cg
!===================================================================================================================================
! Does not work with gcc 5.3
!function sg()
!character(len=:),allocatable :: sg(:)
!   sg=unnamed
!end function sg

function sg()
character(len=:),allocatable :: sg(:)
   if(allocated(sg))deallocate(sg)
   allocate(sg,source=unnamed)
end function sg
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine mystop(sig,msg)
! negative signal means always stop program
! else do not stop and set G_STOP_MESSAGE if G_QUIET is true
! or
! print message and stop if G_QUIET is false
! the MSG is NOT for displaying except for internal errors when the program will be stopped.
! It is for returning a value when the stop is being ignored
!
integer,intent(in) :: sig
character(len=*),intent(in),optional :: msg
   !x!write(*,*)'MYSTOP:',sig,trim(msg)
   if(sig.lt.0)then
      if(present(msg))call journal('sc',msg)
      !x!stop abs(sig)
      stop 1
   elseif(.not.G_QUIET)then
      stop
   else
      if(present(msg)) then
         G_STOP_MESSAGE=msg
      else
         G_STOP_MESSAGE=''
      endif
      G_STOP=sig
      !x!write(*,*)'G_STOP:',g_stop,trim(msg)
   endif
end subroutine mystop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function atleast(line,length,pattern) result(strout)

! ident_40="@(#)M_strings::atleast(3f): return string padded to at least specified length"

character(len=*),intent(in)                :: line
integer,intent(in)                         :: length
character(len=*),intent(in),optional       :: pattern
character(len=max(length,len(trim(line)))) :: strout
if(present(pattern))then
   strout=line//repeat(pattern,len(strout)/len(pattern)+1)
else
   strout=line
endif
end function atleast
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine locate_key(value,place)

! ident_41="@(#)M_CLI2::locate_key(3f): find PLACE in sorted character array where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
integer                                 :: ii
   if(len_trim(value).eq.1)then
      !x!ii=findloc(shorts,value,dim=1)
      ii=maxloc([0,merge(1, 0, shorts.eq.value)],dim=1)
      if(ii.gt.1)then
         place=ii-1
      else
         call locate(keywords,value,place)
      endif
   else
      call locate(keywords,value,place)
   endif
end subroutine locate_key
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_CLI2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! REVISION:  nvfortran does not support real128 from iso_fortran_env x86_64 GNU/Linux
!            nvfortran 20.7-0 LLVM 64-bit target on x86-64 Linux -tp nehalem
! < !NVFORTRAN-S-0000-Internal compiler error. size_of: attempt to get size of assumed size character       0  (M_CLI2.f90: 2012)
! < !  0 inform,   0 warnings,   1 severes, 0 fatal for get_anyarray_cc
! Changed
!       allocate(character(len=*)::strings(0))
! to
!       strings=[character(len=len(strings)) ::]
!===================================================================================================================================
 
 
!>>>>> build/dependencies/M_match/src/M_match.f90
module M_match
implicit none
private
public :: getpat  !....... encode regular expression for pattern matching
public :: match   !....... match pattern anywhere on line
public :: amatch  !....... look for pattern matching regular expression
public :: makpat  !....... encode regular expression for pattern matching
public :: regex_pattern
public :: bpos, epos
private :: omatch
private :: error
private :: addset
private :: dodash
private :: locate
private :: patsiz
private :: stclos
private :: getccl
private :: filset
private :: esc
interface getpat;     module procedure getpat_, getpat__;           end interface
interface makpat;     module procedure makpat_          ;           end interface
interface amatch;     module procedure amatch_, amatch__;           end interface
interface match;      module procedure match_,  match__ ;           end interface
interface omatch;     module procedure omatch_          ;           end interface

!========== STANDARD RATFOR DEFINITIONS ==========
!!integer,parameter :: CHARACTER=INTEGER
integer,parameter :: chr=kind(1)
integer,parameter :: byte=kind(1)
integer,parameter :: def=kind(1)
!!integer,parameter :: ANDIF=IF

integer(kind=byte),parameter :: EOF=10003_byte
integer(kind=byte),parameter,public :: EOS=10002_byte
integer(kind=byte),parameter,public :: ERR=10001_byte
integer(kind=byte),parameter,public :: YES=1_byte
!!integer(kind=byte),parameter :: ARB=100_byte

integer(kind=byte),parameter :: ACCENT=96_byte
integer(kind=byte),parameter :: AND=38_byte
integer(kind=byte),parameter :: ATSIGN=64_byte
integer(kind=byte),parameter :: BACKSLASH=92_byte
integer(kind=byte),parameter :: BACKSPACE=8_byte
integer(kind=byte),parameter :: BANG=33_byte
integer(kind=byte),parameter :: BAR=124_byte
integer(kind=byte),parameter :: BIGA=65_byte
integer(kind=byte),parameter :: BIGB=66_byte
integer(kind=byte),parameter :: BIGC=67_byte
integer(kind=byte),parameter :: BIGD=68_byte
integer(kind=byte),parameter :: BIGE=69_byte
integer(kind=byte),parameter :: BIGF=70_byte
integer(kind=byte),parameter :: BIGG=71_byte
integer(kind=byte),parameter :: BIGH=72_byte
integer(kind=byte),parameter :: BIGI=73_byte
integer(kind=byte),parameter :: BIGJ=74_byte
integer(kind=byte),parameter :: BIGK=75_byte
integer(kind=byte),parameter :: BIGL=76_byte
integer(kind=byte),parameter :: BIGM=77_byte
integer(kind=byte),parameter :: BIGN=78_byte
integer(kind=byte),parameter :: BIGO=79_byte
integer(kind=byte),parameter :: BIGP=80_byte
integer(kind=byte),parameter :: BIGQ=81_byte
integer(kind=byte),parameter :: BIGR=82_byte
integer(kind=byte),parameter :: BIGS=83_byte
integer(kind=byte),parameter :: BIGT=84_byte
integer(kind=byte),parameter :: BIGU=85_byte
integer(kind=byte),parameter :: BIGV=86_byte
integer(kind=byte),parameter :: BIGW=87_byte
integer(kind=byte),parameter :: BIGX=88_byte
integer(kind=byte),parameter :: BIGY=89_byte
integer(kind=byte),parameter :: BIGZ=90_byte
integer(kind=byte),parameter,public :: BLANK=32_byte
integer(kind=byte),parameter :: CARET=94_byte
integer(kind=byte),parameter :: COLON=58_byte
integer(kind=byte),parameter :: COMMA=44_byte
integer(kind=byte),parameter :: DIG0=48_byte
integer(kind=byte),parameter :: DIG1=49_byte
integer(kind=byte),parameter :: DIG2=50_byte
integer(kind=byte),parameter :: DIG3=51_byte
integer(kind=byte),parameter :: DIG4=52_byte
integer(kind=byte),parameter :: DIG5=53_byte
integer(kind=byte),parameter :: DIG6=54_byte
integer(kind=byte),parameter :: DIG7=55_byte
integer(kind=byte),parameter :: DIG8=56_byte
integer(kind=byte),parameter :: DIG9=57_byte
integer(kind=byte),parameter :: DIGIT=2_byte
integer(kind=byte),parameter :: DOLLAR=36_byte
integer(kind=byte),parameter :: DQUOTE=34_byte
integer(kind=byte),parameter :: EQUALS=61_byte
integer(kind=byte),parameter :: ERROUT=2_byte
integer(kind=byte),parameter :: GREATER=62_byte
integer(kind=byte),parameter :: LBRACE=123_byte
integer(kind=byte),parameter :: LBRACK=91_byte
integer(kind=byte),parameter :: LESS=60_byte
integer(kind=byte),parameter :: LETA=97_byte
integer(kind=byte),parameter :: LETB=98_byte
integer(kind=byte),parameter :: LETC=99_byte
integer(kind=byte),parameter :: LETD=100_byte
integer(kind=byte),parameter :: LETE=101_byte
integer(kind=byte),parameter :: LETF=102_byte
integer(kind=byte),parameter :: LETG=103_byte
integer(kind=byte),parameter :: LETH=104_byte
integer(kind=byte),parameter :: LETI=105_byte
integer(kind=byte),parameter :: LETJ=106_byte
integer(kind=byte),parameter :: LETK=107_byte
integer(kind=byte),parameter :: LETL=108_byte
integer(kind=byte),parameter :: LETM=109_byte
integer(kind=byte),parameter :: LETN=110_byte
integer(kind=byte),parameter :: LETO=111_byte
integer(kind=byte),parameter :: LETP=112_byte
integer(kind=byte),parameter :: LETQ=113_byte
integer(kind=byte),parameter :: LETR=114_byte
integer(kind=byte),parameter :: LETS=115_byte
integer(kind=byte),parameter :: LETT=116_byte
integer(kind=byte),parameter :: LETTER=1_byte
integer(kind=byte),parameter :: LETU=117_byte
integer(kind=byte),parameter :: LETV=118_byte
integer(kind=byte),parameter :: LETW=119_byte
integer(kind=byte),parameter :: LETX=120_byte
integer(kind=byte),parameter :: LETY=121_byte
integer(kind=byte),parameter :: LETZ=122_byte
integer(kind=byte),parameter :: LPAREN=40_byte
!!integer(kind=byte),parameter :: MAXCHARS=20_byte
integer(kind=byte),parameter,public :: MAXLINE=1024_byte       ! TYPICAL LINE LENGTH
!!integer(kind=byte),parameter :: MAXNAME=30_byte        ! TYPICAL FILE NAME SIZE
integer(kind=byte),parameter :: MINUS=45_byte
integer(kind=byte),parameter :: NEWLINE=10_byte
integer(kind=byte),parameter,public :: NO=0_byte
integer(kind=byte),parameter :: NOERR=0_byte
integer(kind=byte),parameter :: NOT=126_byte           ! SAME AS TILDE
integer(kind=byte),parameter :: OK=-2_byte
integer(kind=byte),parameter :: OR=BAR             ! SAME AS BAR
integer(kind=byte),parameter :: PERCENT=37_byte
integer(kind=byte),parameter :: PERIOD=46_byte
integer(kind=byte),parameter :: PLUS=43_byte
integer(kind=byte),parameter :: QMARK=63_byte
integer(kind=byte),parameter :: RBRACE=125_byte
integer(kind=byte),parameter :: RBRACK=93_byte
integer(kind=byte),parameter :: READ=0_byte
integer(kind=byte),parameter :: READWRITE=2_byte
integer(kind=byte),parameter :: RPAREN=41_byte
integer(kind=byte),parameter :: SEMICOL=59_byte
integer(kind=byte),parameter :: SHARP=35_byte
integer(kind=byte),parameter :: SLASH=47_byte
integer(kind=byte),parameter :: SQUOTE=39_byte
integer(kind=byte),parameter :: STAR=42_byte
integer(kind=byte),parameter :: STDIN=0_byte
integer(kind=byte),parameter :: STDOUT=1_byte
integer(kind=byte),parameter :: STDERR=ERROUT
integer(kind=byte),parameter :: TAB=9_byte
integer(kind=byte),parameter :: TILDE=126_byte
integer(kind=byte),parameter :: UNDERLINE=95_byte
integer(kind=byte),parameter :: WRITE=1_byte

! HANDY MACHINE-DEPENDENT PARAMETERS, CHANGE FOR A NEW MACHINE
integer(kind=byte),parameter,public  :: MAXPAT=512
integer(kind=byte),parameter,public  :: MAXARG=512
integer(kind=byte),parameter :: MAXSUBS=10

integer(kind=byte),parameter :: COUNT=1
integer(kind=byte),parameter :: PREVCL=2
integer(kind=byte),parameter :: START=3
integer(kind=byte),parameter :: CLOSIZE=4

!!integer(kind=byte),parameter  :: ESCAPE=ATSIGN
!!integer(kind=byte),parameter  :: ANY=QMARK
!!integer(kind=byte),parameter  :: BOL=PERCENT

integer(kind=byte),parameter   :: EOL=DOLLAR
integer(kind=byte),parameter   :: CLOSURE=STAR
integer(kind=byte),parameter   :: DASH=MINUS
integer(kind=byte),parameter   :: ESCAPE=BACKSLASH
integer(kind=byte),parameter   :: ANY=PERIOD
integer(kind=byte),parameter   :: BOL=CARET

integer(kind=byte),parameter :: CCL=LBRACK
integer(kind=byte),parameter :: CCLEND=RBRACK

integer(kind=byte),parameter :: NCCL=LETN
integer(kind=byte),parameter :: CHAR=LETA
integer(kind=byte),parameter :: BOSS=LBRACE        ! <
integer(kind=byte),parameter :: EOSS=RBRACE        ! >

!!COMMON /CSUBS/ BPOS(MAXSUBS), EPOS(MAXSUBS)
integer(kind=byte) ::  bpos(maxsubs)           ! beginning of partial match
integer(kind=byte) ::  epos(maxsubs)           ! end of corresponding partial match

type :: regex_pattern
   integer :: pat(MAXPAT)
end type regex_pattern

contains
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
function f2r(string,isize)

character(len=*),parameter::ident_1="&
&@(#)M_match::f2r(3f): convert Fortran character variable to Ratfor integer array with Ratfor terminator"

character(len=*),intent(in) :: string
integer,intent(in)          :: isize
!!integer                     :: f2r(len(string)+1)
integer                     :: f2r(isize)
integer                     :: i
f2r=blank
   do i=1,len_trim(string)
      f2r(i)=ichar(string(i:i))
   enddo
   f2r(i)=eos
end function f2r
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
function r2f(ints)

character(len=*),parameter::ident_2="@(#)M_match::r2f(3f): convert Ratfor integer array to Fortran character variable"

integer,intent(in)          :: ints(:)
character(len=size(ints)-1) :: r2f
integer                     :: i
intrinsic char
   r2f=' '
   do i=1,size(ints)-1
      if(ints(i).eq.eos)then
         exit
      endif
      r2f(i:i)=char(ints(i))
   enddo
end function r2f
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    getpat_ - [M_match] convert argument into pattern
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function getpat_(arg, pat)

character(len=*),parameter::ident_3="@(#)M_match::getpat_ convert argument into pattern"

integer(kind=def) :: getpat_
integer(kind=def) :: arg(maxarg), pat(maxpat)
   getpat_ = makpat_(arg, 1, eos, pat)
end function getpat_
!===================================================================================================================================
function getpat__(arg_str, pat)

character(len=*),parameter::ident_4="@(#)M_match::getpat__ convert argument into pattern"

character(len=*),intent(in) :: arg_str
integer(kind=def) :: getpat__
integer(kind=def) :: arg(maxarg), pat(maxpat)
   arg=f2r(arg_str,size(arg))
   getpat__ = makpat_(arg, 1, eos, pat)
end function getpat__
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    addset - [M_match] put C in SET(J) if it fits, increment J
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function addset(c, set, j, maxsiz)

character(len=*),parameter::ident_5="@(#)M_match::addset put C in SET(J) if it fits, increment J"

integer(kind=byte) :: addset
integer(kind=chr)  :: c
integer(kind=chr)  :: set(:)
integer(kind=byte) :: j
integer(kind=byte) :: maxsiz
   if (j > maxsiz)then
      addset = no
   else
      set(j) = c
      j = j + 1
      addset = yes
   endif
end function addset
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    dodash - [M_match] expand array(i-1)-array(i+1) into set(j)...
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! dodash - expand array(i-1)-array(i+1) into set(j)... from valid
subroutine dodash(valid, array, i, set, j, maxset)
integer(kind=def) ::  i, j, junk, k, limit, maxset
character(len=*),intent(in) :: valid
integer(kind=chr) :: array(:)
integer(kind=chr) :: set(:)
intrinsic char
   i = i + 1
   j = j - 1
   limit = index(valid, char(esc(array, i)))
   k=index(valid,char(set(j)))
   do
      if(.not. (k.le.limit)) exit
      junk = addset(ichar(valid(k:k)), set, j, maxset)
      k=k+1
   enddo
end subroutine dodash
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    locate - [M_match] look for c in char class at pat(offset)
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function locate(c, pat, offset)

character(len=*),parameter::ident_7="@(#)M_match::locate look for c in char class at pat(offset)"

integer(kind=def) :: locate
integer(kind=chr) :: c, pat(maxpat)
integer(kind=def) :: i, offset
   ! size of class is at pat(offset), characters follow

   !!for (i = offset + pat(offset); i > offset; i = i - 1)
   do i = offset + pat(offset), offset+1,  -1
      if (c == pat(i)) then
         locate = yes
         return
      endif
   enddo
   locate = no
end function locate
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    match - [M_match] find match anywhere on line
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function match_(lin, pat)

character(len=*),parameter::ident_8="@(#)M_match::match find match anywhere on line"

integer(kind=def) :: match_
integer(kind=chr) :: lin(maxline), pat(maxpat)
integer(kind=def) :: i

   if (pat(1) == bol) then            ! anchored match
      if (amatch_(lin, 1, pat) > 0) then
         match_ = yes
         return
      endif
   else               ! unanchored
      !- for (i = 1; lin(i) /= eos; i = i + 1)
      i=1
      do while (lin(i) /= eos)
         if (amatch_(lin, i, pat) > 0) then
            match_ = yes
            return
         endif
         i=i+1
      enddo
   endif
   match_ = no
end function match_
!==================================================================================================================================!
function match__(lin_str, pat)

character(len=*),parameter::ident_9="@(#)M_match::match find match anywhere on line"

character(len=*),intent(in) :: lin_str
integer(kind=def) :: match__
integer(kind=chr) :: lin(maxline), pat(maxpat)
   lin=f2r(lin_str,size(lin))
   match__=match_(lin,pat)
end function match__
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    patsiz - [M_match] returns size of pattern entry at pat(n)
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function patsiz(pat, n)

character(len=*),parameter::ident_10="@(#)M_match::patsiz returns size of pattern entry at pat(n)"

integer(kind=def) :: patsiz
integer(kind=chr) :: pat(maxpat)
integer(kind=def) :: n

   if (pat(n) == char .or. pat(n) == boss .or. pat(n) == eoss)then
      patsiz = 2
   elseif (pat(n) == bol .or. pat(n) == eol .or. pat(n) == any)then
      patsiz = 1
   elseif (pat(n) == ccl .or. pat(n) == nccl)then
      patsiz = pat(n + 1) + 2
   elseif (pat(n) == closure)then      ! optional
      patsiz = closize
   else
      call error("in patsiz: can't happen.")
   endif
end function patsiz
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    stclos - [M_match] insert closure entry at pat(j)
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function stclos(pat, j, lastj, lastcl)

character(len=*),parameter::ident_11="@(#)M_match::stclos insert closure entry at pat(j)"

integer(kind=def) :: stclos
integer(kind=chr) :: pat(maxpat)
integer(kind=def) :: j, jp, jt, junk, lastcl, lastj

   !- for (jp = j - 1; jp >= lastj; jp = jp - 1) <   ! make a hole
   do jp = j - 1, lastj,  - 1   ! make a hole
      jt = jp + closize
      junk = addset(pat(jp), pat, jt, maxpat)
   enddo
   j = j + closize
   stclos = lastj
   junk = addset(closure, pat, lastj, maxpat)   ! put closure in it
   junk = addset(0, pat, lastj, maxpat)      ! count
   junk = addset(lastcl, pat, lastj, maxpat)   ! prevcl
   junk = addset(0, pat, lastj, maxpat)      ! start
end function stclos
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    getccl - [M_match] expand char class at arg(i) into pat(j)
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function getccl(arg, i, pat, j)

character(len=*),parameter::ident_12="@(#)M_match::getccl expand char class at arg(i) into pat(j)"

integer(kind=def) :: getccl
integer(kind=chr)  :: arg(maxarg), pat(maxpat)
integer(kind=def) :: i, j, jstart, junk

   i = i + 1      ! skip over [
   if (arg(i) == tilde .or. arg(i) == caret) then
      junk = addset(nccl, pat, j, maxpat)
      i = i + 1
   else
      junk = addset(ccl, pat, j, maxpat)
   endif
   jstart = j
   junk = addset(0, pat, j, maxpat)      ! leave room for count
   call filset(cclend, arg, i, pat, j, maxpat)
   pat(jstart) = j - jstart - 1
   if (arg(i) == cclend)then
      getccl = ok
   else
      getccl = err
   endif
end function getccl
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    filset - [M_match] expand set at  array(i)  into  set(j),  stop at  delim
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
subroutine filset(delim, array, i, set, j, maxset)

character(len=*),parameter::ident_13="@(#)M_match::filset expand set at  array(i)  into  set(j),  stop at  delim"

integer(kind=def) :: i, j, junk, maxset
integer(kind=chr) :: array(:), delim, set(:)

character(len=*),parameter :: digits= "0123456789"
character(len=*),parameter :: lowalf= "abcdefghijklmnopqrstuvwxyz"
character(len=*),parameter :: upalf= "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
intrinsic char

   !-  for ( ; array(i) /= delim .and. array(i) /= eos; i = i + 1)
   do while( array(i) /= delim .and. array(i) /= eos)
      if (array(i) == escape) then
         junk = addset(esc(array, i), set, j, maxset)
      elseif (array(i) /= dash) then
         junk = addset(array(i), set, j, maxset)
      elseif (j <= 1 .or. array(i+1) == eos) then   ! literal -
         junk = addset(dash, set, j, maxset)
      elseif (index(digits, char(set (j - 1))) > 0) then
         call dodash(digits, array, i, set, j, maxset)
     elseif (index(lowalf, char(set (j - 1))) > 0) then
         call dodash(lowalf, array, i, set, j, maxset)
      elseif (index(upalf, char(set (j - 1))) > 0) then
         call dodash(upalf, array, i, set, j, maxset)
      else
         junk = addset (DASH, set, j, maxset)
      endif
      i=i+1
   enddo
end subroutine filset
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    esc - [M_match] map  array(i)  into escaped character if appropriate
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function esc(array, i)

character(len=*),parameter::ident_14="@(#)M_match::esc map  array(i)  into escaped character if appropriate"
integer(kind=chr) :: esc
integer(kind=chr) :: array(:)
integer(kind=def) :: i

   if (array(i) /= escape)then
      esc = array(i)
   elseif (array(i+1) == eos)then   ! not special at end
      esc = escape
   else
      i = i + 1
      if (array(i) == letn .or. array(i) == bign)then
         esc = newline
      elseif (array(i) == lett .or. array(i) == bigt)then
         esc = tab
      elseif (array(i) == letb .or. array(i) == bigb)then
         esc = backspace
      elseif (array(i) >= dig0 .and. array(i) <= dig7) then
         !- for (esc = 0; array(i) >= dig0 .and. array(i) <= dig7; i = i + 1)
         esc=0
         do while (array(i) >= dig0 .and.  array(i) <= dig7)
            i = i + 1
            esc = 8*esc + array(i) - dig0
            i = i - 1    ! so like other cases
         enddo
      else
         esc = array(i)
      endif
   endif
end function esc
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    omatch_ - [M_match] try to match a single pattern at pat(j)
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function omatch_(lin, i, pat, j)

character(len=*),parameter::ident_15="@(#)M_match::omatch_ try to match a single pattern at pat(j)"

integer(kind=def) ::  omatch_
integer(kind=chr)  :: lin(maxline), pat(maxpat)
integer(kind=def) :: bump, i, j, k

   omatch_ = no
   if (lin(i) == eos)then
      return
   endif
   bump = -1
   if (pat(j) == char) then
      if (lin(i) == pat(j + 1))then
         bump = 1
      endif
   elseif (pat(j) == bol) then
      if (i == 1)then
         bump = 0
      endif
   elseif (pat(j) == any) then
      if (lin(i) /= newline)then
         bump = 1
      endif
   elseif (pat(j) == eol) then
      if (lin(i) == newline .or. lin(i) == eos)then
         bump = 0
      endif
   elseif (pat(j) == ccl) then
      if (locate(lin(i), pat, j + 1) == yes)then
         bump = 1
      endif
   elseif (pat(j) == nccl) then
      if (lin(i) /= newline .and. locate(lin(i), pat, j + 1) == no)then
         bump = 1
      endif
   elseif (pat(j) == boss) then
      k = pat(j+1)
      bpos(k+1) = i
      bump = 0
   elseif (pat(j) == eoss) then
      k = pat(j+1)
      epos(k+1) = i
      bump = 0
   else
      call error("in omatch_: can't happen.")
   endif
   if (bump >= 0) then
      i = i + bump
      omatch_ = yes
   endif
end function omatch_
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    amatch_ - [M_match] - look for pattern matching regular expression; returns its location
! SYNOPSIS
!       loc = amatch_ (line, from, pat, tagbeg, tagend)
!
!        character line(ARB), pat(MAXPAT)
!        integer from
!        integer tagbeg(10), tagend(10)
!        (element "i + 1" returns start or end, respectively,
!        of "i"th tagged subpattern)
!        integer loc returns location/0
!        matched; if no match, loc is returned as 0
! DESCRIPTION
!        amatch_(3f)  scans 'line' starting at location 'from', looking for
!        a  pattern which matches the regular expression coded in 'pat'.
!        If the pattern is found, its starting location in line is
!        returned. If the pattern is not found, amatch_(3f)  returns 0.
!
!        The regular expression in 'pat' must have been previously encoded
!        by 'getpat_' or 'makpat_'. (For a complete description of regular
!        expressions, see the writeup on the editor.)
!
!        amatch_(3f)  is a special-purpose version of match, which should
!        be used in most cases.
!
! OPTIONS
! RETURNS
! EXAMPLE
! SEE ALSO
!        match, getpat_, makpat_
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function amatch_(lin, from, pat)

character(len=*),parameter::ident_16="@(#)M_match::amatch_  (non-recursive) look for match starting at lin(from)"

integer(kind=def) :: amatch_
integer(kind=chr)  :: lin(maxline), pat(maxpat)
integer(kind=def) :: from, i, j, offset, stack
   stack = 0
   offset = from      ! next unexamined input character
!-   for (j = 1; j <= maxsubs; j = j + 1) <     ! clear partial match results
   do j = 1, maxsubs     ! clear partial match results
      bpos(j) = offset
      epos(j) = offset
   enddo
!-   for (j = 1; pat(j) /= eos; j = j + patsiz(pat, j))
   j=1
   do while (pat(j) /= eos)
      if (pat(j) == closure) then   ! a closure entry
         stack = j
         j = j + closize      ! step over closure
         !- for (i = offset; lin(i) /= eos; )   ! match as many as possible
         i = offset
         do while ( lin(i) /= eos )                 ! match as many as
            if (omatch_(lin, i, pat, j) == no)then   ! possible
               exit
            endif
         enddo
         pat(stack+count) = i - offset
         pat(stack+start) = offset
         offset = i      ! character that made us fail
      elseif (omatch_(lin, offset, pat, j) == no) then   ! non-closure
!-         for ( ; stack > 0; stack = pat(stack+prevcl))
         do while (stack >0)
            if (pat(stack+count) > 0)then
               exit
            endif
            stack = pat(stack+prevcl)
         enddo
         if (stack <= 0) then      ! stack is empty
            amatch_ = 0            ! return failure
            return
         endif
         pat(stack+count) = pat(stack+count) - 1
         j = stack + closize
         offset = pat(stack+start) + pat(stack+count)
      endif
      j = j + patsiz(pat, j)
   enddo ! else omatch_ succeeded
   epos(1) = offset
   amatch_ = offset
   ! success
end function amatch_
!==================================================================================================================================!
function amatch__(lin_str, from, pat)

character(len=*),parameter::ident_9="@(#)M_match::amatch "

character(len=*),intent(in) :: lin_str
integer,intent(in) :: from
integer(kind=def)  :: amatch__
integer(kind=chr)  :: pat(maxpat)
integer(kind=chr)  :: lin(maxline)
   lin=f2r(lin_str,size(lin))
   amatch__=amatch_(lin,from,pat)
end function amatch__
!----------------------------------------------------------------------------------------------------------------------------------!
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! NAME
!    makpat_ - [M_match] make pattern from arg(from), terminate at delim
! SYNOPSIS
! DESCRIPTION
! OPTIONS
! RETURNS
! EXAMPLE
! AUTHOR
!   John S. Urban
! REFERENCE
!   "Software Tools" by Kernighan and Plauger , 1976
! LICENSE
!   Public Domain
function makpat_(arg, from, delim, pat)

character(len=*),parameter::ident_17="@(#)M_match::makpat_ make pattern from arg(from), terminate at delim"

integer(kind=def) :: makpat_
integer(kind=chr)  :: arg(maxarg), delim, pat(maxpat)
integer(kind=def) :: from, i, j, junk, lastcl, lastj, lj, nsubs, sp, substk(maxsubs)

   j = 1      ! pat index
   lastj = 1
   lastcl = 0
   nsubs = 0  ! counts number of @(@) pairs
   sp = 0     ! stack pointer for substk
   !-   for (i = from; arg(i) /= delim .and. arg(i) /= eos; i = i + 1) <
   i=from
   do while ( arg(i) /= delim .and. arg(i) /= eos )
      lj = j
      if (arg(i) == any)then
         junk = addset(any, pat, j, maxpat)
      elseif (arg(i) == bol .and. i == from)then
         junk = addset(bol, pat, j, maxpat)
      elseif (arg(i) == eol .and. arg(i + 1) == delim)then
         junk = addset(eol, pat, j, maxpat)
      elseif (arg(i) == ccl) then
         if (getccl(arg, i, pat, j) == err)then
            exit
         endif
      elseif (arg(i) == closure .and. i > from) then
         lj = lastj
         !!if(pat(lj)==bol .or. pat(lj)==eol .or. pat(lj)==closure .or. pat(lj-1) == boss .or. pat(lj-1) == eoss) then
         if(pat(lj)==bol .or. pat(lj)==eol .or. pat(lj)==closure .or. pat(lj) == boss .or. pat(lj) == eoss) then
            exit
         endif
         lastcl = stclos(pat, j, lastj, lastcl)
      elseif (arg(i) == escape .and. arg(i+1) == lparen) then
         nsubs = nsubs + 1
         if (nsubs >= maxsubs)then
            exit
         endif
         junk = addset(boss, pat, j, maxpat)
         junk = addset(nsubs, pat, j, maxpat)
         sp = sp + 1
         substk(sp) = nsubs
         i = i + 1
      elseif (arg(i) == escape .and. arg(i+1) == rparen) then
         if (sp <= 0)then
            exit
         endif
         junk = addset(eoss, pat, j, maxpat)
         junk = addset(substk(sp), pat, j, maxpat)
         sp = sp - 1
         i = i + 1
      else
         junk = addset(char, pat, j, maxpat)
         junk = addset(esc(arg, i), pat, j, maxpat)
      endif
      lastj = lj
      i=i+1
   enddo
   if (arg(i) /= delim .or. sp /= 0)then   ! terminated early
      makpat_ = err
   elseif (addset(eos, pat, j, maxpat) == no)then   ! no room
      makpat_ = err
   else
      makpat_ = i
   endif
end function makpat_
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
subroutine error(message)
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT ! access computing environment
character(len=*),intent(in) :: message
   write(stderr,'(a)')message
end subroutine error
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
end module M_match
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
 
 
!>>>>> build/dependencies/M_strings/src/M_strings.F90
!>
!!##NAME
!!    M_strings(3f) - [M_strings::INTRO] Fortran string module
!!
!!##DESCRIPTION
!!    The M_strings(3fm) module is a collection of Fortran procedures
!!    that supplement the built-in intrinsic string routines. Routines
!!    for parsing, tokenizing, changing case, substituting new strings for
!!    substrings, locating strings with simple wildcard expressions, removing
!!    tabs and line terminators and other string manipulations are included.
!!
!!    M_strings_oop(3fm) is a companion module that provides an OOP interface
!!    to the M_strings module.
!!
!!##SYNOPSIS
!!
!!  public entities:
!!
!!      use M_strings, only : split,sep,delim,chomp,strtok
!!      use M_strings, only : substitute,change,modif,transliterate,reverse
!!      use M_strings, only : replace,join
!!      use M_strings, only : upper,lower,upper_quoted
!!      use M_strings, only : rotate13
!!      use M_strings, only : adjustc,compact,nospace,indent
!!      use M_strings, only : crop,unquote,quote
!!      use M_strings, only : len_white,atleast,stretch,lenset,merge_str
!!      use M_strings, only : switch,s2c,c2s
!!      use M_strings, only : noesc,notabs,dilate,expand,visible
!!      use M_strings, only : longest_common_substring
!!      !x!use M_strings, only : uc
!!      use M_strings, only : string_to_value,string_to_values,s2v,s2vs
!!      use M_strings, only : value_to_string,v2s,msg
!!      use M_strings, only : listout,getvals
!!      use M_strings, only : glob, ends_with
!!      use M_strings, only : paragraph
!!      use M_strings, only : base, decodebase, codebase, base2
!!      use M_strings, only : isalnum, isalpha, iscntrl, isdigit
!!      use M_strings, only : isgraph, islower, isprint, ispunct
!!      use M_strings, only : isspace, isupper, isascii, isblank, isxdigit
!!      use M_strings, only : isnumber
!!      use M_strings, only : fortran_name
!!      use M_strings, only : describe
!!      use M_strings, only : edit_distance
!!      use M_strings, only : cc
!!
!!   TOKENS
!!
!!       split  subroutine parses string using specified delimiter characters
!!              and stores tokens into an array
!!       sep    function interface to split(3f)
!!       delim  subroutine parses string using specified delimiter characters
!!              and store tokens into an array
!!       chomp  function consumes input line as it returns next token in a
!!              string using specified delimiters
!!       paragraph    convert a string into a paragraph
!!       strtok tokenize a string like C strtok(3c) routine
!!
!!   EDITING
!!
!!       substitute     subroutine non-recursively globally replaces old
!!                      substring with new substring
!!       replace        function non-recursively globally replaces old
!!                      substring with new substring using allocatable string
!!                      (version of substitute(3f) without limitation on
!!                      length of output string)
!!       change         subroutine non-recursively globally replaces old
!!                      substring with new substring with a directive like
!!                      line editor
!!       modif          subroutine modifies a string with a directive like the
!!                      XEDIT line editor MODIFY command
!!       transliterate  replace characters found in set one with characters
!!                      from set two
!!       reverse        reverse character order in a string
!!       join           join an array of CHARACTER variables with specified
!!                      separator
!!       rotate13       apply trivial encryption algorithm ROT13 to a string
!!       squeeze        delete adjacent duplicate characters from a string
!!
!!   CASE
!!
!!       upper          function converts string to uppercase
!!       lower          function converts string to miniscule
!!       upper_quoted   function converts string to uppercase skipping strings
!!                      quoted per Fortran rules
!!
!!   WHITE SPACE
!!
!!       adjustc  elemental function centers text within the length of the
!!                input string
!!       compact  left justify string and replace duplicate whitespace with
!!                single characters or nothing
!!       nospace  function replaces whitespace with nothing
!!       indent   find number of leading spaces
!!       crop     function trims leading and trailing spaces
!!
!!       See Also: squeeze
!!
!!   QUOTES
!!
!!       unquote  remove quotes from string as if read with list-directed input
!!       quote    add quotes to string as if written with list-directed input
!!
!!   STRING LENGTH
!!
!!       len_white  find location of last non-whitespace character
!!       lenset     return a string of specified length
!!       atleast    return a string of at least specified length
!!       stretch    return a string of at least specified length with suffix
!!       merge_str  make strings of equal length and then call MERGE(3f)
!!                  intrinsic
!!
!!   CHARACTER ARRAY VERSUS STRING
!!
!!       switch  switch between a string and an array of single characters
!!       s2c     convert string to array of single characters and add null
!!               terminator for passing to C
!!       c2s     convert null-terminated array of single characters to
!!               string for converting strings returned from C
!!
!!   NONALPHA
!!
!!       noesc    convert non-printable ASCII8 characters to a space
!!       notabs   convert tabs to spaces while maintaining columns,
!!                assuming tabs are set every 8 characters
!!       dilate   function to convert tabs to spaces assuming tabs are set
!!                every 8 characters
!!       expand   expand escape sequences in a string
!!       visible  expand escape sequences in a string to "control" and
!!                meta-control representations
!!
!!   NUMERIC STRINGS
!!
!!       string_to_value   generic subroutine returns numeric value (REAL,
!!                         DOUBLEPRECISION, INTEGER) from string
!!       string_to_values  subroutine reads an array of numbers from a string
!!       getvals           subroutine reads a relatively arbitrary number
!!                         of values from a string using list-directed read
!!       s2v               function returns DOUBLEPRECISION numeric value
!!                         from string
!!       s2vs              function returns a DOUBLEPRECISION array of numbers
!!                         from a string
!!       msg               append the values of up to nine values into a string
!!
!!       value_to_string   generic subroutine returns string given numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER, LOGICAL )
!!       v2s               generic function returns string from numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER )
!!       listout           expand a list of numbers where negative numbers
!!                         denote range ends (1 -10 means 1 thru 10)
!!       isnumber          determine if string represents a number
!!
!!   CHARACTER TESTS
!!
!!       glob        compares given string for match to pattern which may
!!                   contain wildcard characters
!!       ends_with   test whether strings ends with one of the specified suffixs
!!
!!       o isalnum   returns .true. if character is a letter or digit
!!       o isalpha   returns .true. if character is a letter and
!!                   .false. otherwise
!!       o iscntrl   returns .true. if character is a delete character or
!!                   ordinary control character
!!       o isdigit   returns .true. if character is a digit (0,1,...,9)
!!                   and .false. otherwise
!!       o isgraph   returns .true. if character is a printable character
!!                   except a space is considered non-printable
!!       o islower   returns .true. if character is a miniscule letter (a-z)
!!       o isprint   returns .true. if character is an ASCII printable
!!                   character
!!       o ispunct   returns .true. if character is a printable punctuation
!!                   character
!!       o isspace   returns .true. if character is a null, space, tab,
!!                   carriage return, new line, vertical tab, or formfeed
!!       o isupper   returns .true. if character is an uppercase letter (A-Z)
!!       o isascii   returns .true. if the character is in the range char(0)
!!                   to char(127)
!!       o isblank   returns .true. if character is a blank character
!!                   (space or horizontal tab.
!!       o isxdigit  returns .true. if character is a hexadecimal digit
!!                   (0-9, a-f, or A-F).
!!
!!       fortran_name   returns .true. if input string is a valid Fortran name
!!
!!   BASE CONVERSION
!!
!!       base       convert whole number string in base [2-36] to string
!!                  in alternate base [2-36]
!!       base2      convert INTEGER to a string representing a binary value
!!       codebase   convert whole number string in base [2-36] to base
!!                  10 number
!!       decodebase convert whole number in base 10 to string in base [2-36]
!!
!!   MISCELLANEOUS
!!
!!       cc         return up to twenty strings of arbitrary length as an array
!!       describe   returns a string describing the name of a single character
!!       edit_distance  returns a naive edit distance using the Levenshtein
!!                      distance algorithm
!!       longest_common_substring  function that returns the longest common
!!                                 substring of two strings.
!!
!!   INTRINSICS
!!
!!    The M_strings(3fm) module supplements and works in combination with
!!    the Fortran built-in intrinsics. Stand-alone Fortran lets you access
!!    the characters in a string using ranges much like they are character
!!    arrays, assignment, comparisons with standard operators, supports
!!    dynamically allocatable strings and supports concatenation using the //
!!    operator, as well as a number of intrinsic string routines:
!!
!!        adjustl             Left adjust a string
!!        adjustr             Right adjust a string
!!        index               Position of a substring within a string
!!        repeat              Repeated string concatenation
!!        scan                Scan a string for the presence of a set
!!                            of characters
!!        trim                Remove trailing blank characters of a string
!!        verify              Scan a string for the absence of a set of
!!                            characters
!!        len                 It returns the length of a character string
!!        achar               converts an integer into a character
!!        iachar              converts a character into an integer
!!        len_trim            finds length of string with trailing spaces
!!                            ignored
!!        new_line            Newline character
!!        selected_char_kind  Choose character kind
!!        lge                 Lexical greater than or equal
!!        lgt                 Lexical greater than
!!        lle                 Lexical less than or equal
!!        llt                 Lexical less than
!!
!!   OOPS INTERFACE
!!
!!    The M_strings_oop(3fm) module (included with the M_strings(3fm)
!!    module) provides an OOP (Object-Oriented Programming) interface to
!!    the M_strings(3fm) module.
!!
!!##SEE ALSO
!!    There are additional routines in other GPF modules for working with
!!    expressions (M_calculator), time strings (M_time), random strings
!!    (M_random, M_uuid), lists (M_list), and interfacing with the C regular
!!    expression library (M_regex).
!!
!!##EXAMPLES
!!
!!    Each of the procedural functions includes an example program in the
!!    corresponding man(1) page for the function. The object-oriented
!!    interface does not have individual man(1) pages, but is instead
!!    demonstrated using the following example program:
!!
!!     program demo_M_strings
!!     use M_strings, only : split, delim, chomp, sep
!!     use M_strings, only : substitute, change, modif
!!     use M_strings, only : transliterate, reverse
!!     use M_strings, only : replace, join
!!     use M_strings, only : upper, lower, upper_quoted
!!     use M_strings, only : rotate13
!!     use M_strings, only : adjustc, compact, nospace, indent, crop, squeeze
!!     use M_strings, only : unquote, quote
!!     use M_strings, only : len_white, atleast, stretch, lenset, merge_str
!!     use M_strings, only : switch, s2c, c2s
!!     use M_strings, only : noesc, notabs, dilate, expand, visible
!!     use M_strings, only : longest_common_substring
!!     !x!use M_strings, only : uc
!!     use M_strings, only : string_to_value, string_to_values, s2v, s2vs
!!     use M_strings, only : value_to_string, v2s, msg
!!     use M_strings, only : listout, getvals
!!     use M_strings, only : glob, ends_with
!!     use M_strings, only : paragraph
!!     use M_strings, only : base, decodebase, codebase, base2
!!     use M_strings, only : isalnum, isalpha, iscntrl, isdigit, isgraph
!!     use M_strings, only : islower, isprint, ispunct, isspace, isupper
!!     use M_strings, only : isascii, isblank, isxdigit
!!     use M_strings, only : fortran_name
!!     end program demo_M_strings
!!
!!   Expected output
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
MODULE M_strings !
use, intrinsic :: iso_fortran_env, only : ERROR_UNIT        ! access computing environment
use, intrinsic :: iso_fortran_env, only : output_unit, stderr=>error_unit
implicit none    ! change default for every procedure contained in the module

! ident_1="@(#) M_strings(3f) Fortran module containing routines that deal with character strings"

!-----------------------------------------------------------------------------------------------------------------------------------
private

!----------------------# TOKENS
public split           !  subroutine parses a string using specified delimiter characters and store tokens into an allocatable array
public sep             !  function interface to split
public chomp           !  function consumes input line as it returns next token in a string using specified delimiters
public delim           !  subroutine parses a string using specified delimiter characters and store tokens into an array
public strtok          !  gets next token. Used by change(3f)
public paragraph       !  convert a long string into a paragraph
!----------------------# EDITING
public substitute      !  subroutine non-recursively globally replaces old substring with new substring in string
public replace         !  function non-recursively globally replaces old substring with new substring in string
public change          !  replaces old substring with new substring in string with a directive like a line editor
public modif           !  change string using a directive using rules similar to XEDIT line editor MODIFY command
public transliterate   !  when characters in set one are found replace them with characters from set two
public reverse         !  elemental function reverses character order in a string
public join            !  append an array of character variables with specified separator into a single CHARACTER variable
public squeeze         !  delete adjacent duplicate characters from a string
public rotate13        !  apply trivial encryption algorithm ROT13 to string
!----------------------# CHARACTER ARRAY VERSUS STRING
public switch          !  generic switch between a string and an array of single characters (a2s,s2a)
private a2s            !  function to copy char array to string
private s2a            !  function to copy string(1:Clen(string)) to char array
public s2c             !  convert character variable to array of character(len=1) with null terminator for C compatibility
public c2s             !  convert null-terminated array of character(len=1) to string for strings returned by C
!----------------------# CASE
public upper           !  elemental function converts string to uppercase
public lower           !  elemental function converts string to miniscule
public upper_quoted    !  elemental function converts string to miniscule skipping strings quoted per Fortran syntax rules
!----------------------# WHITE SPACE
public adjustc         !  elemental function centers string within the length of the input string
public compact         !  left justify string and replace duplicate whitespace with single characters or nothing
public nospace         !  function replaces whitespace with nothing
public indent          !  count number of leading spaces
public crop            !  function trims leading and trailing spaces
!----------------------# QUOTES
public unquote         !  remove quotes from string as if read with list-directed input
public quote           !  add quotes to string as if written with list-directed input
!----------------------# STRING LENGTH
public lenset          !  return a string as specified length
public atleast         !  return a string of at least specified length
public stretch         !  return a string of at least specified length with suffix
public merge_str       !  make strings of equal length and then call MERGE(3f) intrinsic
public len_white       !  find location of last non-whitespace character
!----------------------# NONALPHA
public noesc           !  elemental function converts non-printable ASCII8 characters to a space
public notabs          !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public dilate          !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public expand          !  expand escape sequences in a string
public visible         !  expand escape sequences in a string to control and meta-control representations
!----------------------# NUMERIC STRINGS
public string_to_value !  generic subroutine returns REAL|DOUBLEPRECISION|INTEGER value from string (a2d,a2r,a2i)
 private a2d           !  subroutine returns double value from string
 private a2r           !  subroutine returns real value from string
 private a2i           !  subroutine returns integer value from string
public string_to_values!  subroutine returns values from a string
public getvals         !  subroutine returns values from a string
public s2v             !  function returns doubleprecision value from string
public s2vs            !  function returns a doubleprecision array of numbers from a string
                       !------------------------------------------------------------------------------------------------------------
public msg             !  function returns a string representing up to nine scalar intrinsic values
public value_to_string !  generic subroutine returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
public v2s             !  generic function returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
 private d2s           !  function returns string from doubleprecision value
 private r2s           !  function returns string from real value
 private i2s           !  function returns string from integer value
 private l2s           !  function returns string from logical value
public v2s_bug         !  generic function returns string given numeric REAL|DOUBLEPRECISION|INTEGER value
public isnumber        !  determine if string represents a number
 private trimzeros_    !  Delete trailing zeros from numeric decimal string
public listout         !  expand a list of numbers where  negative numbers denote range ends (1 -10 means 1 thru 10)
!-----------------------------------------------------------------------------------------------------------------------------------
!
! extend intrinsics to accept CHARACTER values
!
public int, real, dble

interface int;     module procedure int_s2v;           end interface
interface real;    module procedure real_s2v;          end interface
interface dble;    module procedure dble_s2v;          end interface

interface int;     module procedure ints_s2v;          end interface
interface real;    module procedure reals_s2v;         end interface
interface dble;    module procedure dbles_s2v;         end interface

!-----------------------------------------------------------------------------------------------------------------------------------
!----------------------# BIT ROUTINES
public setbits8        !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits16       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits32       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits64       !  use a string representing a positive binary value to fill the bits of an INTEGER value
!----------------------# BASE CONVERSION
public base            !  convert whole number string in base [2-36] to string in alternate base [2-36]
public codebase        !  convert whole number string in base [2-36] to base 10 number
public decodebase      !  convert whole number in base 10 to string in base [2-36]
public base2           !  convert INTEGER to a string representing a binary value
!----------------------# LOGICAL TESTS
public glob            !  compares given string for match to pattern which may contain wildcard characters
public matchw          !  clone of glob -- for backward compatibiity
public ends_with       !  test whether strings ends with one of the specified suffix
public isalnum         !  elemental function returns .true. if CHR is a letter or digit
public isalpha         !  elemental function returns .true. if CHR is a letter and .false. otherwise
public isascii         !  elemental function returns .true. if the low order byte of c is in the range char(0) to char(127)
public isblank         !  elemental function returns .true. if CHR is a blank character (space or horizontal tab.
public iscntrl         !  elemental function returns .true. if CHR is a delete character or ordinary control character
public isdigit         !  elemental function returns .true. if CHR is a digit (0,1,...,9) and .false. otherwise
public isgraph         !  elemental function true if CHR is an ASCII printable character except considers a space non-printable
public islower         !  elemental function returns .true. if CHR is a miniscule letter (a-z)
public isprint         !  elemental function determines if CHR is an ASCII printable character
public ispunct         !  elemental function returns .true. if CHR is a printable punctuation character
public isspace         !  elemental function true if CHR is a null, space, tab, carriage return, new line, vertical tab, or formfeed
public isupper         !  elemental function returns .true. if CHR is an uppercase letter (A-Z)
public isxdigit        !  elemental function returns .true. if CHR is a hexadecimal digit (0-9, a-f, or A-F).
!----------------------#
!-------------------------------#
public fortran_name             !  elemental function returns .true. if LINE is a valid Fortran name
public describe                 !  returns a string describing character
public edit_distance            !  returns a naive edit distance using the Levenshtein distance algorithm
public cc                       !  return up to twenty strings of arbitrary length as an array
public longest_common_substring !  function that returns the longest common substring of two strings.
!-------------------------------#

!-----------------------------------------------------------------------------------------------------------------------------------

! ident_2="@(#) M_strings switch(3f) toggle between string and array of characters; generic{a2s s2a}"

interface switch
   module procedure a2s, s2a
end interface switch
! note how returned result is "created" by the function
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_3="@(#) M_strings string_to_value(3f) Generic subroutine converts numeric string to a number (a2d a2r a2i)"

interface string_to_value
   module procedure a2d, a2r, a2i
end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_4="@(#) M_strings v2s(3f) Generic function returns string given REAL|INTEGER|DOUBLEPRECISION value(d2s r2s i2s)"

interface v2s
   module procedure d2s, r2s, i2s, l2s
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
!-!interface setbits ! boz
!-!        module procedure setbits8, setbits16, setbits32, setbits64
!-!end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_5="@(#) M_strings msg(3f) convert up to nine scalar values to a string. Alternatively can also handle one-dimensional arrays"

interface msg
   module procedure msg_scalar, msg_one
end interface msg
!-----------------------------------------------------------------------------------------------------------------------------------
! ASCII character constants
character, public, parameter :: ascii_nul = char(0)   ! null
character, public, parameter :: ascii_bel = char(7)   ! bell
character, public, parameter :: ascii_bs  = char(8)   ! backspace
character, public, parameter :: ascii_ht  = char(9)   ! horizontal tab
character, public, parameter :: ascii_lf  = char(10)  ! line feed or newline
character, public, parameter :: ascii_ff  = char(12)  ! form feed or newpage
character, public, parameter :: ascii_cr  = char(13)  ! carriage return
character, public, parameter :: ascii_esc = char(27)  ! escape
!-----------------------------------------------------------------------------------------------------------------------------------
interface ends_with
    procedure :: ends_with_str
    procedure :: ends_with_any
end interface ends_with
!-----------------------------------------------------------------------------------------------------------------------------------
public :: split2020, string_tokens

interface split2020
   module procedure :: split_tokens, split_first_last, split_pos
end interface split2020
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
!This contains a conditionally built mini-version of M_journal which allows the M_strings.f90 module
!to be built using make as a stand-alone distribution but still have make.shell built a true version
!
!This is so when built with make.shell(1) or fpm(1) it will use the
!real M_journal.f90 file but that fpm(1) will not auto-discover the mini
!M_journal.f90 file and built it and cause duplicates.

interface journal
   module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
   module procedure set_stdout_lun            ! journal(i)               ! first is not a string
end interface journal

interface str
   module procedure str_scalar, str_one
end interface str

!$@(#) M_journal::journal(3fg): provides public message routine, no paging or graphic mode change

! global variables

integer,save,private       :: stdout=OUTPUT_UNIT
logical,save               :: debug=.false.
integer,save               :: last_int=0
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
! for compatibility allow old name for renamed procedures
interface matchw; module procedure glob ;  end interface
!-----------------------------------------------------------------------------------------------------------------------------------
CONTAINS
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    glob(3f) - [M_strings:COMPARE] compare given string for match to
!!    a pattern which may contain globbing wildcard characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function glob(string, pattern )
!!
!!     character(len=*),intent(in) :: string
!!     character(len=*),intent(in) :: pattern
!!
!!##DESCRIPTION
!!    glob(3f) compares given (entire) STRING for a match to PATTERN which may
!!    contain basic wildcard "globbing" characters.
!!
!!    In this version to get a match the entire string must be described
!!    by PATTERN. Trailing whitespace is significant, so trim the input
!!    string to have trailing whitespace ignored.
!!
!!    Patterns like "b*ba" fail on a string like "babababa" because the
!!    algorithm finds an early match. To skip over the early matches insert
!!    an extra character at the end of the string and pattern that does
!!    not occur in the pattern. Typically a NULL is used (char(0)).
!!
!!##OPTIONS
!!    string   the input string to test to see if it contains the pattern.
!!    pattern  the following simple globbing options are available
!!
!!             o "?" matching any one character
!!             o "*" matching zero or more characters.
!!               Do NOT use adjacent asterisks.
!!             o spaces are significant and must be matched or pretrimmed
!!             o There is no escape character, so matching strings with
!!               literal question mark and asterisk is problematic.
!!
!!##EXAMPLES
!!
!!   Example program
!!
!!    program demo_glob
!!    implicit none
!!    ! This main() routine passes a bunch of test strings
!!    ! into the above code.  In performance comparison mode,
!!    ! it does that over and over. Otherwise, it does it just
!!    ! once. Either way, it outputs a passed/failed result.
!!    !
!!    integer :: nReps
!!    logical :: allpassed
!!    integer :: i
!!     allpassed = .true.
!!
!!     nReps = 10000
!!     ! Can choose as many repetitions as you're expecting
!!     ! in the real world.
!!     nReps = 1
!!
!!     do i=1,nReps
!!      ! Cases with repeating character sequences.
!!      allpassed=  test("a*abab",       "a*b",    .true.)   .and.  allpassed
!!      allpassed=  test("ab",           "*?",     .true.)   .and.  allpassed
!!      allpassed=  test("abc",          "*?",     .true.)   .and.  allpassed
!!      allpassed=  test("abcccd",       "*ccd",   .true.)   .and.  allpassed
!!      allpassed=  test("bLah",         "bLaH",   .false.)  .and.  allpassed
!!      allpassed=  test("mississippi",  "*sip*",  .true.)   .and.  allpassed
!!      allpassed= &
!!       & test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.) .and. allpassed
!!      allpassed= &
!!       & test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.) .and. allpassed
!!      allpassed= &
!!       & test("mississipissippi", "*issip*ss*", .true.) .and. allpassed
!!      allpassed= &
!!       & test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.) .and. allpassed
!!      allpassed= &
!!       & test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.) .and. allpassed
!!      allpassed=  test("xyxyxyzyxyz",  "xy*z*xyz",  .true.)   .and.  allpassed
!!      allpassed=  test("xyxyxyxyz",    "xy*xyz",    .true.)   .and.  allpassed
!!      allpassed=  test("mississippi",  "mi*sip*",   .true.)   .and.  allpassed
!!      allpassed=  test("ababac",       "*abac*",    .true.)   .and.  allpassed
!!      allpassed=  test("aaazz",        "a*zz*",     .true.)   .and.  allpassed
!!      allpassed=  test("a12b12",       "*12*23",    .false.)  .and.  allpassed
!!      allpassed=  test("a12b12",       "a12b",      .false.)  .and.  allpassed
!!      allpassed=  test("a12b12",       "*12*12*",   .true.)   .and.  allpassed
!!
!!      ! Additional cases where the '*' char appears in the tame string.
!!      allpassed=  test("*",     "*",      .true.)   .and.  allpassed
!!      allpassed=  test("a*r",   "a*",     .true.)   .and.  allpassed
!!      allpassed=  test("a*ar",  "a*aar",  .false.)  .and.  allpassed
!!
!!      ! More double wildcard scenarios.
!!      allpassed=  test("XYXYXYZYXYz",  "XY*Z*XYz",   .true.)   .and.  allpassed
!!      allpassed=  test("missisSIPpi",  "*SIP*",      .true.)   .and.  allpassed
!!      allpassed=  test("mississipPI",  "*issip*PI",  .true.)   .and.  allpassed
!!      allpassed=  test("xyxyxyxyz",    "xy*xyz",     .true.)   .and.  allpassed
!!      allpassed=  test("miSsissippi",  "mi*sip*",    .true.)   .and.  allpassed
!!      allpassed=  test("miSsissippi",  "mi*Sip*",    .false.)  .and.  allpassed
!!      allpassed=  test("abAbac",       "*Abac*",     .true.)   .and.  allpassed
!!      allpassed=  test("aAazz",        "a*zz*",      .true.)   .and.  allpassed
!!      allpassed=  test("A12b12",       "*12*23",     .false.)  .and.  allpassed
!!      allpassed=  test("a12B12",       "*12*12*",    .true.)   .and.  allpassed
!!      allpassed=  test("oWn",          "*oWn*",      .true.)   .and.  allpassed
!!
!!      ! Completely tame (no wildcards) cases.
!!      allpassed= test("bLah", "bLah", .true.) .and. allpassed
!!
!!      ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert.
!!      allpassed= test("a", "*?", .true.) .and. allpassed
!!
!!      ! More mixed wildcard tests including coverage for false positives.
!!      allpassed=  test("a",      "??",         .false.)  .and.  allpassed
!!      allpassed=  test("ab",     "?*?",        .true.)   .and.  allpassed
!!      allpassed=  test("ab",     "*?*?*",      .true.)   .and.  allpassed
!!      allpassed=  test("abc",    "?**?*?",     .true.)   .and.  allpassed
!!      allpassed=  test("abc",    "?**?*&?",    .false.)  .and.  allpassed
!!      allpassed=  test("abcd",   "?b*??",      .true.)   .and.  allpassed
!!      allpassed=  test("abcd",   "?a*??",      .false.)  .and.  allpassed
!!      allpassed=  test("abcd",   "?**?c?",     .true.)   .and.  allpassed
!!      allpassed=  test("abcd",   "?**?d?",     .false.)  .and.  allpassed
!!      allpassed=  test("abcde",  "?*b*?*d*?",  .true.)   .and.  allpassed
!!
!!      ! Single-character-match cases.
!!      allpassed=  test("bLah",   "bL?h",  .true.)   .and.  allpassed
!!      allpassed=  test("bLaaa",  "bLa?",  .false.)  .and.  allpassed
!!      allpassed=  test("bLah",   "bLa?",  .true.)   .and.  allpassed
!!      allpassed=  test("bLaH",   "?Lah",  .false.)  .and.  allpassed
!!      allpassed=  test("bLaH",   "?LaH",  .true.)   .and.  allpassed
!!
!!      allpassed=  test( 'abcdefghijk' , '?b*'     , .true.)  .and. allpassed
!!      allpassed=  test( 'abcdefghijk' , '*c*'     , .true.)  .and. allpassed
!!      allpassed=  test( 'abcdefghijk' , '*c'      , .false.) .and. allpassed
!!      allpassed=  test( 'abcdefghijk' , '*c*k'    , .true.)  .and. allpassed
!!      allpassed=  test( 'LS'          , '?OW'     , .false.) .and. allpassed
!!      allpassed=  test( 'teztit'      , 'tez*t*t' , .true.)  .and. allpassed
!!     ! Two pattern match problems that might pose difficulties
!!      allpassed=  test( 'abcde '  , '*e *', .true.)  .and. allpassed
!!      allpassed=  test( 'baaaaax' , 'b*ax', .true.)  .and. allpassed
!!      allpassed=  test( 'baaaaa'  , 'b*ax', .false.) .and. allpassed
!!      allpassed=  test( 'baaaaax' , 'b*a' , .false.) .and. allpassed
!!      allpassed=  test( ''        , 'b*'  , .false.) .and. allpassed
!!      allpassed=  test( '3'       , '??'  , .false.) .and. allpassed
!!      ! note adding null at end to prevent an early match stopping the algorithm
!!      allpassed=  test( 'baaaaa'//char(0)  , 'b*a'//char(0) , .true.) .and. allpassed
!!      allpassed=  test( 'bababa'//char(0)  , 'b*ba'//char(0), .true.) .and. allpassed
!!
!!      ! Many-wildcard scenarios.
!!      allpassed= test(&
!!      &"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!!      &aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",&
!!      &"a*a*a*a*a*a*aa*aaa*a*a*b",&
!!      &.true.) .and. allpassed
!!      allpassed= test(&
!!      &"abababababababababababababababababababaacacacacacacac&
!!      &adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!      &"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",&
!!      &.true.) .and. allpassed
!!      allpassed= test(&
!!      &"abababababababababababababababababababaacacacacacaca&
!!      &cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!      &"*a*b*ba*ca*a*x*aaa*fa*ga*b*",&
!!      &.false.) .and. allpassed
!!      allpassed= test(&
!!      &"abababababababababababababababababababaacacacacacacacad&
!!      &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!      &"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",&
!!      &.false.) .and. allpassed
!!      allpassed= test(&
!!      &"abababababababababababababababababababaacacacacacacacad&
!!      &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!      &"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",&
!!      &.true.) .and. allpassed
!!      allpassed= test("aaabbaabbaab", "*aabbaa*a*", .true.) .and. allpassed
!!      allpassed= &
!!      test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*",&
!!      &"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!      allpassed= test("aaaaaaaaaaaaaaaaa",&
!!      &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!      allpassed= test("aaaaaaaaaaaaaaaa",&
!!      &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.) .and. allpassed
!!      allpassed= test(&
!!      &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!      &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!      & "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc&
!!      &*abc*abc*abc*",&
!!      &.false.) .and. allpassed
!!      allpassed= test(&
!!      &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!      &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!      &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&
!!      &.true.) .and. allpassed
!!      allpassed= test("abc*abcd*abcd*abc*abcd",&
!!      &"abc*abc*abc*abc*abc", .false.) .and. allpassed
!!      allpassed= test( "abc*abcd*abcd*abc*abcd*abcd&
!!      &*abc*abcd*abc*abc*abcd", &
!!      &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",&
!!      &.true.) .and. allpassed
!!      allpassed= test("abc",&
!!      &"********a********b********c********", .true.) .and. allpassed
!!      allpassed=&
!!      &test("********a********b********c********", "abc",.false.).and.allpassed
!!      allpassed= &
!!      &test("abc", "********a********b********b********",.false.).and.allpassed
!!      allpassed= test("*abc*", "***a*b*c***", .true.) .and. allpassed
!!
!!      ! A case-insensitive algorithm test.
!!      ! allpassed=test("mississippi", "*issip*PI", .true.) .and. allpassed
!!     enddo
!!
!!     if (allpassed)then
!!        write(*,'(a)')"Passed",nReps
!!     else
!!        write(*,'(a)')"Failed"
!!     endif
!!    contains
!!    ! This is a test program for wildcard matching routines.
!!    ! It can be used either to test a single routine for correctness,
!!    ! or to compare the timings of two (or more) different wildcard
!!    ! matching routines.
!!    !
!!    function test(tame, wild, bExpectedResult) result(bPassed)
!!    use M_strings, only : glob
!!       character(len=*) :: tame
!!       character(len=*) :: wild
!!       logical          :: bExpectedResult
!!       logical          :: bResult
!!       logical          :: bPassed
!!       bResult = .true.    ! We'll do "&=" cumulative checking.
!!       bPassed = .false.   ! Assume the worst.
!!       write(*,*)repeat('=',79)
!!       bResult = glob(tame, wild) ! Call a wildcard matching routine.
!!
!!       ! To assist correctness checking, output the two strings in any
!!       ! failing scenarios.
!!       if (bExpectedResult .eqv. bResult) then
!!          bPassed = .true.
!!          if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild
!!       else
!!          if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild
!!       endif
!!
!!    end function test
!!    end program demo_glob
!!
!!   Expected output
!!
!!##AUTHOR
!!   John S. Urban
!!
!!##REFERENCE
!!   The article "Matching Wildcards: An Empirical Way to Tame an Algorithm"
!!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014
!!
!!##LICENSE
!!   Public Domain
function glob(tame,wild)

! ident_6="@(#) M_strings glob(3f) function compares text strings one of which can have wildcards ('*' or '?')."

logical                    :: glob
character(len=*)           :: tame       ! A string without wildcards
character(len=*)           :: wild       ! A (potentially) corresponding string with wildcards
character(len=len(tame)+1) :: tametext
character(len=len(wild)+1) :: wildtext
character(len=1),parameter :: NULL=char(0)
integer                    :: wlen
integer                    :: ti, wi
integer                    :: i
character(len=:),allocatable :: tbookmark, wbookmark
! These two values are set when we observe a wildcard character. They
! represent the locations, in the two strings, from which we start once we have observed it.
   tametext=tame//NULL
   wildtext=wild//NULL
   tbookmark = NULL
   wbookmark = NULL
   wlen=len(wild)
   wi=1
   ti=1
   do                                            ! Walk the text strings one character at a time.
      if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string?
         do i=wi,wlen                            ! Easy: unique up on it!
            if(wildtext(wi:wi).eq.'*')then
               wi=wi+1
            else
               exit
            endif
         enddo
         if(wildtext(wi:wi).eq.NULL) then        ! "x" matches "*"
            glob=.true.
            return
         endif
         if(wildtext(wi:wi) .ne. '?') then
            ! Fast-forward to next possible match.
            do while (tametext(ti:ti) .ne. wildtext(wi:wi))
               ti=ti+1
               if (tametext(ti:ti).eq.NULL)then
                  glob=.false.
                  return                         ! "x" doesn't match "*y*"
               endif
            enddo
         endif
         wbookmark = wildtext(wi:)
         tbookmark = tametext(ti:)
      elseif(tametext(ti:ti) .ne. wildtext(wi:wi) .and. wildtext(wi:wi) .ne. '?') then
         ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry.
         if(wbookmark.ne.NULL) then
            if(wildtext(wi:).ne. wbookmark) then
               wildtext = wbookmark
               wlen=len_trim(wbookmark)
               wi=1
               ! Don't go this far back again.
               if (tametext(ti:ti) .ne. wildtext(wi:wi)) then
                  tbookmark=tbookmark(2:)
                  tametext = tbookmark
                  ti=1
                  cycle                          ! "xy" matches "*y"
               else
                  wi=wi+1
               endif
            endif
            if (tametext(ti:ti).ne.NULL) then
               ti=ti+1
               cycle                             ! "mississippi" matches "*sip*"
            endif
         endif
         glob=.false.
         return                                  ! "xy" doesn't match "x"
      endif
      ti=ti+1
      wi=wi+1
      if (ti.gt.len(tametext)) then
         glob=.false.
         return
      elseif (tametext(ti:ti).eq.NULL) then          ! How do you match a tame text string?
         if(wildtext(wi:wi).ne.NULL)then
            do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it!
               wi=wi+1                           ! "x" matches "x*"
               if(wildtext(wi:wi).eq.NULL)exit
            enddo
         endif
         if (wildtext(wi:wi).eq.NULL)then
            glob=.true.
            return                               ! "x" matches "x"
         endif
         glob=.false.
         return                                  ! "x" doesn't match "xy"
      endif
   enddo
end function glob
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    ends_with(3f) - [M_strings:MATCH] test if string ends with specified
!!                    suffix(es)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function ends_with(source_string,suffix)
!!
!!     or
!!
!!    function ends_with(source_string,[suffixs])
!!
!!     character(len=*),intent(in)          :: source_string
!!     character(len=*),intent(in)          :: suffix
!!     logical                              :: ends_with
!!
!!##DESCRIPTION
!!
!!##OPTIONS
!!     SOURCE_STRING  string to tokenize
!!     SUFFIX         list of separator characters. May be scalar or an array.
!!
!!##RETURNS
!!     ENDS_WITH      returns .TRUE. if one of the suffix match the end
!!                    of SOURCE_STRING.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_ends_with
!!    use M_strings, only : ends_with
!!    use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
!!    implicit none
!!       write(stdout,*)ends_with('prog.a',['.o','.i','.s'])
!!       write(stdout,*)ends_with('prog.f90',['.F90','.f90'])
!!       write(stdout,*)ends_with('prog.pdf','.pdf')
!!       write(stdout,*)ends_with('prog.doc','.txt')
!!    end program demo_ends_with
!!
!!   Results:
!!
!!     F
!!     T
!!     T
!!     F
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function ends_with_str(string, ending) result(matched)
character(*), intent(in) :: string, ending
integer                  :: n1, n2
logical                  :: matched
   n1 = len(string) - len(ending) + 1
   n2 = len(string)
   if (n1 < 1) then
       matched = .false.
   else
       matched = (string(n1:n2) == ending)
   endif
end function ends_with_str
!-----------------------------------------------------------------------------------------------------------------------------------
pure function ends_with_any(string, endings) result(matched)
character(*), intent(in) :: string
character(*), intent(in) :: endings(:)
logical                  :: matched
integer                  :: i
   matched = .true.
   FINDIT: block
   do i=1, size(endings)
       if(ends_with_str(string,trim(endings(i)))) exit FINDIT
   enddo
   matched = .false.
   endblock FINDIT
end function ends_with_any
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    sep(3f) - [M_strings:TOKENS] function to parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function sep(input_line,delimiters,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: nulls
!!     character(len=:),allocatable             :: sep(:)
!!
!!##DESCRIPTION
!!     sep(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!    ORDER='ASCENDING'|'DESCENDING'  by default the tokens are returned from
!!                                    last to first; order='ASCENDING' returns
!!                                    them from first to last (left to right).
!!##RETURNS
!!    SEP       Output array of tokens
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_sep
!!    use M_strings, only: sep
!!    character(len=*),parameter :: fo='(/,a,*(/,"[",g0,"]":,","))'
!!    character(len=*),parameter :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!       write(*,'(a)') 'INPUT LINE:['//LINE//']'
!!       write(*,fo) 'typical call:',sep(line)
!!       write(*,fo) 'delimiters ":|":',sep(line,':|')
!!       write(*,fo) 'count null fields ":|":',sep(line,':|','return')
!!    end program demo_sep
!!
!!  Output
!!
!!    INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!
!!    typical call:
!!    [cc        ],
!!    [B         ],
!!    [a         ],
!!    [333|333   ],
!!    [1:|:2     ],
!!    [qrstuvwxyz],
!!    [ghijklmnop],
!!    [aBcdef    ]
!!
!!    delimiters ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!    count null fields ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [                                   ],
!!    [                                   ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function sep(input_line,delimiters,nulls,order)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_7="@(#) M_strings sep(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=*),optional,intent(in)     :: order       ! return strings composed of delimiters or not ignore|return|ignoreend

character(len=:),allocatable             :: sep(:)      ! output array of tokens
integer                                  :: isize
   call split(input_line,sep,delimiters,'right',nulls)
   if(present(order))then
   select case(order)
   case('ascending','ASCENDING')
    isize=size(sep)
    if(isize.gt.1)then
       sep=sep(isize:1:-1)
    endif
   end select
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function sep
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_strings:TOKENS] parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!
!!##DESCRIPTION
!!     SPLIT(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!                (This can be accomplished with array syntax in modern
!!                Fortran, but was more useful pre-fortran90).
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_split
!!    use M_strings, only: split
!!    implicit none
!!    integer :: i
!!    character(len=*),parameter     :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!    character(len=:),allocatable :: array(:) ! output array of tokens
!!       write(*,*)'INPUT LINE:['//line//']'
!!       write(*,'(70("="))')
!!       write(*,*)'typical call:'
!!       call split(line,array)
!!       write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!       write(*,*)'SIZE:',size(array)
!!       write(*,'(70("-"))')
!!       write(*,*)'custom list of delimiters (colon and vertical line):'
!!       call split(line,array,delimiters=':|',&
!!       & order='sequential',nulls='ignore')
!!       write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!       write(*,*)'SIZE:',size(array)
!!       write(*,'(70("-"))')
!!       write(*,*) 'custom list of delimiters, &
!!       &reverse array order and count null fields:'
!!       call split(line,array,delimiters=':|',&
!!       &order='reverse',nulls='return')
!!       write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!       write(*,*)'SIZE:',size(array)
!!       write(*,'(70("-"))')
!!       write(*,*)'INPUT LINE:['//line//']'
!!       write(*,*) 'default delimiters and reverse array order &
!!       &and return null fields:'
!!       call split(line,array,delimiters='',order='reverse',nulls='return')
!!       write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!       write(*,*)'SIZE:',size(array)
!!    end program demo_split
!!
!!  Output
!!
!!   >INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|
!!   333 a B cc    ]
!!   >=================================================================
!!   > typical call:
!!   >1 ==> aBcdef
!!   >2 ==> ghijklmnop
!!   >3 ==> qrstuvwxyz
!!   >4 ==> 1:|:2
!!   >5 ==> 333|333
!!   >6 ==> a
!!   >7 ==> B
!!   >8 ==> cc
!!   > SIZE:           8
!!   >----------------------------------------------------------------
!!   > custom list of delimiters (colon and vertical line):
!!   >1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!   >2 ==> 2     333
!!   >3 ==> 333 a B cc
!!   > SIZE:           3
!!   >----------------------------------------------------------------
!!   > custom list of delimiters, reverse array order and
!!   return null fields:
!!   >1 ==> 333 a B cc
!!   >2 ==> 2     333
!!   >3 ==>
!!   >4 ==>
!!   >5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!   > SIZE:           5
!!   >----------------------------------------------------------------
!!   > INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|
!!   333 a B cc    ]
!!   > default delimiters and reverse array order and count null fields:
!!   >1 ==>
!!   >2 ==>
!!   >3 ==>
!!   >4 ==> cc
!!   >5 ==> B
!!   >6 ==> a
!!   >7 ==> 333|333
!!   >8 ==>
!!   >9 ==>
!!   >10 ==>
!!   >11 ==>
!!   >12 ==> 1:|:2
!!   >13 ==>
!!   >14 ==> qrstuvwxyz
!!   >15 ==> ghijklmnop
!!   >16 ==>
!!   >17 ==>
!!   >18 ==> aBcdef
!!   >19 ==>
!!   >20 ==>
!!   > SIZE:          20
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_8="@(#) M_strings split(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: lgth                   ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters.ne.'')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)    !x! intel compiler says allocated already ?
   if(allocated(iterm))deallocate(iterm)      !x! intel compiler says allocated already ?
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   lgth=len(input_line)                                           ! lgth is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   if(lgth.gt.0)then                                              ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,lgth,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)).eq.0)then  ! if current character is not a delimiter
            iterm(i30)=lgth                                       ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):lgth),dlim(i10:i10))
               IF(ifound.gt.0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol.gt.lgth)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                       ! allocate the array to return
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(ordr)))                              ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20).lt.ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    chomp(3f) - [M_strings:TOKENS] Tokenize a string, consuming it one
!!    token per call
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function chomp(source_string,token[,delimiters])
!!
!!     character(len=*)                     :: source_string
!!     character(len=:),intent(out)         :: token
!!     character(len=:),intent(in),optional :: delimiters
!!     integer                              :: chomp
!!
!!##DESCRIPTION
!!    The CHOMP(3f) function is used to isolate sequential tokens in a
!!    string, SOURCE_STRING. These tokens are delimited in the string by at
!!    least one of the characters in DELIMITERS. This routine consumes the
!!    source_string one token per call. It returns -1 when complete. The
!!    default delimiter list is "space,tab,carriage return,newline".
!!
!!##OPTIONS
!!     SOURCE_STRING  string to tokenize
!!     DELIMITERS     list of separator characters
!!
!!##RETURNS
!!     TOKEN          returned token
!!     CHOMP          status flag. 0 = success, -1 = no tokens remain
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_chomp
!!
!!    use M_strings, only : chomp
!!    implicit none
!!    character(len=100)            :: inline
!!    character(len=:),allocatable  :: token
!!    character(len=*),parameter    :: delimiters=' ;,'
!!    integer                       :: ios
!!    integer                       :: icount
!!    integer                       :: itoken
!!       icount=0
!!       do        ! read lines from stdin until end-of-file or error
!!          read (unit=*,fmt="(a)",iostat=ios) inline
!!          if(ios.ne.0)stop
!!          icount=icount+1
!!          itoken=0
!!          write(*,*)'INLINE ',trim(inline)
!!          do while ( chomp(inline,token,delimiters).ge. 0)
!!             itoken=itoken+1
!!             print *, itoken,'TOKEN=['//trim(token)//']'
!!          enddo
!!       enddo
!!
!!    end program demo_chomp
!!
!!   sample input file
!!
!!     this is a test of chomp; A:B :;,C;;
!!
!!   sample output file
!!
!!     > INLINE     this is a test of chomp; A:B :;,C;;
!!     >           1 TOKEN=[this]
!!     >           2 TOKEN=[is]
!!     >           3 TOKEN=[a]
!!     >           4 TOKEN=[test]
!!     >           5 TOKEN=[of]
!!     >           6 TOKEN=[chomp]
!!     >           7 TOKEN=[A:B]
!!     >           8 TOKEN=[:]
!!     >           9 TOKEN=[C]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
FUNCTION chomp(source_string,token,delimiters)

! ident_9="@(#) M_strings chomp(3f) Tokenize a string JSU- 20151030"

character(len=*)                         :: source_string    ! string to tokenize
character(len=:),allocatable,intent(out) :: token            ! returned token
character(len=*),intent(in),optional     :: delimiters       ! list of separator characters
integer                                  :: chomp            ! returns copy of shifted source_string
character(len=:),allocatable             :: delimiters_local
integer                                  :: token_start      ! beginning of token found if function result is .true.
integer                                  :: token_end        ! end of token found if function result is .true.
integer                                  :: isource_len
!-----------------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(present(delimiters))then
      delimiters_local=delimiters
   else                                          ! increment start to previous end + 1
      delimiters_local=char(32)//char(09)//char(10)//char(13) ! space,horizontal tab, newline, carriage return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   token_start=1
   do while (token_start .le. isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_start:token_start)) .ne. 0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end .le. isource_len-1)                         ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_end+1:token_end+1)) .ne. 0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
   !write(*,*)'TOKEN_START ',token_start
   !write(*,*)'TOKEN_END   ',token_end
   chomp=isource_len-token_end
   if(chomp.ge.0)then
      token=source_string(token_start:token_end)
      source_string=source_string(token_end+1:)
   else
      token=''
      source_string=''
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function chomp
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      delim(3f) - [M_strings:TOKENS] parse a string and store tokens into
!!      an array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)
!!
!!     character(len=*),intent(in)  :: line
!!     integer,integer(in)          :: n
!!     integer,intent(out)          :: icount
!!     character(len=*)             :: array(n)
!!     integer,intent(out)          :: ibegin(n)
!!     integer,intent(out)          :: iterm(n)
!!     integer,intent(out)          :: lgth
!!     character(len=*)             :: dlim
!!
!!##DESCRIPTION
!!      Given a LINE of structure " par1 par2 par3 ... parn "
!!      store each par(n) into a separate variable in ARRAY (UNLESS
!!      ARRAY(1).eq.'#N#')
!!
!!      Also set ICOUNT to number of elements of array initialized, and
!!      return beginning and ending positions for each element in IBEGIN(N)
!!      and ITERM(N).
!!
!!      Return position of last non-blank character (even if more
!!      than N elements were found) in lgth
!!
!!      No quoting or escaping of delimiter is allowed, so the delimiter
!!      character can not be placed in a token.
!!
!!      No checking for more than N parameters; If any more they are ignored.
!!
!!##OPTIONS
!!    LINE      input string to parse into tokens
!!    ARRAY(N)  array that receives tokens
!!    N         size of arrays ARRAY, IBEGIN, ITERM
!!    ICOUNT    number of tokens found
!!    IBEGIN(N) starting columns of tokens found
!!    ITERM(N)  ending columns of tokens found
!!    LGTH      position of last non-blank character in input string LINE
!!    DLIM      delimiter characters
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_delim
!!
!!     use M_strings, only: delim
!!     implicit none
!!     character(len=80) :: line
!!     character(len=80) :: dlm
!!     integer,parameter :: n=10
!!     character(len=20) :: array(n)=' '
!!     integer           :: ibegin(n),iterm(n)
!!     integer           :: i20, icount, lgth, i10
!!     line=' first  second 10.3 words_of_stuff  '
!!     do i20=1,4
!!        ! change delimiter list and what is calculated or parsed
!!        if(i20.eq.1)dlm=' '
!!        if(i20.eq.2)dlm='o'
!!        if(i20.eq.3)dlm=' aeiou'    ! NOTE SPACE IS FIRST
!!        if(i20.eq.3)ARRAY(1)='#N#'  ! QUIT RETURNING STRING ARRAY
!!        if(i20.eq.4)line='AAAaBBBBBBbIIIIIi  J K L'
!!
!!        ! write out a break line composed of =========== ..
!!        write(*,'(57("="))')
!!        ! show line being parsed
!!        write(*,'(a)')'PARSING=['//trim(line)//'] on '//trim(dlm)
!!        ! call parsing procedure
!!        call delim(line,array,n,icount,ibegin,iterm,lgth,dlm)
!!        write(*,*)'number of tokens found=',icount
!!        write(*,*)'last character in column ',lgth
!!        if(icount.gt.0)then
!!           if(lgth.ne.iterm(icount))then
!!              write(*,*)'ignored from column ',iterm(icount)+1,' to ',lgth
!!           endif
!!           do i10=1,icount
!!              ! check flag to see if ARRAY() was set
!!              if(array(1).ne.'#N#')then
!!                 ! from returned array
!!                 write(*,'(a,a,a)',advance='no')&
!!                 &'[',array(i10)(:iterm(i10)-ibegin(i10)+1),']'
!!              endif
!!           enddo
!!           ! using start and end positions in IBEGIN() and ITERM()
!!           write(*,*)
!!           do i10=1,icount
!!              ! from positions in original line
!!              write(*,'(a,a,a)',advance='no')&
!!              &'[',line(ibegin(i10):iterm(i10)),']'
!!           enddo
!!           write(*,*)
!!        endif
!!     enddo
!!     end program demo_delim
!!
!!   Results:
!!
!!    =========================================================
!!    PARSING=[ first  second 10.3 words_of_stuff] on
!!     number of tokens found=           4
!!     last character in column           34
!!    [first][second][10.3][words_of_stuff]
!!    [first][second][10.3][words_of_stuff]
!!    =========================================================
!!    PARSING=[ first  second 10.3 words_of_stuff] on o
!!     number of tokens found=           4
!!     last character in column           34
!!    [ first  sec][nd 10.3 w][rds_][f_stuff]
!!    [ first  sec][nd 10.3 w][rds_][f_stuff]
!!    =========================================================
!!    PARSING=[ first  second 10.3 words_of_stuff] on  aeiou
!!     number of tokens found=          10
!!     last character in column           34
!!
!!    [f][rst][s][c][nd][10.3][w][rds_][f_st][ff]
!!    =========================================================
!!    PARSING=[AAAaBBBBBBbIIIIIi  J K L] on  aeiou
!!     number of tokens found=           5
!!     last character in column           24
!!
!!    [AAA][BBBBBBbIIIII][J][K][L]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)

! ident_10="@(#) M_strings delim(3f) parse a string and store tokens into an array"

!
!     given a line of structure " par1 par2 par3 ... parn "
!     store each par(n) into a separate variable in array.
!
!     IF ARRAY(1) == '#N#' do not store into string array  (KLUDGE))
!
!     also count number of elements of array initialized, and
!     return beginning and ending positions for each element.
!     also return position of last non-blank character (even if more
!     than n elements were found).
!
!     no quoting of delimiter is allowed
!     no checking for more than n parameters, if any more they are ignored
!
character(len=*),intent(in)    :: line
integer,intent(in)             :: n
character(len=*)               :: array(n)
integer,intent(out)            :: icount
integer,intent(out)            :: ibegin(n)
integer,intent(out)            :: iterm(n)
integer,intent(out)            :: lgth
character(len=*),intent(in)    :: dlim
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(line)):: line_local
logical             :: lstore
integer             :: i10
integer             :: iarray
integer             :: icol
integer             :: idlim
integer             :: iend
integer             :: ifound
integer             :: istart
!-----------------------------------------------------------------------------------------------------------------------------------
      icount=0
      lgth=len_trim(line)
      line_local=line

      idlim=len(dlim)
      if(idlim > 5)then
         idlim=len_trim(dlim)      ! dlim a lot of blanks on some machines if dlim is a big string
         if(idlim == 0)then
            idlim=1     ! blank string
         endif
      endif

      if(lgth == 0)then                                        ! command was totally blank
         return
      endif
!
!     there is at least one non-blank character in the command
!     lgth is the column position of the last non-blank character
!     find next non-delimiter
      icol=1

      if(array(1) == '#N#')then                                ! special flag to not store into character array
         lstore=.false.
      else
         lstore=.true.
      endif

      do iarray=1,n,1                                          ! store into each array element until done or too many words
         NOINCREMENT: do
            if(index(dlim(1:idlim),line_local(icol:icol)) == 0)then  ! if current character is not a delimiter
               istart=icol                                     ! start new token on the non-delimiter character
               ibegin(iarray)=icol
               iend=lgth-istart+1+1                            ! assume no delimiters so put past end of line
               do i10=1,idlim
                  ifound=index(line_local(istart:lgth),dlim(i10:i10))
                  if(ifound > 0)then
                     iend=min(iend,ifound)
                  endif
               enddo
               if(iend <= 0)then                               ! no remaining delimiters
                 iterm(iarray)=lgth
                 if(lstore)then
                    array(iarray)=line_local(istart:lgth)
                 endif
                 icount=iarray
                 return
               else
                 iend=iend+istart-2
                 iterm(iarray)=iend
                 if(lstore)then
                    array(iarray)=line_local(istart:iend)
                 endif
               endif
               icol=iend+2
               exit NOINCREMENT
            endif
            icol=icol+1
         enddo NOINCREMENT
!        last character in line was a delimiter, so no text left
!        (should not happen where blank=delimiter)
         if(icol > lgth)then
           icount=iarray
           if( (iterm(icount)-ibegin(icount)) < 0)then         ! last token was all delimiters
              icount=icount-1
           endif
           return
         endif
      enddo
      icount=n  ! more than n elements
end subroutine delim
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_strings:EDITING] function replaces one
!!    substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!! syntax:
!!
!!      function replace(targetline,old,new,cmd,&
!!       & occurrence, &
!!       & repeat, &
!!       & ignorecase, &
!!       & ierr) result (newline)
!!      character(len=*)                       :: targetline
!!      character(len=*),intent(in),optional   :: old
!!      character(len=*),intent(in),optional   :: new
!!      character(len=*),intent(in),optional   :: cmd
!!      integer,intent(in),optional            :: occurrence
!!      integer,intent(in),optional            :: repeat
!!      logical,intent(in),optional            :: ignorecase
!!      integer,intent(out),optional           :: ierr
!!      character(len=:),allocatable           :: newline
!!
!!##DESCRIPTION
!!    Replace one substring for another in string.
!!    Either CMD or OLD and NEW must be specified.
!!
!!##OPTIONS
!!     targetline  input line to be changed
!!     old         old substring to replace
!!     new         new substring
!!     cmd         alternate way to specify old and new string, in
!!                 the form c/old/new/; where "/" can be any character
!!                 not in "old" or "new".
!!     occurrence  if present, start changing at the Nth occurrence of the
!!                 OLD string. If negative start replacing from the left
!!                 end of the string.
!!     repeat      number of replacements to perform. Defaults to a global
!!                 replacement.
!!     ignorecase  whether to ignore ASCII case or not. Defaults
!!                 to .false. .
!!##RETURNS
!!     newline     allocatable string returned
!!     ierr        error code. iF ier = -1 bad directive, >= 0 then
!!                 count of changes made.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_replace
!!    use M_strings, only : replace
!!    implicit none
!!    character(len=:),allocatable :: line
!!
!!    write(*,*)replace('Xis is Xe string','X','th')
!!    write(*,*)replace('Xis is xe string','x','th',ignorecase=.true.)
!!    write(*,*)replace('Xis is xe string','X','th',ignorecase=.false.)
!!
!!    ! a null old substring means "at beginning of line"
!!    write(*,*) replace('my line of text','','BEFORE:')
!!
!!    ! a null new string deletes occurrences of the old substring
!!    write(*,*) replace('I wonder i ii iii','i','')
!!
!!    ! Examples of the use of RANGE
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=1,repeat=1)
!!    write(*,*)'replace first a with A ['//line//']'
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=3,repeat=3)
!!    write(*,*)'replace a with A for 3rd to 5th occurrence ['//line//']'
!!
!!    line=replace('ababababa','a','',occurrence=3,repeat=3)
!!    write(*,*)'replace a with null instances 3 to 5 ['//line//']'
!!
!!    line=replace( &
!!     & 'a b ab baaa aaaa aa aa a a a aa aaaaaa',&
!!     & 'aa','CCCC',occurrence=-1,repeat=1)
!!    write(*,*)'replace lastaa with CCCC ['//line//']'
!!
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-1,repeat=1)
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-2,repeat=2)
!!
!!    end program demo_replace
!!
!!   Results:
!!
!!     this is the string
!!     this is the string
!!     this is xe string
!!     BEFORE:my line of text
!!     I wonder
!!     replace first a with A [Aaaaaaaaa]
!!     replace a with A for 3rd to 5th occurrence [aaAAAaaaa]
!!     replace a with null instances 3 to 5 [ababbb]
!!     replace lastaa with CCCC [a b ab baaa aaaa aa aa a a a aa aaaaCCCC]
!!     myf90stuff.f90.for
!!     myforstuff.for.f90
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine crack_cmd(cmd,old,new,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)              :: cmd
character(len=:),allocatable,intent(out) :: old,new                ! scratch string buffers
integer                                  :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=1)                         :: delimiters
integer                                  :: itoken
integer,parameter                        :: id=2                   ! expected location of delimiter
logical                                  :: ifok
integer                                  :: lmax                   ! length of target string
integer                                  :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr=0
   old=''
   new=''
   lmax=len_trim(cmd)                       ! significant length of change directive

   if(lmax.ge.4)then                      ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)               ! find delimiter in expected location
      itoken=0                            ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id).eq.cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token .eq. (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*crack_cmd* incorrect change directive -too short')
   endif

end subroutine crack_cmd
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function replace(targetline,old,new,cmd,occurrence,repeat,ignorecase,ierr) result (newline)

! ident_11="@(#) M_strings replace(3f) replace one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
! parameters
character(len=*),intent(in)            :: targetline   ! input line to be changed
character(len=*),intent(in),optional   :: old          ! old substring to replace
character(len=*),intent(in),optional   :: new          ! new substring
character(len=*),intent(in),optional   :: cmd          ! contains the instructions changing the string
integer,intent(in),optional            :: occurrence   ! Nth occurrence of OLD string to start replacement at
integer,intent(in),optional            :: repeat       ! how many replacements
logical,intent(in),optional            :: ignorecase
integer,intent(out),optional           :: ierr         ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
!-----------------------------------------------------------------------------------------------------------------------------------
! returns
character(len=:),allocatable  :: newline               ! output string buffer
!-----------------------------------------------------------------------------------------------------------------------------------
! local
character(len=:),allocatable  :: new_local, old_local, old_local_for_comparison
integer                       :: icount,ichange,ier2
integer                       :: original_input_length
integer                       :: len_old, len_new
integer                       :: ladd
integer                       :: left_margin, right_margin
integer                       :: ind
integer                       :: ic
integer                       :: ichr
integer                       :: range_local(2)
character(len=:),allocatable  :: targetline_for_comparison   ! input line to be changed
logical                       :: ignorecase_local
logical                       :: flip
character(len=:),allocatable  :: targetline_local   ! input line to be changed
!-----------------------------------------------------------------------------------------------------------------------------------
   flip=.false.
   ignorecase_local=.false.
   original_input_length=len_trim(targetline)          ! get non-blank length of input line

!  get old_local and new_local from cmd or old and new
   if(present(cmd))then
      call crack_cmd(cmd,old_local,new_local,ier2)
      if(ier2.ne.0)then
         newline=targetline  ! if no changes are made return original string on error
         if(present(ierr))ierr=ier2
         return
      endif
   elseif(present(old).and.present(new))then
      old_local=old
      new_local=new
   else
      newline=targetline  ! if no changes are made return original string on error
      call journal('sc','*replace* must specify OLD and NEW or CMD')
      return
   endif
   if(present(ignorecase))then
      ignorecase_local=ignorecase
   else
      ignorecase_local=.false.
   endif
   if(present(occurrence))then
      range_local(1)=abs(occurrence)
   else
      range_local(1)=1
   endif
   if(present(repeat))then
      range_local(2)=range_local(1)+repeat-1
   else
      range_local(2)=original_input_length
   endif
   if(ignorecase_local)then
      targetline_for_comparison=lower(targetline)
      old_local_for_comparison=lower(old_local)
   else
      targetline_for_comparison=targetline
      old_local_for_comparison=old_local
   endif
   if(present(occurrence))then
      if(occurrence.lt.0)then
         flip=.true.
         targetline_for_comparison=reverse(targetline_for_comparison)
         targetline_local=reverse(targetline)
         old_local_for_comparison=reverse(old_local_for_comparison)
         old_local=reverse(old_local)
         new_local=reverse(new_local)
      else
         targetline_local=targetline
      endif
   else
      targetline_local=targetline
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   icount=0                                            ! initialize error flag/change count
   ichange=0                                           ! initialize error flag/change count
   len_old=len(old_local)                              ! length of old substring to be replaced
   len_new=len(new_local)                              ! length of new substring to replace old substring
   left_margin=1                                       ! left_margin is left margin of window to change
   right_margin=len(targetline)                        ! right_margin is right margin of window to change
   newline=''                                          ! begin with a blank line as output string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old.eq.0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(len_new.gt.0)then
         newline=new_local(:len_new)//targetline_local(left_margin:original_input_length)
      else
         newline=targetline_local(left_margin:original_input_length)
      endif
      ichange=1                                        ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ichange
      if(flip) newline=reverse(newline)
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=left_margin                                    ! place to put characters into output string
   ic=left_margin                                      ! place looking at in input string
   loop: do
                                                       ! try finding start of OLD in remaining part of input in change window
      ind=index(targetline_for_comparison(ic:),old_local_for_comparison(:len_old))+ic-1
      if(ind.eq.ic-1.or.ind.gt.right_margin)then       ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      icount=icount+1                                  ! found an old string to change, so increment count of change candidates
      if(ind.gt.ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         newline=newline(:ichr-1)//targetline_local(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(icount.ge.range_local(1).and.icount.le.range_local(2))then    ! check if this is an instance to change or keep
         ichange=ichange+1
         if(len_new.ne.0)then                                          ! put in new string
            newline=newline(:ichr-1)//new_local(:len_new)
            ichr=ichr+len_new
         endif
      else
         if(len_old.ne.0)then                                          ! put in copy of old string
            newline=newline(:ichr-1)//old_local(:len_old)
            ichr=ichr+len_old
         endif
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ichange)
   case (0)                                            ! there were no changes made to the window
      newline=targetline_local                         ! if no changes made output should be input
   case default
      if(ic.le.len(targetline))then                    ! if there is more after last change on original line add it
         newline=newline(:ichr-1)//targetline_local(ic:max(ic,original_input_length))
      endif
   end select
   if(present(ierr))ierr=ichange
   if(flip) newline=reverse(newline)
!-----------------------------------------------------------------------------------------------------------------------------------
end function replace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    substitute(3f) - [M_strings:EDITING] subroutine globally substitutes
!!    one substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine substitute(targetline,old,new,ierr,start,end)
!!
!!     character(len=*)              :: targetline
!!     character(len=*),intent(in)   :: old
!!     character(len=*),intent(in)   :: new
!!     integer,intent(out),optional  :: ierr
!!     integer,intent(in),optional   :: start
!!     integer,intent(in),optional   :: end
!!
!!##DESCRIPTION
!!    Globally substitute one substring for another in string.
!!
!!##OPTIONS
!!     TARGETLINE  input line to be changed. Must be long enough to
!!                 hold altered output.
!!     OLD         substring to find and replace
!!     NEW         replacement for OLD substring
!!     IERR        error code. If IER = -1 bad directive, >= 0 then
!!                 count of changes made.
!!     START       sets the left margin to be scanned for OLD in
!!                 TARGETLINE.
!!     END         sets the right margin to be scanned for OLD in
!!                 TARGETLINE.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_substitute
!!    use M_strings, only : substitute
!!    implicit none
!!    ! must be long enough to hold changed line
!!    character(len=80) :: targetline
!!
!!    targetline='this is the input string'
!!    write(*,*)'ORIGINAL    : '//trim(targetline)
!!
!!    ! changes the input to 'THis is THe input string'
!!    call substitute(targetline,'th','TH')
!!    write(*,*)'th => TH    : '//trim(targetline)
!!
!!    ! a null old substring means "at beginning of line"
!!    ! changes the input to 'BEFORE:this is the input string'
!!    call substitute(targetline,'','BEFORE:')
!!    write(*,*)'"" => BEFORE: '//trim(targetline)
!!
!!    ! a null new string deletes occurrences of the old substring
!!    ! changes the input to 'ths s the nput strng'
!!    call substitute(targetline,'i','')
!!    write(*,*)'i => ""     : '//trim(targetline)
!!
!!    end program demo_substitute
!!
!!   Expected output
!!
!!     ORIGINAL    : this is the input string
!!     th => TH    : THis is THe input string
!!     "" => BEFORE: BEFORE:THis is THe input string
!!     i => ""     : BEFORE:THs s THe nput strng
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine substitute(targetline,old,new,ierr,start,end)

! ident_12="@(#) M_strings substitute(3f) Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichr
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option ! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id.le.0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old.eq.0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(ichr.gt.maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new.gt.0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=il                                            ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind.eq.ic-1.or.ind.gt.ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind.gt.ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(ichr-1+ladd.gt.maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichr:)=targetline(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(ichr-1+len_new.gt.maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new.ne.0)then
         dum1(ichr:)=new(:len_new)
         ichr=ichr+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      call journal('sc','*substitute* new line will be too long')
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichr+ladd.gt.maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic.lt.len(targetline))then
         dum1(ichr:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    change(3f) - [M_strings:EDITING] change old string to new string with
!!    a directive like a line editor
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine change(target_string,cmd,ierr)
!!
!!     character(len=*),intent(inout) :: target_string
!!     character(len=*),intent(in)    :: cmd
!!     integer                        :: ierr
!!
!!##DESCRIPTION
!!    change an old substring into a new substring in a character variable
!!    like a line editor. Primarily used to create interactive utilities
!!    such as input history editors for interactive line-mode programs. The
!!    output string is assumed long enough to accommodate the change.
!!    a directive resembles a line editor directive of the form
!!
!!       C/old_string/new_string/
!!
!!    where / may be any character which is not included in old_string
!!    or new_string.
!!
!!    a null old_string implies "beginning of string".
!!
!!##OPTIONS
!!    target_string  line to be changed
!!    cmd            contains instructions to change the string
!!    ierr           error code.
!!
!!       o =-1 bad directive
!!       o =0 no changes made
!!       o >0 count of changes made
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_change
!!
!!     use M_strings, only : change
!!     implicit none
!!     character(len=132) :: line='This is a test string to change'
!!     integer            :: ierr
!!        write(*,*)trim(line)
!!        ! change miniscule a to uppercase A
!!        call change(line,'c/a/A/',ierr)
!!        write(*,*)trim(line)
!!        ! put string at beginning of line
!!        call change(line,'c//prefix: /',ierr)
!!        write(*,*)trim(line)
!!        ! remove blanks
!!        call change(line,'c/ //',ierr)
!!        write(*,*)trim(line)
!!    end program demo_change
!!
!!   Expected output
!!
!!     This is a test string to change
!!     This is A test string to chAnge
!!     prefix: This is A test string to chAnge
!!     prefix:ThisisAteststringtochAnge
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine change(target_string,cmd,ierr)
! Change a string assumed long enough to accommodate the change, with a directive that resembles a line editor directive of the form
!    C/old_string/new_string/
! where / may be any character which is not included in old_string or new_string.
! a null old_string implies "beginning of string"
!===================================================================================================================================

! ident_13="@(#) M_strings change(3f) change a character string like a line editor"

character(len=*),intent(inout)   :: target_string          ! line to be changed
character(len=*),intent(in)      :: cmd                    ! contains the instructions changing the string
character(len=1)                 :: delimiters
integer                          :: ierr                   ! error code. ier=-1 bad directive;=0 no changes made;>0 ier changes made
integer                          :: itoken
integer,parameter                :: id=2                   ! expected location of delimiter
character(len=:),allocatable     :: old,new                ! scratch string buffers
logical                          :: ifok
integer                          :: lmax                   ! length of target string
integer                          :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   lmax=len_trim(cmd)                                                          ! significant length of change directive
   if(lmax.ge.4)then                         ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)                                                    ! find delimiter in expected location
      itoken=0                                                                 ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id).eq.cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token .eq. (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif

      call substitute(target_string,old,new,ierr,1,len_trim(target_string))    ! change old substrings to new substrings
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*change* incorrect change directive -too short')
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine change
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     strtok(3f) - [M_strings:TOKENS] Tokenize a string
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!  function strtok(source_string,itoken,token_start,token_end,delimiters)
!!  result(strtok_status)
!!
!!   ! returned value
!!   logical                      :: strtok_status
!!   ! string to tokenize
!!   character(len=*),intent(in)  :: source_string
!!   ! token count since started
!!   integer,intent(inout)        :: itoken
!!   ! beginning of token
!!   integer,intent(out)          :: token_start
!!   ! end of token
!!   integer,intent(inout)        :: token_end
!!   ! list of separator characters
!!   character(len=*),intent(in)  :: delimiters
!!
!!##DESCRIPTION
!!     The STRTOK(3f) function is used to isolate sequential tokens in a
!!     string, SOURCE_STRING. These tokens are delimited in the string by
!!     at least one of the characters in DELIMITERS. The first time that
!!     STRTOK(3f) is called, ITOKEN should be specified as zero. Subsequent
!!     calls, wishing to obtain further tokens from the same string,
!!     should pass back in TOKEN_END  and ITOKEN until the function result
!!     returns .false.
!!
!!     This routine assumes no other calls are made to it using any other
!!     input string while it is processing an input line.
!!
!!##OPTIONS
!!     source_string  input string to parse
!!     itoken         token count should be set to zero for a new string
!!     delimiters     characters used to determine the end of tokens
!!
!!##RETURN
!!     token_start    beginning position in SOURCE_STRING where token was found
!!     token_end      ending position in SOURCE_STRING where token was found
!!     strtok_status
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_strtok
!!     use M_strings, only : strtok
!!     implicit none
!!     character(len=264)          :: inline
!!     character(len=*),parameter  :: delimiters=' ;,'
!!     integer                     :: ios, itoken, istart, iend
!!        do ! read lines from stdin until end-of-file or error
!!           read (unit=*,fmt="(a)",iostat=ios) inline
!!           if(ios.ne.0)stop
!!           ! must set ITOKEN=0 before looping on strtok(3f)
!!           ! on a new string.
!!           itoken=0
!!           do while &
!!           &( strtok(inline,itoken,istart,iend,delimiters) )
!!              print *, itoken,&
!!              & 'TOKEN=['//(inline(istart:iend))//']',istart,iend
!!           enddo
!!        enddo
!!     end program demo_strtok
!!
!!     sample input file
!!
!!      this is a test of strtok; A:B :;,C;;
!!
!!     sample output file
!!
!!     1  TOKEN=[this]    2   5
!!     2  TOKEN=[is]      7   8
!!     3  TOKEN=[a]       10  10
!!     4  TOKEN=[test]    12  15
!!     5  TOKEN=[of]      17  18
!!     6  TOKEN=[strtok]  20  25
!!     7  TOKEN=[A:B]     28  30
!!     8  TOKEN=[:]       32  32
!!     9  TOKEN=[C]       35  35
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
FUNCTION strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)
! JSU- 20151030

! ident_14="@(#) M_strings strtok(3f) Tokenize a string"

character(len=*),intent(in)  :: source_string    ! Source string to tokenize.
character(len=*),intent(in)  :: delimiters       ! list of separator characters. May change between calls
integer,intent(inout)        :: itoken           ! token count since started
logical                      :: strtok_status    ! returned value
integer,intent(out)          :: token_start      ! beginning of token found if function result is .true.
integer,intent(inout)        :: token_end        ! end of token found if function result is .true.
integer,save                 :: isource_len
!----------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(itoken.le.0)then                           ! this is assumed to be the first call
      token_start=1
   else                                          ! increment start to previous end + 1
      token_start=token_end+1
   endif
!----------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!----------------------------------------------------------------------------------------------------------------------------
   if(token_start.gt.isource_len)then            ! user input error or at end of string
      token_end=isource_len                      ! assume end of token is end of string until proven otherwise so it is set
      strtok_status=.false.
      return
   endif
!----------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   do while (token_start .le. isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_start:token_start)) .ne. 0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end .le. isource_len-1)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_end+1:token_end+1)) .ne. 0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   if (token_start .gt. isource_len) then        ! determine if finished
      strtok_status=.false.                      ! flag that input string has been completely processed
   else
      itoken=itoken+1                            ! increment count of tokens found
      strtok_status=.true.                       ! flag more tokens may remain
   endif
!----------------------------------------------------------------------------------------------------------------------------
end function strtok
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    modif(3f) - [M_strings:EDITING] emulate the MODIFY command from the
!!    line editor XEDIT
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine modif(cline,cmod)
!!
!!     character(len=*) :: cline ! input string to change
!!     ! directive provides directions on changing string
!!     character(len=*) :: cmod
!!
!!##DESCRIPTION
!!   MODIF(3f) Modifies the line currently pointed at using a directive
!!   that acts much like a line editor directive.
!!   Primarily used to create interactive utilities such as input history
!!   editors for interactive line-mode programs.
!!
!!   the modify directives are as follows-
!!
!!    DIRECTIVE EXPLANATION
!!
!!    ^STRING#   Causes the string of characters between the ^ and the
!!               next # to be inserted before the characters pointed to
!!               by the ^. an ^ or & within the string is treated as a
!!               regular character. If the closing # is not specified,
!!               MODIF(3f) inserts the remainder of the line as if a # was
!!               specified after the last nonblank character.
!!
!!               There are two exceptions. the combination ^# causes a #
!!               to be inserted before the character pointed to by the
!!               ^, and an ^ as the last character of the directives
!!               causes a blank to be inserted.
!!
!!    #          (When not the first # after an ^) causes the character
!!               above it to be deleted.
!!
!!    &          Replaces the character above it with a space.
!!
!!    (SPACE)    A space below a character leaves it unchanged.
!!
!!    Any other character replaces the character above it.
!!
!!##EXAMPLES
!!
!!   Example input/output:
!!
!!    THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
!!    THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
!!    ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!!
!!   Sample program:
!!
!!    program demo_modif
!!    use M_strings, only : modif
!!    implicit none
!!    character(len=256)           :: line
!!    integer                      :: ios
!!    integer                      :: count
!!    integer                      :: COMMAND_LINE_LENGTH
!!    character(len=:),allocatable :: COMMAND_LINE
!!       ! get command name length
!!       call get_command_argument(0,length=count)
!!       ! get command line length
!!       call get_command(length=COMMAND_LINE_LENGTH)
!!       ! allocate string big enough to hold command line
!!       allocate(character(len=COMMAND_LINE_LENGTH+200) :: COMMAND_LINE)
!!       ! get command line as a string
!!       call get_command(command=COMMAND_LINE)
!!       ! trim leading spaces just in case
!!       COMMAND_LINE=adjustl(COMMAND_LINE)
!!       ! remove command name
!!       COMMAND_LINE=adjustl(COMMAND_LINE(COUNT+2:))
!!       INFINITE: do
!!          read(*,'(a)',iostat=ios)line
!!          if(ios.ne.0)exit
!!          call modif(line,COMMAND_LINE)
!!          write(*,'(a)')trim(line)
!!       enddo INFINITE
!!    end program demo_modif
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine modif(cline,mod)

!$@(#) M_strings::modif(3f): Emulate the MODIFY command from the line editor XEDIT

!
! MODIF
! =====
! ACTION- MODIFIES THE LINE CURRENTLY POINTED AT. THE INPUT STRING CLINE IS ASSUMED TO BE LONG ENOUGH TO ACCOMMODATE THE CHANGES
!         THE MODIFY DIRECTIVES ARE AS FOLLOWS-
!
!   DIRECTIVE                       EXPLANATION
!   ---------                       ------------
!   ^STRING#   CAUSES THE STRING OF CHARACTERS BETWEEN THE ^ AND THE
!              NEXT  # TO BE INSERTED BEFORE THE CHARACTERS POINTED TO
!              BY THE ^. AN ^ OR & WITHIN THE STRING IS TREATED AS A
!              REGULAR CHARACTER. IF THE CLOSING # IS NOT SPECIFIED,
!              MODIF(3f) INSERTS THE REMAINDER OFTHELINE AS IF A # WAS
!              SPECIFIED AFTER THE LAST NONBLANK CHARACTER.
!
!              THERE ARE TWO EXCEPTIONS. THE COMBINATION ^# CAUSES A #
!              TO BE INSERTED BEFORE THE CHARACTER POINTED TO BY THE
!              ^,  AND AN ^ AS THE LAST CHARACTER OF THE DIRECTIVES
!              CAUSES A BLANK TO BE INSERTED.
!
!   #          (WHEN NOT THE FIRST # AFTER AN ^) CAUSES THE CHARACTER
!              ABOVE IT TO BE DELETED.
!
!   &          REPLACES THE CHARACTER ABOVE IT WITH A SPACE.
!
!   (SPACE)    A SPACE BELOW A CHARACTER LEAVES IT UNCHANGED.
!
!   ANY OTHER CHARACTER REPLACES THE CHARACTER ABOVE IT.
!
! EXAMPLE-
! THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
! THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
! ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
character(len=*)            :: cline        !STRING TO BE MODIFIED
character(len=*),intent(in) :: mod          !STRING TO DIRECT MODIFICATION
character(len=len(cline))   :: cmod
character(len=3),parameter  :: c='#&^'      !ASSIGN DEFAULT EDIT CHARACTERS
integer                     :: maxscra      !LENGTH OF SCRATCH BUFFER
character(len=len(cline))   :: dum2         !SCRATCH CHARACTER BUFFER
logical                     :: linsrt       !FLAG FOR INSERTING DATA ON LINE
integer :: i, j, ic, ichr, iend, lmax, lmx1
maxscra=len(cline)
   cmod=trim(mod)
   lmax=min0(len(cline),maxscra)         !DETERMINE MAXIMUM LINE LENGTH
   lmx1=lmax-1                           !MAX LINE LENGTH -1
   dum2=' '                              !INITIALIZE NEW LINE
   linsrt=.false.                        !INITIALIZE INSERT MODE
   iend=len_trim(cmod)                   !DETERMINE END OF MODS
   i=0                                   !CHAR COUNTER FOR MOD LINE CMOD
   ic=0                                  !CHAR COUNTER FOR CURRENT LINE CLINE
   ichr=0                                !CHAR COUNTER NEW LINE DUM2
11 continue
   i=i+1                                 !NEXT CHAR IN MOD LINE
   if(ichr.gt.lmx1)goto 999              !IF TOO MANY CHARS IN NEW LINE
   if(linsrt) then                       !IF INSERTING NEW CHARS
      if(i.gt.iend) cmod(i:i)=c(1:1)     !FORCE END OF INSERT MODE
      if(cmod(i:i).eq.c(1:1))then        !IF END OF INSERT MODE
         linsrt=.false.                  !RESET INSERT MODE FLAG
         if(ic+1.eq.i)then               !NULL INSERT STRING
            ichr=ichr+1                  !INCREMENT COUNTER FOR NEW LINE
            dum2(ichr:ichr)=c(1:1)       !INSERT INSERT MODE TERMINATOR
         endif
         do j=ic,i                       !LOOP OF NUMBER OF CHARS INSERTED
            ichr=ichr+1                  !INCREMENT COUNTER FOR NEW LINE
            if(ichr.gt.lmax)goto 999     !IF AT BUFFER LIMIT, QUIT
            dum2(ichr:ichr)=cline(j:j)   !APPEND CHARS FROM ORIG LINE
         enddo                           !...WHICH ALIGN WITH INSERTED CHARS
         ic=i                            !RESET CHAR COUNT TO END OF INSERT
         goto 1                          !CHECK NEW LINE LENGTH AND CYCLE
      endif                              !END OF TERMINATED INSERT LOGIC
      ichr=ichr+1                        !INCREMENT NEW LINE COUNT
      dum2(ichr:ichr)=cmod(i:i)          !SET NEWLINE CHAR TO INSERTED CHAR
   else                                  !IF NOT INSERTING CHARACTERS
      ic=ic+1                            !INCREMENT ORIGINAL LINE COUNTER
      if(cmod(i:i).eq.c(1:1))goto 1      !IF DELETE CHAR. NO COPY AND CYCLE
      if(cmod(i:i).eq.c(3:3))then        !IF BEGIN INSERT MODE
         linsrt=.true.                   !SET INSERT FLAG TRUE
         goto 1                          !CHECK LINE LENGTH AND CONTINUE
      endif                              !IF NOT BEGINNING INSERT MODE
      ichr=ichr+1                        !INCREMENT NEW LINE COUNTER
      if(cmod(i:i).eq.c(2:2))then        !IF REPLACE WITH BLANK
         dum2(ichr:ichr)=' '             !SET NEWLINE CHAR TO BLANK
         goto 1                          !CHECK LINE LENGTH AND CYCLE
      endif                              !IF NOT REPLACE WITH BLANK
      if(cmod(i:i).eq.' ')then           !IF BLANK, KEEP ORIGINAL CHARACTER
         dum2(ichr:ichr)=cline(ic:ic)    !SET NEW CHAR TO ORIGINAL CHAR
      else                               !IF NOT KEEPING OLD CHAR
         dum2(ichr:ichr)=cmod(i:i)       !REPLACE ORIGINAL CHAR WITH NEW
      endif                              !END CHAR KEEP OR REPLACE
   endif                                 !END INSERT OR NO-INSERT
1  continue
   if(i.lt.lmax)goto 11                  !CHECK FOR END OF LINE REACHED
                                         !AND CYCLE IF OK
999   continue
   cline=dum2                            !SET ORIGINAL CHARS TO NEW CHARS
end subroutine modif                     !RETURN
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      len_white(3f) - [M_strings:LENGTH] get length of string trimmed
!!      of whitespace.
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    integer function len_white(string)
!!
!!     character(len=*) :: string
!!
!!##DESCRIPTION
!!      len_white(3f) returns the position of the last character in
!!      string that is not a whitespace character. The Fortran90 intrinsic
!!      LEN_TRIM() should be used when trailing whitespace can be assumed
!!      to always be spaces.
!!
!!      This procedure was heavily used in the past because ANSI FORTRAN
!!      77 character objects are fixed length and blank padded and the
!!      LEN_TRIM() intrinsic did not exist. It should now be used only when
!!      whitespace characters other than blanks are likely.
!!
!!##OPTIONS
!!      string     input string whose trimmed length is being calculated
!!                 ignoring all trailing whitespace characters.
!!##RETURNS
!!      len_white  the number of characters in the trimmed string
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_len_white
!!
!!      use M_strings, only : len_white
!!      implicit none
!!      character(len=80) ::  s
!!      integer           :: lgth, lastnb
!!      intrinsic len
!!
!!      s=' ABCDEFG abcdefg '
!!      lgth = len(s)
!!      lastnb = len_white(s)
!!
!!      write(*,*) 'total length of variable is ',lgth
!!      write(*,*) 'trimmed length of variable is ',lastnb
!!      write(*,*) 'trimmed string=[',s(:lastnb),']'
!!
!!     end program demo_len_white
!!
!!   Results:
!!
!!     total length of variable is           80
!!     trimmed length of variable is           16
!!     trimmed string=[ ABCDEFG abcdefg]
!!
!!##NOTES
!!
!! o len_white
!!
!!      is a resource-intensive routine. Once the end of
!!      the string is found, it is probably best to keep track of it in
!!      order to avoid repeated calls to len_white. Because they
!!      might be more efficient, consider looking for vendor-supplied or
!!      system-optimized equivalents. For example:
!!
!!         o lnblnk - Solaris f77
!!         o len_trim - FORTRAN 90
!!
!! o Some compilers seem to have trouble passing a string of variable
!!   length properly. To be safe, use something like this:
!!
!!       subroutine message(s)
!!        character(len=*) :: s ! s is of variable length
!!           lgth=len(s)        ! get total length of variable
!!           ! explicitly specify a substring instead of just variable name
!!           lastnb = len_white(s(:lgth))
!!           write(*,*)'error:[',s(:lastnb),']'
!!       end subroutine messages
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental integer function len_white(string)
!  DEPRECATED. Use len_trim(3f),trim(3f) unless you might have trailing nulls (common when interacting with C procedures)"
!  John S. Urban, 1984, 1997-12-31
!  Note that if the string is blank, a length of 0 is returned; which is not a legal string length in Fortran77.
!  this routine used to return one instead of zero.
!   - mod 1:     1994
!                added null (char(0)) because HP and some Suns not padding
!                strings with blank, but with null characters; 1994 JSU
!   - mod 2:     1999
!                update syntax with INTENT(), ENDDO, no RETURN
!                still need instead of LEN_TRIM() because some systems stil pad CHARACTER with NULL
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_15="@(#) M_strings len_white(3f) return position of last non-blank/non-null character in string"

character(len=*),intent(in):: string ! input string to determine length of
integer                    :: i10
intrinsic len
   len_white=0
   do i10=len(string),1,-1
      select case(string(i10:i10))
      case(' ')                 ! space(32)
      case(char(0))             ! null(0)
      case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13)
      case default
         len_white=i10
         exit
      end select
   enddo
end function len_white
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    crop(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks
!!               and control characters from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function crop(strin) result (strout)
!!
!!     character(len=*),intent(in)  :: strin
!!     character(len=:),allocatable :: strout
!!
!!##DESCRIPTION
!!    All control characters throughout the string are replaced with spaces
!!    and leading and trailing spaces are trimmed from the resulting string.
!!    Tabs are expanded assuming a stop every eight characters.
!!
!!##OPTIONS
!!    strin   input string to trim leading and trailing space and control
!!    characters
!!            from
!!
!!##RETURNS
!!    strout  cropped version of input string
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_crop
!!    use M_strings, only: crop
!!    implicit none
!!    character(len=20) ::  untrimmed = '   ABCDEFG abcdefg  '
!!       write(*,*) 'untrimmed string=[',untrimmed,']'
!!       write(*,*) 'cropped string=[',crop(untrimmed),']'
!!    end program demo_crop
!!
!!   Expected output
!!
!!      untrimmed string=[   ABCDEFG abcdefg                      ]
!!      cropped string=[ABCDEFG abcdefg]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function crop(strin) result (strout)

! ident_16="@(#) M_strings crop(3f) replace control characters with whitespace and trim leading and trailings spaces from resulting string"

character(len=*),intent(in)  :: strin
character(len=:),allocatable :: strout
   strout=trim(adjustl(noesc(dilate(strin))))
end function crop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    transliterate(3f) - [M_strings:EDITING] replace characters from old
!!                        set with new set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function transliterate(instr,old_set,new_set) result(outstr)
!!
!!     character(len=*),intent(in)  :: instr
!!     character(len=*),intent(in)  :: old_set
!!     character(len=*),intent(in)  :: new_set
!!     character(len=len(instr))    :: outstr
!!
!!##DESCRIPTION
!!    Translate, squeeze, and/or delete characters from the input string.
!!
!!##OPTIONS
!!    instr    input string to change
!!    old_set  list of letters to change in INSTR if found
!!
!!             Each character in the input string that matches a character
!!             in the old set is replaced.
!!
!!    new_set  list of letters to replace letters in OLD_SET with.
!!
!!             If the new_set is the empty set the matched characters
!!             are deleted.
!!
!!             If the new_set is shorter than the old set the last character
!!             in the new set is used to replace the remaining characters
!!             in the new set.
!!
!!##RETURNS
!!    outstr   instr with substitutions applied
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_transliterate
!!
!!     use M_strings, only : transliterate
!!     implicit none
!!     character(len=80)   :: STRING
!!
!!     STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'
!!     write(*,'(a)') STRING
!!
!!     ! convert a string to uppercase:
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
!!
!!     ! change all miniscule letters to a colon (":"):
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz',':')
!!
!!     ! delete all miniscule letters
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','')
!!
!!    end program demo_transliterate
!!
!!    Expected output
!!
!!     > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
!!     > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
!!     > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z
!!     > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
PURE FUNCTION transliterate(instr,old_set,new_set) RESULT(outstr)

! ident_17="@(#) M_strings transliterate(3f) replace characters from old set with new set"

!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=*),INTENT(IN)  :: instr                             ! input string to change
CHARACTER(LEN=*),intent(in)  :: old_set
CHARACTER(LEN=*),intent(in)  :: new_set
!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=LEN(instr))    :: outstr                            ! output string to generate
!-----------------------------------------------------------------------------------------------------------------------------------
INTEGER                      :: i10                               ! loop counter for stepping thru string
INTEGER                      :: ii,jj
!-----------------------------------------------------------------------------------------------------------------------------------
   jj=LEN(new_set)
   IF(jj.NE.0)THEN
      outstr=instr                                                ! initially assume output string equals input string
      stepthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))                         ! see if current character is in old_set
         IF (ii.NE.0)THEN
            if(ii.le.jj)then                                      ! use corresponding character in new_set
               outstr(i10:i10) = new_set(ii:ii)
            else
               outstr(i10:i10) = new_set(jj:jj)                   ! new_set not as long as old_set; use last character in new_set
            endif
         ENDIF
      ENDDO stepthru
   else                                                           ! new_set is null string so delete characters in old_set
      outstr=' '
      hopthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))                         ! see if current character is in old_set
         IF (ii.EQ.0)THEN                                         ! only keep characters not in old_set
            jj=jj+1
            outstr(jj:jj) = instr(i10:i10)
         ENDIF
      ENDDO hopthru
   endif
END FUNCTION transliterate
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    rotate13(3f) - [M_strings] apply trivial ROT13 encryption to a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    rotate13(input) result(output)
!!
!!     character(len=*),intent(in) :: input
!!     character(len=len(input))   :: output
!!
!!##DESCRIPTION
!!    ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple
!!    letter substitution cipher that replaces a letter with the 13th letter
!!    after it in the alphabet; wrapping around if necessary.
!!
!!    The transformation can be done using a lookup table, such as the
!!    following:
!!
!!       Input  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
!!       Output NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm
!!
!!    ROT13 is used in online forums as a means of hiding spoilers,
!!    punchlines, puzzle solutions, and offensive materials from the casual
!!    glance. ROT13 has inspired a variety of letter and word games on-line,
!!    and is frequently mentioned in newsgroup conversations.
!!
!!    The algorithm provides virtually no cryptographic security, and is
!!    often cited as a canonical example of weak encryption.
!!
!!    ROT13 is a special case of the Caesar cipher which was developed in
!!    ancient Rome.
!!
!!    ALGORITHM
!!
!!    Applying ROT13 to a piece of text merely requires examining its
!!    alphabetic characters and replacing each one by the letter 13 places
!!    further along in the alphabet, wrapping back to the beginning if
!!    necessary. A becomes N, B becomes O, and so on up to M, which becomes
!!    Z, then the sequence continues at the beginning of the alphabet: N
!!    becomes A, O becomes B, and so on to Z, which becomes M. Only those
!!    letters which occur in the English alphabet are affected; numbers,
!!    symbols, whitespace, and all other characters are left unchanged.
!!
!!    SAME ALGORITHM FOR ENCODING AND DECODING
!!
!!    Because there are 26 letters in the English alphabet and 26 = 2 x 13,
!!    the ROT13 function is its own inverse: so the same action can be used
!!    for encoding and decoding. In other words, two successive applications
!!    of ROT13 restore the original text (in mathematics, this is sometimes
!!    called an involution; in cryptography, a reciprocal cipher).
!!
!!    TRIVIAL SECURITY
!!
!!    The use of a constant shift means that the encryption effectively
!!    has no key, and decryption requires no more knowledge than the fact
!!    that ROT13 is in use. Even without this knowledge, the algorithm is
!!    easily broken through frequency analysis.
!!
!!    In encrypted normal English-language text of any significant size,
!!    ROT13 is recognizable from some letter/word patterns. The words "n",
!!    "V" (capitalized only), and "gur" (ROT13 for "a", "I", and "the"),
!!    and words ending in "yl" ("ly") are examples.
!!
!!##REFERENCES
!!    Wikipedia, the free encyclopedia
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_rotate13
!!    use M_strings, only : rotate13
!!    implicit none
!!    character(len=256) :: line
!!    integer            :: ios
!!    do
!!       read(*,'(a)',iostat=ios)line
!!       if(ios.ne.0)exit
!!       write(*,'(a)')rotate13(line)
!!    enddo
!!    end program demo_rotate13
!!
!!  Sample usage:
!!
!!    demo_rotate13
!!    United we stand, divided we fall.
!!    Havgrq jr fgnaq, qvivqrq jr snyy.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rotate13 (input)
implicit none

! ident_18="@(#) M_strings rotate13(3f) converts a character to its ROT13 equivalent which is a trivial encryption."

character(len=*),intent(in) :: input
character(len=len(input))   :: rotate13
integer                     :: itemp
integer                     :: i
   rotate13=' '
   do i=1,len_trim(input)
      itemp = iachar(input(i:i))
      select case(itemp)
       case(65:77,97:109)
         itemp = itemp + 13
       case(78:90,110:122)
         itemp = itemp - 13
      end select
      rotate13(i:i) = char ( itemp )
   enddo

end function rotate13
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    join(3f) - [M_strings:EDITING] append CHARACTER variable array into
!!    a single CHARACTER variable with specified separator
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function join(str,sep,trm,left,right,start,end) result (string)
!!
!!     character(len=*),intent(in)          :: str(:)
!!     character(len=*),intent(in),optional :: sep
!!     logical,intent(in),optional          :: trm
!!     character(len=*),intent(in),optional :: right
!!     character(len=*),intent(in),optional :: left
!!     character(len=*),intent(in),optional :: start
!!     character(len=*),intent(in),optional :: end
!!     character(len=:),allocatable         :: string
!!
!!##DESCRIPTION
!!   JOIN(3f) appends the elements of a CHARACTER array into a single
!!   CHARACTER variable, with elements 1 to N joined from left to right.
!!   By default each element is trimmed of trailing spaces and the
!!   default separator is a null string.
!!
!!##OPTIONS
!!      STR(:)  array of CHARACTER variables to be joined
!!      SEP     separator string to place between each variable. defaults
!!              to a null string.
!!      LEFT    string to place at left of each element
!!      RIGHT   string to place at right of each element
!!      START   prefix string
!!      END     suffix string
!!      TRM     option to trim each element of STR of trailing
!!              spaces. Defaults to .TRUE.
!!
!!##RESULT
!!      STRING  CHARACTER variable composed of all of the elements of STR()
!!              appended together with the optional separator SEP placed
!!              between the elements.
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!   program demo_join
!!   use M_strings, only: join
!!   implicit none
!!   character(len=:),allocatable  :: s(:)
!!   character(len=:),allocatable  :: out
!!   integer                       :: i
!!     s=[character(len=10) :: 'United',' we',' stand,', &
!!     & ' divided',' we fall.']
!!     out=join(s)
!!     write(*,'(a)') out
!!     write(*,'(a)') join(s,trm=.false.)
!!     write(*,'(a)') (join(s,trm=.false.,sep='|'),i=1,3)
!!     write(*,'(a)') join(s,sep='<>')
!!     write(*,'(a)') join(s,sep=';',left='[',right=']')
!!     write(*,'(a)') join(s,left='[',right=']')
!!     write(*,'(a)') join(s,left='>>')
!!   end program demo_join
!!
!!  Expected output:
!!
!!   United we stand, divided we fall.
!!   United     we        stand,    divided   we fall.
!!   United    | we       | stand,   | divided  | we fall.
!!   United    | we       | stand,   | divided  | we fall.
!!   United    | we       | stand,   | divided  | we fall.
!!   United<> we<> stand,<> divided<> we fall.
!!   [United];[ we];[ stand,];[ divided];[ we fall.]
!!   [United][ we][ stand,][ divided][ we fall.]
!!   >>United>> we>> stand,>> divided>> we fall.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function join(str,sep,trm,left,right,start,end) result (string)

! ident_19="@(#) M_strings join(3f) merge string array into a single CHARACTER value adding specified separators caps prefix and suffix"

character(len=*),intent(in)          :: str(:)
character(len=*),intent(in),optional :: sep, right, left, start, end
logical,intent(in),optional          :: trm
character(len=:),allocatable         :: sep_local, left_local, right_local
character(len=:),allocatable         :: string
logical                              :: trm_local
integer                              :: i
   if(present(sep))then   ; sep_local=sep     ; else ; sep_local=''     ; endif
   if(present(trm))then   ; trm_local=trm     ; else ; trm_local=.true. ; endif
   if(present(left))then  ; left_local=left   ; else ; left_local=''    ; endif
   if(present(right))then ; right_local=right ; else ; right_local=''   ; endif
   string=''
   if(size(str).eq.0)then
      string=string//left_local//right_local
   else
      do i = 1,size(str)-1
         if(trm_local)then
            string=string//left_local//trim(str(i))//right_local//sep_local
         else
            string=string//left_local//str(i)//right_local//sep_local
         endif
      enddo
      if(trm_local)then
         string=string//left_local//trim(str(i))//right_local
      else
         string=string//left_local//str(i)//right_local
      endif
   endif
   if(present(start))string=start//string
   if(present(end))string=string//end
end function join
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      reverse(3f) - [M_strings:EDITING] Return a string reversed
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function reverse(str) result (string)
!!
!!     character(*), intent(in) :: str
!!     character(len(str))      :: string
!!
!!##DESCRIPTION
!!      reverse(string) returns a copy of the input string with
!!      all characters reversed from right to left.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!       program demo_reverse
!!       use M_strings, only: reverse
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          write(*,*)'REVERSE STRINGS:',reverse('Madam, I''m Adam')
!!          s='abcdefghijklmnopqrstuvwxyz'
!!          write(*,*) 'original input string is ....',s
!!          write(*,*) 'reversed output string is ...',reverse(s)
!!       end program demo_reverse
!!
!!    Expected output
!!
!!      original input string is ....abcdefghijklmnopqrstuvwxyz
!!      reversed output string is ...zyxwvutsrqponmlkjihgfedcba
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function reverse(string ) result (rev)

! ident_20="@(#) M_strings reverse(3f) Return a string reversed"

character(len=*),intent(in)    :: string   ! string to reverse
character(len=len(string))     :: rev      ! return value (reversed string)
integer                        :: length
integer                        :: i
   length = len(string)
   do i = 1,length
      rev(i:i)=string(length-i+1:length-i+1)
   enddo
end function reverse
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper_quoted(3f) - [M_strings:CASE] elemental function converts string to
!!                miniscule skipping strings quoted per Fortran syntax rules
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper_quoted(str) result (string)
!!
!!     character(*), intent(in)    :: str
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!    upper_quoted(string) returns a copy of the input string with all not-quoted
!!    characters converted to uppercase, assuming ASCII character sets
!!    are being used. The quoting rules are the same as for Fortran source.
!!    Either a single or double quote starts a quoted string, and a quote
!!    character of the same type is doubled when it appears internally in
!!    the quoted string. If a double quote quotes the string single quotes
!!    may appear in the quoted string as single characters, and vice-versa
!!    for single quotes.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!
!!##RESULTS
!!    upper  copy of the input string with all unquoted characters converted
!!           to uppercase
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_upper_quoted
!!     use M_strings, only: upper_quoted
!!     implicit none
!!     character(len=:),allocatable  :: s
!!     s=' ABCDEFG abcdefg "Double-Quoted" ''Single-Quoted'' "with ""&
!!        & Quote" everything else'
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper_quoted(s)
!!        write(*,'(1x,a,*(a:,"+"))') 'upper_quoted(3f) is elemental ==>', &
!!        & upper_quoted(["abc","def","ghi"])
!!     end program demo_upper_quoted
!!
!!    Expected output:
!!
!!     mixed-case input string is .... ABCDEFG abcdefg "Double-Quoted"
!!     'Single-Quoted' "with "" Quote" everything else
!!     upper-case output string is ... ABCDEFG ABCDEFG "Double-Quoted"
!!     'Single-Quoted' "with "" Quote" EVERYTHING ELSE
!!     upper_quoted(3f) is elemental ==>ABC+DEF+GHI
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function upper_quoted(str) result (string)

! ident_21="@(#) M_strings upper_quoted(3f) elemental function converts string to miniscule skipping strings quoted per Fortran syntax rules"

character(len=*), intent(in)   :: str     ! The input string
character(len=len(str))        :: string  ! The output string
logical                        :: toggle
character(len=1)               :: togglechar
integer                        :: irnk
integer                        :: i
character(len=26), parameter   :: large="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
character(len=26), parameter   :: small="abcdefghijklmnopqrstuvwxyz"

   string=str
   toggle = .TRUE.
   do i = 1, len_trim(string)
      if(toggle) then
         if(string(i:i) == '"' .or. string(i:i) == "'") then
            toggle = .not. toggle
            togglechar = string(i:i)
         endif
         irnk = index(small, string(i:i))
         if(irnk > 0) then
            string(i:i) = large(irnk:irnk)
         endif
      else
         if(string(i:i) == togglechar) toggle = .not. toggle
      endif
   enddo
end function upper_quoted
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper(3f) - [M_strings:CASE] changes a string to uppercase
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper(str,begin,end) result (string)
!!
!!     character(*), intent(in)    :: str
!!     integer,optional,intent(in) :: begin,end
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!      upper(string) returns a copy of the input string with all characters
!!      converted in the optionally specified range to uppercase, assuming
!!      ASCII character sets are being used. If no range is specified the
!!      entire string is converted to uppercase.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!    begin  optional starting position in "str" to begin converting to
!!           uppercase
!!    end    optional ending position in "str" to stop converting to
!!           uppercase
!!
!!##RESULTS
!!    upper  copy of the input string with all characters converted to
!!           uppercase over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days of
!!    the mechanical printing press. Individual metal alloy casts of each
!!    needed letter, or punctuation symbol, were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These
!!    metal casts were stored and organized in wooden cases. The more
!!    often needed miniscule letters were placed closer to hand, in the
!!    lower cases of the work bench. The less often needed, capitalized,
!!    majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_upper
!!     use M_strings, only: upper
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s=' ABCDEFG abcdefg '
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper(s)
!!        write(*,*) 'make first character uppercase  ... ',&
!!        & upper('this is a sentence.',1,1)
!!        write(*,'(1x,a,*(a:,"+"))') 'UPPER(3f) is elemental ==>',&
!!        & upper(["abc","def","ghi"])
!!     end program demo_upper
!!
!!    Expected output
!!
!!     mixed-case input string is .... ABCDEFG abcdefg
!!     upper-case output string is ... ABCDEFG ABCDEFG
!!     make first character uppercase  ... This is a sentence.
!!     UPPER(3f) is elemental ==>ABC+DEF+GHI
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
! Timing
!
!    Several different methods have been proposed for changing case.
!    A simple program that copies a large file and converts it to
!    uppercase was timed and compared to a simple copy. This was used
!    to select the default function.
!
! NULL:    83.41user  9.25system 1:37.94elapsed 94%CPU
! upper:  101.44user 10.89system 1:58.36elapsed 94%CPU
! upper2: 105.04user 10.69system 2:04.17elapsed 93%CPU
! upper3: 267.21user 11.69system 4:49.21elapsed 96%CPU
elemental pure function upper(str,begin,end) result (string)

! ident_22="@(#) M_strings upper(3f) returns a trimmed uppercase string"

character(*), intent(in)      :: str                 ! input string to convert to all uppercase
integer, intent(in), optional :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str                                      ! initialize output string to input string
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(ibegin,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range
       select case (str(i:i))
       case ('a':'z')                                ! located miniscule letter
          string(i:i) = char(iachar(str(i:i))+diff)  ! change miniscule letter to majascule
       end select
   enddo

end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lower(3f) - [M_strings:CASE] changes a string to lowercase over
!!    specified range
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function lower(str,begin,end) result (string)
!!
!!     character(*), intent(in) :: str
!!     integer,optional         :: begin, end
!!     character(len(str))      :: string  ! output string
!!
!!##DESCRIPTION
!!      lower(string) returns a copy of the input string with all characters
!!      converted to miniscule over the specified range, assuming ASCII
!!      character sets are being used. If no range is specified the entire
!!      string is converted to miniscule.
!!
!!##OPTIONS
!!    str    string to convert to miniscule
!!    begin  optional starting position in "str" to begin converting to
!!           miniscule
!!    end    optional ending position in "str" to stop converting to
!!           miniscule
!!
!!##RESULTS
!!    lower  copy of the input string with all characters converted to
!!           miniscule over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days of
!!    the mechanical printing press. Individual metal alloy casts of each
!!    needed letter, or punctuation symbol, were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These
!!    metal casts were stored and organized in wooden cases. The more
!!    often needed miniscule letters were placed closer to hand, in the
!!    lower cases of the work bench. The less often needed, capitalized,
!!    majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!       program demo_lower
!!       use M_strings, only: lower
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          s=' ABCDEFG abcdefg '
!!          write(*,*) 'mixed-case input string is ....',s
!!          write(*,*) 'lower-case output string is ...',lower(s)
!!       end program demo_lower
!!
!!    Expected output
!!
!!       mixed-case input string is .... ABCDEFG abcdefg
!!       lower-case output string is ... abcdefg abcdefg
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function lower(str,begin,end) result (string)

! ident_23="@(#) M_strings lower(3f) Changes a string to lowercase over specified range"

character(*), intent(in)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(1,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))-diff)   ! change letter to miniscule
      case default
      end select
   enddo

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    switch(3f) - [M_strings:ARRAY] converts between CHARACTER scalar and
!!    array of single characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function switch(array) result (string)
!!
!!     character(len=1),intent(in) :: array(:)
!!     character(len=SIZE(array))  :: string
!!
!!      or
!!
!!    pure function switch(string) result (array)
!!
!!     character(len=1),intent(in) :: array(:)
!!     character(len=SIZE(array))  :: string
!!
!!##DESCRIPTION
!!    SWITCH(3f): generic function that switches CHARACTER string to an array
!!    of single characters or an array of single characters to a CHARACTER
!!    string. Useful in passing strings to C. New Fortran features may
!!    supersede these routines.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_switch
!!    use M_strings, only : switch, isalpha, islower, nospace
!!    character(len=*),parameter :: &
!!    & dashes='-----------------------------------'
!!    character(len=*),parameter :: string='This is a string'
!!    character(len=1024)        :: line
!!
!!    ! First, examples of standard Fortran features
!!    ! returns array [F,T,T,T,T,T]
!!    write(*,*)['A','=','=','=','=','='].eq.'='
!!    ! this would return T
!!    write(*,*)all(['=','=','=','=','=','='].eq.'=')
!!    ! this would return F
!!    write(*,*)all(['A','=','=','=','=','='].eq.'=')
!!
!!    ! so to test if the string DASHES is all dashes
!!    ! using SWITCH(3f) is
!!    if(all(switch(dashes).eq.'-'))then
!!       write(*,*)'DASHES is all dashes'
!!    endif
!!
!!    ! so to test is a string is all letters
!!    ! isalpha(3f) returns .true. only if character is a letter
!!    ! false because dashes are not a letter
!!    write(*,*) all(isalpha(switch(dashes)))
!!    ! false because of spaces
!!    write(*,*) all(isalpha(switch(string)))
!!    ! true because removed whitespace
!!    write(*,*) all(isalpha(switch(nospace(string))))
!!
!!    ! to see if a string is all uppercase
!!    ! show the string
!!    write(*,*) string
!!    ! converted to character array
!!    write(*,'(1x,*("[",a,"]":))') switch(string)
!!    write(*,'(*(l3))') islower(switch(string))
!!
!!    ! we need a string that is all letters
!!    line=nospace(string)
!!    write(*,*)'LINE=',trim(line)
!!    ! all true except first character
!!    write(*,*) islower(switch(nospace(string)))
!!    ! should be false
!!    write(*,*) all(islower(switch(nospace(string))))
!!    ! should be true
!!    write(*,*) all(islower(switch(nospace(string(2:)))))
!!
!!    end program demo_switch
!!
!!  Expected output
!!
!!     F T T T T T
!!     T
!!     F
!!     DASHES is all dashes
!!     F
!!     F
!!     T
!!     This is a string
!!     [T][h][i][s][ ][i][s][ ][a][ ][s][t][r][i][n][g]
!!      F  T  T  T  F  T  T  F  T  F  T  T  T  T  T  T
!!     LINE=Thisisastring
!!     F T T T T T T T T T T T T
!!     F
!!     T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function a2s(array)  result (string)

! ident_24="@(#) M_strings a2s(3fp) function to copy char array to string"

character(len=1),intent(in) :: array(:)
character(len=SIZE(array))  :: string
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall( i = 1:size(array)) string(i:i) = array(i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  string=transfer(array,string)
end function a2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function s2a(string)  RESULT (array)

! ident_25="@(#) M_strings s2a(3fp) function to copy string(1 Clen(string)) to char array"

character(len=*),intent(in) :: string
character(len=1)            :: array(len(string))
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall(i=1:len(string)) array(i) = string(i:i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  array=transfer(string,array)
end function s2a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2c(3f) - [M_strings:ARRAY] convert character variable to array of
!!      characters with last element set to null
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2c(string)
!!
!!     character(len=*),intent=(in)  :: string
!!     character(len=1),allocatable  :: s2c(:)
!!
!!##DESCRIPTION
!!    Given a character variable convert it to an array of single-character
!!    character variables with the last element set to a null character.
!!    This is generally used to pass character variables to C procedures.
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_s2c
!!     use M_strings, only : s2c
!!     implicit none
!!     character(len=*),parameter   :: string="single string"
!!     character(len=3),allocatable :: array(:)
!!        write(*,*)'INPUT STRING ',trim(string)
!!        ! put one character into each 3-character element of array
!!        array=s2c(string)
!!        ! write array with ASCII Decimal Equivalent below it except show
!!        ! unprintable characters like NULL as "XXX"
!!        write(*,'(1x,*("[",a3,"]":))')&
!!             & merge('XXX',array,iachar(array(:)(1:1)).lt.32)
!!        write(*,'(1x,*("[",i3,"]":))')&
!!             & iachar(array(:)(1:1))
!!     end program demo_s2c
!!
!!   Expected output:
!!
!!    INPUT STRING single string
!!    [s  ][i  ][n  ][g  ][l  ][e  ][   ][s  ][t  ][r  ][i  ][n  ][g  ][XXX]
!!    [115][105][110][103][108][101][ 32][115][116][114][105][110][103][  0]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function s2c(string)  RESULT (array)
use,intrinsic :: ISO_C_BINDING, only : C_CHAR

! ident_26="@(#) M_strings s2c(3f) copy string(1 Clen(string)) to char array with null terminator"

character(len=*),intent(in)     :: string

! This is changing, but currently the most portable way to pass a CHARACTER variable to C is to convert it to an array of
! character variables with length one and add a null character to the end of the array. The s2c(3f) function helps do this.
character(kind=C_CHAR,len=1)    :: array(len_trim(string)+1)
integer                         :: i
   do i = 1,size(array)-1
      array(i) = string(i:i)
   enddo
   array(size(array):)=achar(0)
end function s2c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      c2s(3f) - [M_strings:ARRAY] convert C string pointer to Fortran
!!      character string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function c2s(c_string_pointer) result(f_string)
!!
!!     type(c_ptr), intent(in)       :: c_string_pointer
!!     character(len=:), allocatable :: f_string
!!
!!##DESCRIPTION
!!    Given a C pointer to a character string return a Fortran character
!!    string.
!!
!!##OPTIONS
!!    c_string_pointer  C pointer to convert
!!
!!##RETURNS
!!    f_string          Fortran character variable to return
!!
!!##EXAMPLE
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function c2s(c_string_pointer) result(f_string)
! gets a C string (pointer), and returns the corresponding Fortran string;
! If the C string is null, it returns "NULL", similar to C's "(null)" printed in similar cases:
use, intrinsic :: iso_c_binding, only: c_ptr,c_f_pointer,c_char,c_null_char

! ident_27="@(#) M_strings c2s(3f) copy pointer to C char array till a null is encountered to a Fortran string up to 4096 characters"

integer,parameter                             :: max_length=4096
type(c_ptr), intent(in)                       :: c_string_pointer
character(len=:), allocatable                 :: f_string
character(kind=c_char), dimension(:), pointer :: char_array_pointer => null()
character(len=max_length)                            :: aux_string
integer                                       :: i,length=0

   call c_f_pointer(c_string_pointer,char_array_pointer,[max_length])
   if (.not.associated(char_array_pointer)) then
     allocate(character(len=4)::f_string)
     f_string="NULL"
     return
   endif
   aux_string=" "
   do i=1,max_length
     if (char_array_pointer(i)==c_null_char) then
       length=i-1
       exit
     endif
     aux_string(i:i)=char_array_pointer(i)
   enddo
   allocate(character(len=length)::f_string)
   f_string=aux_string(1:length)

end function c2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      indent(3f) - [M_strings:WHITESPACE] count number of leading spaces
!!      in a string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function indent(line)
!!
!!     integer                        :: indent
!!     character(len=*),intent(in)    :: line
!!
!!##DESCRIPTION
!!    Count number of leading spaces in a CHARACTER variable.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!    program demo_indent
!!    !  test filter to count leading spaces in a character variable
!!    !  might want to call notabs(3f) to expand tab characters
!!    use M_strings, only : indent
!!    implicit none
!!    character(len=1024) :: in
!!    integer             :: ios
!!       READFILE: do
!!          read(*,'(A)',iostat=ios)in
!!          if(ios /= 0) exit READFILE
!!          write(*,'(i3,"",a)')indent(in),trim(in)
!!       enddo READFILE
!!    end program demo_indent
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function indent(line)
implicit none

! ident_28="@(#) M_strings indent(3f) find number of leading spaces in a string"

integer                        :: indent
character(len=*),intent(in)    :: line
integer                        :: i
   indent=0
   NOTSPACE: block
      SCAN: do i=1,len(line)
         if(line(i:i).ne.' ')then
            indent=i-1
            exit NOTSPACE
         endif
      enddo SCAN
      indent=len(line)
   endblock NOTSPACE
end function indent
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    visible(3f) - [M_strings:NONALPHA] expand a string to control and
!!    meta-control representations
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function visible(input) result(output)
!!
!!     character(len=*),intent(in)           :: input
!!     character(len=:),allocatable          :: output
!!
!!##DESCRIPTION
!!     visible(3f) expands characters to commonly used sequences used
!!     to represent the characters as control sequences or meta-control
!!     sequences.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_visible
!!     use M_strings, only : visible
!!     integer :: i
!!        do i=0,255
!!           write(*,'(i0,1x,a)')i,visible(char(i))
!!        enddo
!!     end program demo_visible
!!##BUGS
!!     The expansion is not reversible, as input sequences such as "M-" or
!!     "^a" will look like expanded sequences.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function visible(input) result(output)
character(len=*),intent(in)  :: input
character(len=:),allocatable :: output

! ident_29="@(#) M_strings visible(3f) expand escape sequences in a string to control and meta-control representations"

integer                      :: i
character(len=1)             :: c

character(len=*),parameter :: chars(0:255)= [ &
'^@  ', '^A  ', '^B  ', '^C  ', '^D  ', '^E  ', '^F  ', '^G  ', '^H  ', '^I  ', &
'^J  ', '^K  ', '^L  ', '^M  ', '^N  ', '^O  ', '^P  ', '^Q  ', '^R  ', '^S  ', &
'^T  ', '^U  ', '^V  ', '^W  ', '^X  ', '^Y  ', '^Z  ', '^[  ', '^\  ', '^]  ', &
'^^  ', '^_  ', '    ', '!   ', '"   ', '#   ', '$   ', '%   ', '&   ', '''   ', &
'(   ', ')   ', '*   ', '+   ', ',   ', '-   ', '.   ', '/   ', '0   ', '1   ', &
'2   ', '3   ', '4   ', '5   ', '6   ', '7   ', '8   ', '9   ', ':   ', ';   ', &
'<   ', '=   ', '>   ', '?   ', '@   ', 'A   ', 'B   ', 'C   ', 'D   ', 'E   ', &
'F   ', 'G   ', 'H   ', 'I   ', 'J   ', 'K   ', 'L   ', 'M   ', 'N   ', 'O   ', &
'P   ', 'Q   ', 'R   ', 'S   ', 'T   ', 'U   ', 'V   ', 'W   ', 'X   ', 'Y   ', &
'Z   ', '[   ', '\   ', ']   ', '^   ', '_   ', '`   ', 'a   ', 'b   ', 'c   ', &
'd   ', 'e   ', 'f   ', 'g   ', 'h   ', 'i   ', 'j   ', 'k   ', 'l   ', 'm   ', &
'n   ', 'o   ', 'p   ', 'q   ', 'r   ', 's   ', 't   ', 'u   ', 'v   ', 'w   ', &
'x   ', 'y   ', 'z   ', '{   ', '|   ', '}   ', '~   ', '^?  ', 'M-^@', 'M-^A', &
'M-^B', 'M-^C', 'M-^D', 'M-^E', 'M-^F', 'M-^G', 'M-^H', 'M-^I', 'M-^J', 'M-^K', &
'M-^L', 'M-^M', 'M-^N', 'M-^O', 'M-^P', 'M-^Q', 'M-^R', 'M-^S', 'M-^T', 'M-^U', &
'M-^V', 'M-^W', 'M-^X', 'M-^Y', 'M-^Z', 'M-^[', 'M-^\', 'M-^]', 'M-^^', 'M-^_', &
'M-  ', 'M-! ', 'M-" ', 'M-# ', 'M-$ ', 'M-% ', 'M-& ', 'M-'' ', 'M-( ', 'M-) ', &
'M-* ', 'M-+ ', 'M-, ', 'M-- ', 'M-. ', 'M-/ ', 'M-0 ', 'M-1 ', 'M-2 ', 'M-3 ', &
'M-4 ', 'M-5 ', 'M-6 ', 'M-7 ', 'M-8 ', 'M-9 ', 'M-: ', 'M-; ', 'M-< ', 'M-= ', &
'M-> ', 'M-? ', 'M-@ ', 'M-A ', 'M-B ', 'M-C ', 'M-D ', 'M-E ', 'M-F ', 'M-G ', &
'M-H ', 'M-I ', 'M-J ', 'M-K ', 'M-L ', 'M-M ', 'M-N ', 'M-O ', 'M-P ', 'M-Q ', &
'M-R ', 'M-S ', 'M-T ', 'M-U ', 'M-V ', 'M-W ', 'M-X ', 'M-Y ', 'M-Z ', 'M-[ ', &
'M-\ ', 'M-] ', 'M-^ ', 'M-_ ', 'M-` ', 'M-a ', 'M-b ', 'M-c ', 'M-d ', 'M-e ', &
'M-f ', 'M-g ', 'M-h ', 'M-i ', 'M-j ', 'M-k ', 'M-l ', 'M-m ', 'M-n ', 'M-o ', &
'M-p ', 'M-q ', 'M-r ', 'M-s ', 'M-t ', 'M-u ', 'M-v ', 'M-w ', 'M-x ', 'M-y ', &
'M-z ', 'M-{ ', 'M-| ', 'M-} ', 'M-~ ', 'M-^?']
output=''
do i=1,len(input)
   c=input(i:i)
   if(c.eq.' ')then
      output=output//' '
   else
      output=output//trim(chars(iachar(c)))
   endif
enddo
end function visible
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    expand(3f) - [M_strings:NONALPHA] expand C-like escape sequences
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function expand(line,escape) result(lineout)
!!
!!    character(len=*)                      :: line
!!    character(len=1),intent(in),optional  :: escape
!!    character(len=:),allocatable          :: lineout
!!
!!##DESCRIPTION
!!     EXPAND() expands sequences used to represent commonly used escape
!!     sequences or control characters. By default ...
!!
!!     Escape sequences
!!       \      backslash
!!       a      alert (BEL) -- g is an alias for a
!!       b      backspace
!!       c      suppress further output
!!       e      escape
!!       f      form feed
!!       n      new line
!!       r      carriage return
!!       t      horizontal tab
!!       v      vertical tab
!!       oNNN   byte with octal value NNN (3 digits)
!!       dNNN   byte with decimal value NNN (3 digits)
!!       xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
!!
!!     The default escape character is the backslash, but this may be
!!     changed using the optional parameter ESCAPE.
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_expand
!!     !  test filter to expand escape sequences in input lines
!!     use M_strings, only : expand
!!     character(len=1024) :: line
!!     integer             :: ios
!!        READFILE: block
!!           do
!!              read(*,'(A)',iostat=ios)line
!!              if(ios /= 0) exit READFILE
!!              write(*,'(a)')trim(expand(line))
!!           enddo
!!        endblock READFILE
!!     end program demo_expand
!!
!!    Sample input:
!!
!!      \e[2J
!!      \tABC\tabc
!!      \tA\a
!!      \nONE\nTWO\nTHREE
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function expand(line,escape) result(lineout)
!x!USE ISO_C_BINDING ,ONLY: c_horizontal_tab
implicit none

! ident_30="@(#) M_strings expand(3f) return string with escape sequences expanded"

character(len=*),parameter            :: c_horizontal_tab=char(9)
character(len=*),intent(in)           :: line
character(len=1),intent(in),optional  :: escape ! escape character. Default is backslash
! expand escape sequences found in input string
! Escape sequences
!    %%      escape character           %a     alert (BEL) -- gi is an alias for a
!    %b      backspace                  %c     suppress further output
!    %e      escape                     %E     escape
!    %f      form feed                  %n     new line
!    %r      carriage return            %t     horizontal tab
!    %v      vertical tab
!    %oNNN   byte with octal value NNN (3 digits)
!    %dNNN   byte with decimal value NNN (3 digits)
!    %xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
character(len=1)                      :: esc    ! escape character. Default is %
character(len=:),allocatable          :: lineout
integer                               :: i
integer                               :: lgth
character(len=3)                      :: thr
integer                               :: xxx
integer                               :: ios
   i=0 ! pointer into input

   lgth=len_trim(line)
   lineout=''

   if(lgth.eq.0)return

   if (present(escape))then
      esc=escape
   else
      esc=char(92)
   endif

   EXP: do
      i=i+1
      if(i.gt.lgth)exit
      if(line(i:i).eq.esc)then
         i=i+1
         if(i.gt.lgth)exit
         if(line(i:i).ne.esc)then
            BACKSLASH: select case(line(i:i))
            case('a','A','g','G');lineout=lineout//char(  7) ! %a     alert (BEL)
            case('b','B');lineout=lineout//char(  8)         ! %b     backspace
            case('c','C');exit EXP                           ! %c     suppress further output
            case('d','D')                                    ! %d     Dnnn decimal value
                      thr=line(i+1:)
                   read(thr,'(i3)',iostat=ios)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('e','E');lineout=lineout//char( 27)         ! %e     escape
            case('f','F');lineout=lineout//char( 12)         ! %f     form feed
            case('n','N');lineout=lineout//char( 10)         ! %n     new line
           !case('n','N');lineout=lineout//new_line('A')     ! %n     new line
            case('o','O')
                      thr=line(i+1:)
                   read(thr,'(o3)',iostat=ios)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('r','R');lineout=lineout//char( 13)         ! %r     carriage return
            case('t','T');lineout=lineout//c_horizontal_tab  ! %t     horizontal tab
            case('v','V');lineout=lineout//char( 11)         ! %v     vertical tab
            case('x','X','h','H')                            ! %x     xHH  byte with hexadecimal value HH (1 to 2 digits)
                      thr=line(i+1:)
                   read(thr,'(z2)',iostat=ios)xxx
                      lineout=lineout//char(xxx)
                   i=i+2
            end select BACKSLASH
         else
            lineout=lineout//esc                             ! escape character, defaults to backslash
         endif
      else
         lineout=lineout//line(i:i)
      endif
      if(i.ge.lgth)exit EXP
   enddo EXP

end function expand
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notabs(3f) - [M_strings:NONALPHA] expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine notabs(INSTR,OUTSTR,lgth)
!!
!!     character(len=*),intent=(in)  :: INSTR
!!     character(len=*),intent=(out) :: OUTSTR
!!     integer,intent=(out)          :: lgth
!!
!!##DESCRIPTION
!!     NOTABS() converts tabs in INSTR to spaces in OUTSTR while maintaining
!!     columns. It assumes a tab is set every 8 characters. Trailing spaces
!!     are removed.
!!
!!     In addition, trailing carriage returns and line feeds are removed
!!     (they are usually a problem created by going to and from MSWindows).
!!
!!     What are some reasons for removing tab characters from an input line?
!!     Some Fortran compilers have problems with tabs, as tabs are not
!!     part of the Fortran character set. Some editors and printers will
!!     have problems with tabs. It is often useful to expand tabs in input
!!     files to simplify further processing such as tokenizing an input line.
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RESULTS
!!     outstr    Output string with tabs expanded. Assumed to be of sufficient
!!               length
!!     lgth      Significant length of returned string
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_notabs
!!
!!    !  test filter to remove tabs and trailing white space from input
!!    !  on files up to 1024 characters wide
!!    use M_strings, only : notabs
!!    character(len=1024) :: in,out
!!    integer             :: ios,iout
!!       do
!!          read(*,'(A)',iostat=ios)in
!!          if(ios /= 0) exit
!!          call notabs(in,out,iout)
!!          write(*,'(a)')out(:iout)
!!       enddo
!!    end program demo_notabs
!!
!!##SEE ALSO
!!     GNU/Unix commands expand(1) and unexpand(1)
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental impure subroutine notabs(instr,outstr,lgth)

! ident_31="@(#) M_strings notabs(3f) convert tabs to spaces while maintaining columns remove CRLF chars"

character(len=*),intent(in)   :: instr        ! input line to scan for tab characters
character(len=*),intent(out)  :: outstr       ! tab-expanded version of INSTR produced
integer,intent(out)           :: lgth         ! column position of last character put into output string
                                              ! that is, lgth holds the position of the last non-blank character in OUTSTR
!===================================================================================================================================
integer,parameter             :: tabsize=8    ! assume a tab stop is set every 8th column
integer                       :: ipos         ! position in OUTSTR to put next character of INSTR
integer                       :: lenin        ! length of input string trimmed of trailing spaces
integer                       :: lenout       ! number of characters output string can hold
integer                       :: istep        ! counter that advances thru input string INSTR one character at a time
character(len=1)              :: c            ! character in input line being processed
integer                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested
!===================================================================================================================================
   ipos=1                                     ! where to put next character in output string OUTSTR
   lenin=len_trim(instr( 1:len(instr) ))      ! length of INSTR trimmed of trailing spaces
   lenout=len(outstr)                         ! number of characters output string OUTSTR can hold
   outstr=" "                                 ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters
!===================================================================================================================================
      SCAN_LINE: do istep=1,lenin             ! look through input string one character at a time
         c=instr(istep:istep)                 ! get next character
         iade=iachar(c)                       ! get ADE of the character
         EXPAND_TABS : select case (iade)     ! take different actions depending on which character was found
         case(9)                              ! test if character is a tab and move pointer out to appropriate column
            ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))
         case(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files
            ipos=ipos+1
         case default                         ! c is anything else other than a tab,newline,or return  insert it in output string
            if(ipos > lenout)then
               call journal("*notabs* output string overflow")
               exit
            else
               outstr(ipos:ipos)=c
               ipos=ipos+1
            endif
         end select EXPAND_TABS
      enddo SCAN_LINE
!===================================================================================================================================
      ipos=min(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far
      lgth=len_trim(outstr(:ipos))            ! trim trailing spaces
!===================================================================================================================================
end subroutine notabs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dilate(3f) - [M_strings:NONALPHA] expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dilate(INSTR) result(OUTSTR)
!!
!!     character(len=*),intent=(in)  :: INSTR
!!     character(len=:),allocatable  :: OUTSTR
!!
!!##DESCRIPTION
!!     dilate() converts tabs in INSTR to spaces in OUTSTR.  It assumes a
!!     tab is set every 8 characters. Trailing spaces are removed.
!!
!!     In addition, trailing carriage returns and line feeds are removed
!!     (they are usually a problem created by going to and from MSWindows).
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RESULTS
!!     outstr    Output string with tabs expanded.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_dilate
!!
!!    !  test filter to remove tabs and trailing white space from input
!!    !  on files up to 1024 characters wide
!!    use M_strings, only : dilate
!!    implicit none
!!    character(len=:),allocatable :: in
!!    integer                      :: i
!!       in='  this is my string  '
!!       ! change spaces to tabs to make a sample input
!!       do i=1,len(in)
!!          if(in(i:i).eq.' ')in(i:i)=char(9)
!!       enddo
!!       write(*,'(a)')in,dilate(in)
!!    end program demo_dilate
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
function dilate(INSTR) result(OUTSTR)

! ident_32="@(#) M_strings dilate(3f) convert tabs to spaces and trims line removing CRLF chars"

CHARACTER(LEN=*),INTENT(IN)   :: instr        ! input line to scan for tab characters
CHARACTER(LEN=:),allocatable  :: outstr       ! tab-expanded version of INSTR produced
integer                       :: i
integer                       :: icount
integer                       :: lgth
   icount=0
   do i=1,len(instr)
      if(instr(i:i).eq.char(9))icount=icount+1
   enddo
   allocate(character(len=(len(instr)+8*icount)) :: outstr)
   call notabs(instr,outstr,lgth)
   outstr=outstr(:lgth)
!===================================================================================================================================
END function dilate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    adjustc(3f) - [M_strings:WHITESPACE] center text
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   pure function adjustc(string[,length])
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in),optional  :: length
!!    character(len=:),allocatable :: adjustc
!!
!!##DESCRIPTION
!!     Centers input text in a string of the length specified. Returns a
!!     string of length LENGTH if LENGTH is present. Otherwise returns a
!!     string of the length of the input string.
!!
!!##OPTIONS
!!     string  input string to trim and center
!!     length  line length to center text in, optional.
!!
!!##RETURNS
!!     adjustc  centered output string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_adjustc
!!    use M_strings, only : adjustc
!!    !  using length of the input string
!!       write(*,'(a)')       '================================'
!!       write(*,'(a)')adjustc('centered string                 ')
!!       write(*,'(a)')adjustc('                 centered string')
!!       write(*,'(a)')adjustc('  centered string               ')
!!    !  using explicit output string length
!!       write(*,'(a)')repeat('=',50)
!!       write(*,'(a)')adjustc('this is a centered string',50)
!!       write(*,'(a)')repeat('=',50)
!!    end program demo_adjustc
!!
!!   Expected output
!!
!!    ================================
!!            centered string
!!            centered string
!!            centered string
!!    ==================================================
!!                this is a centered string
!!    ==================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function adjustc(string,length)

! ident_33="@(#) M_strings adjustc(3f) center text"

!>
!! PROCEDURE   adjustc(3f)
!! DESCRIPTION center text using implicit or explicit length
!!##VERSION     2.0, 20160711
!! AUTHOR      John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: string         ! input string to trim and center
integer,intent(in),optional  :: length         ! line length to center text in
character(len=:),allocatable :: adjustc        ! output string
integer                      :: inlen
integer                      :: ileft          ! left edge of string if it is centered
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(length))then                     ! optional length
      inlen=length                             ! length will be requested length
      if(inlen.le.0)then                       ! bad input length
         inlen=len(string)                     ! could not use input value, fall back to length of input string
      endif
   else                                        ! output length was not explicitly specified, use input string length
      inlen=len(string)
   endif
   allocate(character(len=inlen):: adjustc)    ! create output at requested length
   adjustc(1:inlen)=' '                        ! initialize output string to all blanks
!-----------------------------------------------------------------------------------------------------------------------------------
   ileft =(inlen-len_trim(adjustl(string)))/2  ! find starting point to start input string to center it
   if(ileft.gt.0)then                          ! if string will fit centered in output
      adjustc(ileft+1:inlen)=adjustl(string)   ! center the input text in the output string
   else                                        ! input string will not fit centered in output string
      adjustc(1:inlen)=adjustl(string)         ! copy as much of input to output as can
   endif
end function adjustc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from
!!    input string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function nospace(str) - remove all whitespace from input string
!!
!!     character(len=*),intent(in)          :: str
!!     character(len=:),allocatable         :: nospace
!!
!!##DESCRIPTION
!!    nospace(3f) removes space, tab, carriage return, new line, vertical
!!    tab, formfeed and null characters (called "whitespace"). The output
!!    is returned trimmed.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_nospace
!!     use M_strings, only: nospace
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s='  This     is      a     test  '
!!        write(*,*) 'original input string is ....',s
!!        write(*,*) 'processed output string is ...',nospace(s)
!!        if(nospace(s).eq.'Thisisatest')then
!!           write(*,*)'nospace test passed'
!!        else
!!           write(*,*)'nospace test error'
!!        endif
!!     end program demo_nospace
!!
!!   Expected output
!!
!!     original input string is ....  This     is      a     test
!!     processed output string is ...Thisisatest
!!     nospace test passed
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function nospace(line)

! ident_34="@(#) M_strings nospace(3f) remove all whitespace from input string"

character(len=*),intent(in)    ::  line             ! remove whitespace from this string and return it
character(len=:),allocatable   ::  nospace          ! returned string
integer                        ::  ipos             ! position to place next output character at
integer                        ::  i                ! counter to increment from beginning to end of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(nospace,mold=line)                      ! initially make output line length of input line
   nospace(:len_trim(nospace))=' '
   ipos=0
   do i=1,len_trim(line)                            ! increment from first to last character of the input line
      if ( isspace( line(i:i) ) ) cycle             ! if a blank is encountered skip it
      ipos=ipos+1                                   ! increment count of non-blank characters found
      nospace(ipos:ipos)=line(i:i)                  ! store non-blank character in output
   enddo
   nospace=trim(nospace)                            ! blank out unpacked part of line
end function nospace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    stretch(3f) - [M_strings:LENGTH] return string padded to at least
!!    specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function stretch(str,length,pattern,suffix) result(strout)
!!
!!     character(len=*),intent(in)         :: str
!!     integer,intent(in)                  :: length
!!     character(len=*)intent(in),optional :: pattern
!!     character(len=*)intent(in),optional :: suffix
!!     character(len=:),allocatable        :: strout
!!
!!##DESCRIPTION
!!    stretch(3f) pads a string with spaces to at least the specified
!!    length. If the trimmed input string is longer than the requested
!!    length the original string is returned trimmed of trailing spaces.
!!
!!##OPTIONS
!!    str      the input string to return trimmed, but then padded to
!!             the specified length if shorter than length
!!    length   The minimum string length to return
!!    pattern  optional string to use as padding. Defaults to a space.
!!    suffix   optional string to append to output string
!!
!!##RETURNS
!!    strout  The input string padded to the requested length or
!!            the trimmed input string if the input string is
!!            longer than the requested length.
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!   program demo_stretch
!!    use M_strings, only : stretch
!!    implicit none
!!    character(len=10)            :: string='abcdefghij'
!!    character(len=:),allocatable :: answer
!!    integer                      :: i
!!       answer=stretch(string,5)
!!       write(*,'("[",a,"]")') answer
!!       answer=stretch(string,20)
!!       write(*,'("[",a,"]")') answer
!!       i=30
!!       write(*,*)
!!       write(*,'(1x,a,i0)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,'(1x,a,i7)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,*) &
!!        & stretch('CHAPTER 1 : The beginning ',i,suffix=': '), 1
!!       write(*,*) &
!!        & stretch('CHAPTER 2 : The end ',i,suffix=': '),1234
!!       write(*,*) &
!!        & stretch('APPENDIX ',i,suffix=': '),           1235
!!   end program demo_stretch
!!
!!   Results:
!!
!!    [abcdefghij]
!!    [abcdefghij          ]
!!
!!     CHAPTER 1 : The beginning ....1
!!     CHAPTER 2 : The end ..........1234
!!     APPENDIX .....................1235
!!
!!     CHAPTER 1 : The beginning ....      1
!!     CHAPTER 2 : The end ..........   1234
!!     APPENDIX .....................   1235
!!
!!     CHAPTER 1 : The beginning     :            1
!!     CHAPTER 2 : The end           :         1234
!!     APPENDIX                      :         1235
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function stretch(line,length,pattern,suffix) result(strout)

! ident_35="@(#) M_strings stretch(3f) return string padded to at least specified length"

character(len=*),intent(in)                  :: line
integer,intent(in)                           :: length
character(len=*),intent(in),optional         :: pattern
character(len=*),intent(in),optional         :: suffix
!-!character(len=max(length,len(trim(line)))) :: strout
character(len=:),allocatable                 :: strout
   if(present(pattern))then
      strout=atleast(line,length,pattern)
   else
      strout=atleast(line,length)
   endif
   if(present(suffix))then
      strout=strout//suffix
   endif
end function stretch
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   atleast(3f) - [M_strings:LENGTH] return string padded to at least
!!   specified length
!!   (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   function atleast(str,length,pattern) result(strout)
!!
!!    character(len=*)                           :: str
!!    integer,intent(in)                         :: length
!!    character(len=max(length,len(trim(line)))) ::  strout
!!    character(len=*),optional                  ::  pattern
!!
!!##DESCRIPTION
!!   atleast(3f) pads a string with spaces to at least the specified
!!   length. If the trimmed input string is longer than the requested
!!   length the trimmed string is returned.
!!
!!##OPTIONS
!!   str      the input string to return trimmed, but then padded to
!!            the specified length if shorter than length
!!   length   The minimum string length to return
!!   pattern  optional string to use as padding. Defaults to a space.
!!
!!##RETURNS
!!   strout  The input string padded to the requested length or
!!           the trimmed input string if the input string is
!!           longer than the requested length.
!!
!!##EXAMPLE
!!
!!  Sample Program:
!!
!!    program demo_atleast
!!     use M_strings, only : atleast
!!     implicit none
!!     character(len=10)            :: string='abcdefghij'
!!     character(len=:),allocatable :: answer
!!     integer                      :: i
!!        answer=atleast(string,5)
!!        write(*,'("[",a,"]")') answer
!!        answer=atleast(string,20)
!!        write(*,'("[",a,"]")') answer
!!        i=30
!!        write(*,*)
!!        write(*,'(1x,a,1x,i0)') &
!!         & atleast('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & atleast('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & atleast('APPENDIX ',i,'.'),                  1235
!!        write(*,*)
!!        write(*,'(1x,a,i7)') &
!!         & atleast('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & atleast('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & atleast('APPENDIX ',i,'.'),                  1235
!!    end program demo_atleast
!!
!!  Results:
!!
!!    [abcdefghij]
!!    [abcdefghij          ]
!!
!!     CHAPTER 1 : The beginning .... 1
!!     CHAPTER 2 : The end .......... 1234
!!     APPENDIX ..................... 1235
!!
!!     CHAPTER 1 : The beginning ....      1
!!     CHAPTER 2 : The end ..........   1234
!!     APPENDIX .....................   1235
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function atleast(line,length,pattern) result(strout)

! ident_36="@(#) M_strings atleast(3f) return string padded to at least specified length"

character(len=*),intent(in)                :: line
integer,intent(in)                         :: length
character(len=*),intent(in),optional       :: pattern
character(len=max(length,len(trim(line)))) :: strout
if(present(pattern))then
   strout=line//repeat(pattern,len(strout)/len(pattern)+1)
else
   strout=line
endif
end function atleast
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lenset(3f) - [M_strings:LENGTH] return string trimmed or padded to
!!                 specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lenset(str,length) result(strout)
!!
!!     character(len=*)                     :: str
!!     character(len=length)                :: strout
!!     integer,intent(in)                   :: length
!!
!!##DESCRIPTION
!!    lenset(3f) truncates a string or pads it with spaces to the specified
!!    length.
!!
!!##OPTIONS
!!    str     input string
!!    length  output string length
!!
!!##RESULTS
!!    strout  output string
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!     program demo_lenset
!!      use M_strings, only : lenset
!!      implicit none
!!      character(len=10)            :: string='abcdefghij'
!!      character(len=:),allocatable :: answer
!!         answer=lenset(string,5)
!!         write(*,'("[",a,"]")') answer
!!         answer=lenset(string,20)
!!         write(*,'("[",a,"]")') answer
!!     end program demo_lenset
!!
!!    Expected output:
!!
!!     [abcde]
!!     [abcdefghij          ]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lenset(line,length) result(strout)

! ident_37="@(#) M_strings lenset(3f) return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    merge_str(3f) - [M_strings:LENGTH] pads strings to same length and
!!    then calls MERGE(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function merge_str(str1,str2,expr) result(strout)
!!
!!     character(len=*),intent(in),optional :: str1
!!     character(len=*),intent(in),optional :: str2
!!     logical,intent(in)              :: expr
!!     character(len=:),allocatable    :: strout
!!
!!##DESCRIPTION
!!    merge_str(3f) pads the shorter of str1 and str2 to the longest length
!!    of str1 and str2 and then calls MERGE(padded_str1,padded_str2,expr).
!!    It trims trailing spaces off the result and returns the trimmed
!!    string. This makes it easier to call MERGE(3f) with strings, as
!!    MERGE(3f) requires the strings to be the same length.
!!
!!    NOTE: STR1 and STR2 are always required even though declared optional.
!!          this is so the call "STR_MERGE(A,B,present(A))" is a valid call.
!!          The parameters STR1 and STR2 when they are optional parameters
!!          can be passed to a procedure if the options are optional on the
!!          called procedure.
!!
!!##OPTIONS
!!    STR1    string to return if the logical expression EXPR is true
!!    STR2    string to return if the logical expression EXPR is false
!!    EXPR    logical expression to evaluate to determine whether to return
!!            STR1 when true, and STR2 when false.
!!##RESULT
!!     MERGE_STR  a trimmed string is returned that is otherwise the value
!!                of STR1 or STR2, depending on the logical expression EXPR.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_merge_str
!!     use M_strings, only : merge_str
!!     implicit none
!!     character(len=:), allocatable :: answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10.eq.10)
!!        write(*,'("[",a,"]")') answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10.ne.10)
!!        write(*,'("[",a,"]")') answer
!!     end program demo_merge_str
!!
!!   Expected output
!!
!!     [first string]
!!     [second string is longer]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

! ident_38="@(#) M_strings merge_str(3f) pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in),optional :: str1
character(len=*),intent(in),optional :: str2
character(len=:),allocatable         :: str1_local
character(len=:),allocatable         :: str2_local
logical,intent(in)                   :: expr
character(len=:),allocatable         :: strout
integer                              :: big
   if(present(str2))then
      str2_local=str2
   else
      str2_local=''
   endif
   if(present(str1))then
      str1_local=str1
   else
      str1_local=''
   endif
   big=max(len(str1_local),len(str2_local))
   ! note: perhaps it would be better to warn or fail if an optional value that is not present is returned, instead of returning ''
   strout=trim(merge(lenset(str1_local,big),lenset(str2_local,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    squeeze(3f) - [M_strings:EDITING] delete adjacent duplicate occurrences
!!    of a character from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function squeeze(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    squeeze(3f) reduces adjacent duplicates of the specified character to
!!    a single character
!!
!!##OPTIONS
!!    STR     input string in which to reduce adjacent duplicate characters
!!            to a single character
!!    CHAR    The character to remove adjacent duplicates of
!!
!!##RETURNS
!!    OUTSTR  string with all contiguous adjacent occurrences of CHAR removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_squeeze
!!    use M_strings, only : squeeze
!!    implicit none
!!    character(len=:),allocatable :: strings(:)
!!
!!    strings=[ character(len=72) :: &
!!    '', &
!!    '"If I were two-faced, would I be wearing this one?" --- Abraham Lincoln',  &
!!    '..1111111111111111111111111111111111111111111111111111111111111117777888', &
!!    'I never give ''em hell, I just tell the truth, and they think it''s hell.',&
!!    '                                                    --- Harry S Truman'    &
!!    ]
!!       call printme( trim(strings(1)), ' ' )
!!       call printme( strings(2:4),     ['-','7','.'] )
!!       call printme( strings(5),       [' ','-','r'] )
!!    contains
!!    impure elemental subroutine printme(str,chr)
!!    character(len=*),intent(in) :: str
!!    character(len=1),intent(in) :: chr
!!    character(len=:),allocatable :: answer
!!       write(*,'(a)')repeat('=',11)
!!       write(*,'("IN:   <<<",g0,">>>")')str
!!       answer=squeeze(str,chr)
!!       write(*,'("OUT:  <<<",g0,">>>")')answer
!!       write(*,'("LENS: ",*(g0,1x))')"from",len(str),"to",len(answer), &
!!               & "for a change of",len(str)-len(answer)
!!       write(*,'("CHAR: ",g0)')chr
!!    end subroutine printme
!!    end program demo_squeeze
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function squeeze(str,charp) result (outstr)

character(len=*),intent(in)  :: str
character(len=1),intent(in)  :: charp
character(len=:),allocatable :: outstr
character(len=1)             :: ch, last_one
integer                      :: i, pio ! position in output

   outstr=repeat(' ',len(str))      ! start with a string big enough to hold any output
   if(len(outstr)==0)return         ! handle edge condition
   last_one=str(1:1)                ! since at least this long start output with first character
   outstr(1:1)=last_one
   pio=1

   do i=2,len(str)
      ch=str(i:i)
      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) ! decide whether to advance before saving
      outstr(pio:pio)=ch  ! store new one or overlay the duplcation
      last_one=ch
   enddo

   outstr=outstr(:pio)              ! trim the output string to just what was set
end function squeeze
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace
!!    to a single character (or nothing)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function compact(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    COMPACT(3f) converts multiple spaces, tabs and control characters
!!    (called "whitespace") to a single character or nothing. Leading
!!    whitespace is removed.
!!
!!##OPTIONS
!!    STR     input string to reduce or remove whitespace from
!!    CHAR    By default the character that replaces adjacent
!!            whitespace is a space. If the optional CHAR parameter is supplied
!!            it will be used to replace the whitespace. If a null character is
!!            supplied for CHAR whitespace is removed.
!!
!!##RETURNS
!!    OUTSTR  string of same length as input string but with all contiguous
!!            whitespace reduced to a single space and leading whitespace
!!            removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_compact
!!     use M_strings, only : compact
!!     implicit none
!!     ! produces 'This is a test               '
!!     write(*,*)compact('  This     is      a     test  ')
!!     ! produces 'Thisisatest                  '
!!     write(*,*)compact('  This     is      a     test  ',char='')
!!     ! produces 'This:is:a:test               '
!!     write(*,*)compact('  This     is      a     test  ',char=':')
!!     ! note CHAR is used to replace the whitespace, but if CHAR is
!!     ! in the original string it is just copied
!!     write(*,*)compact('A  AA    A   AAAAA',char='A')
!!     ! produces (original A characters are left as-is) 'AAAAAAAAAAAA'
!!     ! not 'A'
!!    end program demo_compact
!!
!!    Expected output
!!
!!     >This is a test
!!     >Thisisatest
!!     >This:is:a:test
!!     >AAAAAAAAAAAA
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!elemental pure function compact(str,char) result (outstr)
function compact(str,char) result (outstr)

! ident_39="@(#) M_strings compact(3f) Converts white-space to single spaces; removes leading spaces"

character(len=*),intent(in)          :: str
character(len=*),intent(in),optional :: char
character(len=len(str))              :: outstr
character(len=1)                     :: ch
integer                              :: i
integer                              :: position_in_output
logical                              :: last_was_space
character(len=1)                     :: char_p
logical                              :: nospace
if(present(char))then
   char_p=char
   if(len(char).eq.0)then
      nospace=.true.
   else
      nospace=.false.
   endif
else
   char_p=' '
   nospace=.false.
endif
   outstr=' '
   last_was_space=.false.
   position_in_output=0

   IFSPACE: do i=1,len_trim(str)
     ch=str(i:i)
     select case(iachar(ch))
       case(0:32,127)                                         ! space or tab character or control character
         if(position_in_output.eq.0)then                      ! still at beginning so ignore leading whitespace
            cycle IFSPACE
         elseif(.not.last_was_space) then                     ! if have not already put out a space output one
           if(.not.nospace)then
              position_in_output=position_in_output+1
              outstr(position_in_output:position_in_output)=char_p
           endif
         endif
         last_was_space=.true.
       case(:-1,33:126,128:)                                  ! not a space, quote, or control character so copy it
         position_in_output=position_in_output+1
         outstr(position_in_output:position_in_output)=ch
         last_was_space=.false.
     end select
   enddo IFSPACE

end function compact
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     noesc(3f) - [M_strings:NONALPHA] convert non-printable characters
!!     to a space
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental function noesc(INSTR)
!!
!!     character(len=*),intent(in) :: INSTR
!!     character(len=len(instr))   :: noesc
!!
!!##DESCRIPTION
!!      Convert non-printable characters to a space.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_noesc
!!
!!     use M_strings, only : noesc
!!     implicit none
!!     character(len=128) :: ascii
!!     character(len=128) :: cleared
!!     integer            :: i
!!     ! fill variable with base ASCII character set
!!     do i=1,128
!!        ascii(i:i)=char(i-1)
!!     enddo
!!     cleared=noesc(ascii)
!!     write(*,*)'characters and their ADE (ASCII Decimal Equivalent)'
!!     call ade(ascii)
!!     write(*,*)'Cleared of non-printable characters'
!!     call ade(cleared)
!!     write(*,*)'Cleared string:'
!!     write(*,*)cleared
!!     contains
!!       subroutine ade(string)
!!       implicit none
!!       ! the string to print
!!       character(len=*),intent(in) :: string
!!       ! number of characters in string to print
!!       integer :: lgth
!!       ! counter used to step thru string
!!       integer :: i
!!          ! get trimmed length of input string
!!          lgth=len_trim(string(:len(string)))
!!
!!          ! replace lower unprintable characters with spaces
!!          write(*,101)(merge(string(i:i),' ',&
!!          & iachar(string(i:i)).ge.32        &
!!          & .and.                            &
!!          & iachar(string(i:i)).le.126)      &
!!          & ,i=1,lgth)
!!
!!          ! print ADE value of character underneath it
!!          write(*,202)     (iachar(string(i:i))/100,    i=1,lgth)
!!          write(*,202)(mod( iachar(string(i:i)),100)/10,i=1,lgth)
!!          write(*,202)(mod((iachar(string(i:i))),10),   i=1,lgth)
!!       ! format for printing string characters
!!       101   format(*(a1:))
!!       ! format for printing ADE values
!!       202   format(*(i1:))
!!       end subroutine ade
!!     end program demo_noesc
!!
!!    Expected output
!!
!!    The string is printed with the ADE value vertically beneath.
!!    The original string has all the ADEs from 000 to 127. After
!!    NOESC(3f) is called on the string all the "non-printable"
!!    characters are replaced with a space (ADE of 032).
!!
!!   characters and their ADE (ASCII Decimal Equivalent)
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    0000000000000000000000000000000000000000001111111111111111111111111111
!!    >00000000001111111111222222222233333333334444444444555555555566666666
!!    667777777777888888888899999999990000000000111111111122222222
!!    >012345678901234567890123456789012345678901234567890123456789012345678
!!    90123456789012345678901234567890123456789012345678901234567
!!
!!   Cleared of non-printable characters
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    000000000000000000000000000000000000000000111111111111111111111111111
!!    >3333333333333333333333333333333333333333444444444455555555
!!    556666666666777777777788888888889999999999000000000011111111112222222
!!    >2222222222222222222222222222222223456789012345678901234567
!!    890123456789012345678901234567890123456789012345678901234567890123456
!!
!!   Cleared string:
!!
!!    >                                  !"#$%&'()*+,-./0123456789:;<=>?@
!!    ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function noesc(INSTR)

! ident_40="@(#) M_strings noesc(3f) convert non-printable characters to a space"

character(len=*),intent(in) :: INSTR      ! string that might contain nonprintable characters
character(len=len(instr))   :: noesc
integer                     :: ic,i10
!-----------------------------------------------------------------------------------------------------------------------------------
   noesc=''                               ! initialize output string
   do i10=1,len_trim(INSTR(1:len(INSTR)))
      ic=iachar(INSTR(i10:i10))
      if(ic.le.31.or.ic.eq.127)then       ! find characters with ADE of 0-31, 127
         noesc(I10:I10)=' '               ! replace non-printable characters with a space
      else
         noesc(I10:I10)=INSTR(i10:i10)    ! copy other characters as-is from input string to output string
      endif
   enddo
end function noesc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_value(3f) - [M_strings:NUMERIC] subroutine returns numeric
!!      value from string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine string_to_value(chars,valu,ierr)
!!
!!     character(len=*),intent(in)              :: chars   ! input string
!!     integer|real|doubleprecision,intent(out) :: valu
!!     integer,intent(out)                      :: ierr
!!
!!##DESCRIPTION
!!    Returns a numeric value from a numeric character string.
!!
!!    Works with any g-format input, including integer, real, and
!!    exponential. If the input string begins with "B", "Z", or "O"
!!    and otherwise represents a positive whole number it is assumed to
!!    be a binary, hexadecimal, or octal value. If the string contains
!!    commas they are removed. If the string is of the form NN:MMM... or
!!    NN#MMM then NN is assumed to be the base of the whole number.
!!
!!    If an error occurs in the READ, IOSTAT is returned in IERR and
!!    value is set to zero. if no error occurs, IERR=0.
!!
!!##OPTIONS
!!       CHARS  input string to read numeric value from
!!
!!##RETURNS
!!    VALU   numeric value returned. May be INTEGER, REAL, or
!!              DOUBLEPRECISION.
!!    IERR   error flag (0 == no error)
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_string_to_value
!!     use M_strings, only: string_to_value
!!     implicit none
!!     real :: value
!!     integer :: ierr
!!     character(len=80) :: string
!!        string=' -40.5e-2 '
!!        call string_to_value(string,value,ierr)
!!        write(*,*) 'value of string ['//trim(string)//'] is ',value
!!    end program demo_string_to_value
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine a2r(chars,valu,ierr)

! ident_41="@(#) M_strings a2r(3fp) subroutine returns real value from string"

character(len=*),intent(in) :: chars                      ! input string
real,intent(out)            :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(ierr.eq.0)then
      if(valu8.le.huge(valu))then
         valu=real(valu8)
      else
         call journal('sc','*a2r*','- value too large',valu8,'>',huge(valu))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2r
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2i(chars,valu,ierr)

! ident_42="@(#) M_strings a2i(3fp) subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8.le.huge(valu))then
      if(valu8.le.huge(valu))then
         valu=int(valu8)
      else
         call journal('sc','*a2i*','- value too large',valu8,'>',huge(valu))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

! ident_43="@(#) M_strings a2d(3fp) subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o works with any g-format input, including integer, real, and exponential.
!  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!    IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=unquote(chars)
   msg=''
   if(len(local_chars).eq.0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd.ne.0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr.ne.0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars.ne.'eod')then                           ! print warning message except for special value "eod"
         call journal('sc','*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(msg.ne.'')then
            call journal('sc','*a2d* - ['//trim(msg)//']')
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    s2v(3f) - [M_strings:NUMERIC] function returns doubleprecision
!!    numeric value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2v(string[,ierr][,onerr])
!!
!!     character(len=*)             :: string
!!     doubleprecision              :: s2v
!!     integer,intent(out),optional :: ierr
!!     class(*),intent(in),optional :: onerr
!!
!!##DESCRIPTION
!!    This function converts a string to a DOUBLEPRECISION numeric value.
!!
!!    The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended
!!    to take CHARACTER variables. The KIND= keyword is not supported
!!    on the extensions.
!!
!!##OPTIONS
!!
!!     string   holds string assumed to represent a numeric value
!!     ierr     If an error occurs the program is stopped if the optional
!!              parameter IERR is not present. If IERR returns a non-zero
!!              value an error occurred.
!!     onerr    The value to return on error. A value of NaN is
!!              returned on error by default.
!!
!!##RETURNS
!!     s2v      numeric value read from string
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_s2v
!!
!!     use M_strings, only: s2v, int, real, dble
!!     implicit none
!!     character(len=8)              :: s=' 10.345 '
!!     integer                       :: i
!!     character(len=14),allocatable :: strings(:)
!!     doubleprecision               :: dv
!!     integer                       :: errnum
!!
!!     ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!     strings=[&
!!     &' 10.345       ',&
!!     &'+10           ',&
!!     &'    -3        ',&
!!     &'    -4.94e-2  ',&
!!     &'0.1           ',&
!!     &'12345.678910d0',&
!!     &'              ',& ! Note: will return zero without an error message
!!     &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!     &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!     ! a numeric value is returned,
!!     ! so it can be used in numeric expression
!!     write(*,*) '1/2 value of string is ',s2v(s)/2.0d0
!!     write(*,*)
!!     write(*,*)' STRING            VALUE                    ERROR_NUMBER'
!!     do i=1,size(strings)
!!        ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement,
!!        ! as it does I/O when errors occur, so called on a separate line
!!        dv=s2v(strings(i),errnum)
!!        write(*,*) strings(i)//'=',dv,errnum
!!     enddo
!!     write(*,*)"Extended intrinsics"
!!     write(*,*)'given inputs:',s,strings(:8)
!!     write(*,*)'INT(3f):',int(s),int(strings(:8))
!!     write(*,*)'REAL(3f):',real(s),real(strings(:8))
!!     write(*,*)'DBLE(3f):',dble(s),dble(strings(:8))
!!     write(*,*)"That's all folks!"
!!
!!     end program demo_s2v
!!
!!    Expected output
!!
!!     >1/2 value of string is    5.1725000000000003
!!     >
!!     > STRING            VALUE                    ERROR_NUMBER
!!     > 10.345       =   10.345000000000001                0
!!     >+10           =   10.000000000000000                0
!!     >    -3        =  -3.0000000000000000                0
!!     >    -4.94e-2  =  -4.9399999999999999E-002           0
!!     >0.1           =  0.10000000000000001                0
!!     >12345.678910d0=   12345.678910000001                0
!!     >              =   0.0000000000000000                0
!!     >1 2 1 2 1 . 0 =   12121.000000000000                0
!!     >*a2d* - cannot produce number from string [WHAT?]
!!     >*a2d* - [Bad value during floating point read]
!!     >WHAT?         =   0.0000000000000000             5010
!!     >Extended intrinsics
!!     >given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1
!!     12345.678910d0 1 2 1 2 1 . 0
!!     >INT(3f): 10 10 10 -3 0 0 12345 0 12121
!!     >REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000
!!     -4.94000018E-02
!!     >          0.100000001 12345.6787 0.00000000 12121.0000
!!     >DBLE(3f): 10.345000000000001 10.345000000000001
!!     10.000000000000000
!!     >          -3.0000000000000000 -4.9399999999999999E-002
!!     0.10000000000000001
!!     >          12345.678910000001 0.0000000000000000
!!     12121.000000000000
!!     >That's all folks!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!!##PROCEDURE:
!! DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs
!!##VERSION:     2.0, 20160704
!! AUTHOR:      John S. Urban
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

! ident_44="@(#) M_strings s2v(3f) returns doubleprecision number from string;zero if error occurs"

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local.ne.0)then
      write(*,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!===================================================================================================================================
doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!===================================================================================================================================
real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
!===================================================================================================================================
integer function int_s2v(chars)
character(len=*),intent(in) :: chars
   int_s2v=int(s2v(chars))
end function int_s2v
!===================================================================================================================================
function ints_s2v(chars)
integer,allocatable         :: ints_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(ints_s2v(isize))
   do i=1,isize
      ints_s2v(i)=int(s2v(chars(i)))
   enddo
end function ints_s2v
!===================================================================================================================================
function reals_s2v(chars)
real,allocatable            :: reals_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(reals_s2v(isize))
   do i=1,isize
      reals_s2v(i)=real(s2v(chars(i)))
   enddo
end function reals_s2v
!===================================================================================================================================
function dbles_s2v(chars)
doubleprecision,allocatable :: dbles_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(dbles_s2v(isize))
   do i=1,isize
      dbles_s2v(i)=s2v(chars(i))
   enddo
end function dbles_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      value_to_string(3f) - [M_strings:NUMERIC] return numeric string
!!      from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine value_to_string(value,chars[,lgth,ierr,fmt,trimz])
!!
!!     character(len=*) :: chars  ! minimum of 23 characters required
!!     !--------
!!     ! VALUE may be any <em>one</em> of the following types:
!!     doubleprecision,intent(in)               :: value
!!     real,intent(in)                          :: value
!!     integer,intent(in)                       :: value
!!     logical,intent(in)                       :: value
!!     !--------
!!     character(len=*),intent(out)             :: chars
!!     integer,intent(out),optional             :: lgth
!!     integer,optional                         :: ierr
!!     character(len=*),intent(in),optional     :: fmt
!!     logical,intent(in)                       :: trimz
!!
!!##DESCRIPTION
!!    value_to_string(3f) returns a numeric representation of a numeric
!!    value in a string given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the string using internal writes. It
!!    then removes trailing zeros from non-zero values, and left-justifies
!!    the string.
!!
!!##OPTIONS
!!       VALUE   input value to be converted to a string
!!       FMT     You may specify a specific format that produces a string
!!               up to the length of CHARS; optional.
!!       TRIMZ   If a format is supplied the default is not to try to trim
!!               trailing zeros. Set TRIMZ to .true. to trim zeros from a
!!               string assumed to represent a simple numeric value.
!!
!!##RETURNS
!!       CHARS   returned string representing input value, must be at least
!!               23 characters long; or what is required by optional FMT
!!               if longer.
!!       LGTH    position of last non-blank character in returned string;
!!               optional.
!!       IERR    If not zero, error occurred; optional.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_value_to_string
!!      use M_strings, only: value_to_string
!!      implicit none
!!      character(len=80) :: string
!!      integer           :: lgth
!!         call value_to_string(3.0/4.0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(3.0/4.0,string,lgth,fmt='')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string&
!!         &(3.0/4.0,string,lgth,fmt='("THE VALUE IS ",g0)')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1234,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1.0d0/3.0d0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!      end program demo_value_to_string
!!
!!    Expected output
!!
!!     The value is [0.75]
!!     The value is [      0.7500000000]
!!     The value is [THE VALUE IS .750000000]
!!     The value is [1234]
!!     The value is [0.33333333333333331]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

! ident_45="@(#) M_strings value_to_string(3fp) subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         call journal('*value_to_string* UNKNOWN TYPE')
         chars=' '
      end select
      if(fmt.eq.'') then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.').ne.0) call trimzeros_(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local.ne.0)then
       ! cannot currently do I/O from a function being called from I/O
       !write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      v2s(3f) - [M_strings:NUMERIC] return numeric string from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function v2s(value) result(outstr)
!!
!!        integer|real|doubleprecision|logical,intent(in ) :: value
!!        character(len=:),allocatable :: outstr
!!        character(len=*),optional,intent(in) :: fmt
!!
!!##DESCRIPTION
!!    v2s(3f) returns a representation of a numeric value as a
!!    string when given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the strings using internal WRITE()
!!    statements. Trailing zeros are removed from non-zero values, and the
!!    string is left-justified.
!!
!!##OPTIONS
!!    VALUE   input value to be converted to a string
!!    FMT     format can be explicitly given, but is limited to
!!            generating a string of eighty or less characters.
!!
!!##RETURNS
!!    OUTSTR  returned string representing input value,
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_v2s
!!    use M_strings, only: v2s
!!    write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']'
!!    write(*,*) 'The value of 1234    is ['//v2s(1234)//']'
!!    write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']'
!!    write(*,*) 'The value of .false. is ['//v2s(.false.)//']'
!!    write(*,*) 'The value of .true. is  ['//v2s(.true.)//']'
!!    end program demo_v2s
!!
!!   Expected output
!!
!!     The value of 3.0/4.0 is [0.75]
!!     The value of 1234    is [1234]
!!     The value of 0d0     is [0]
!!     The value of .false. is [F]
!!     The value of .true. is  [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
! very odd compiler problems in many (but not all) programs using this routine; GNU Fortran (GCC) 5.4.0; 20161030
function v2s_bug(gval) result(outstr)

! ident_46="@(#) M_strings v2s_bug(3f) function returns string given numeric value"

class(*),intent(in)          :: gval                         ! input value to convert to a string
character(len=:),allocatable :: outstr                       ! output string to generate
character(len=80)            :: string
   call value_to_string(gval,string)
   outstr=trim(string)
end function v2s_bug
!===================================================================================================================================
function d2s(dvalue,fmt) result(outstr)

! ident_47="@(#) M_strings d2s(3fp) private function returns string given doubleprecision value"

doubleprecision,intent(in)   :: dvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(dvalue,string,fmt=fmt)
   else
      call value_to_string(dvalue,string)
   endif
   outstr=trim(string)
end function d2s
!===================================================================================================================================
function r2s(rvalue,fmt) result(outstr)

! ident_48="@(#) M_strings r2s(3fp) private function returns string given real value"

real,intent(in)              :: rvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(rvalue,string,fmt=fmt)
   else
      call value_to_string(rvalue,string)
   endif
   outstr=trim(string)
end function r2s
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

! ident_49="@(#) M_strings i2s(3fp) private function returns string given integer value"

integer,intent(in)           :: ivalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
function l2s(lvalue,fmt) result(outstr)

! ident_50="@(#) M_strings l2s(3fp) private function returns string given logical value"

logical,intent(in)           :: lvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)             :: string
   if(present(fmt))then
      call value_to_string(lvalue,string,fmt=fmt)
   else
      call value_to_string(lvalue,string)
   endif
   outstr=trim(string)
end function l2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isnumber(3f) - [M_strings:NUMERIC] determine if a string represents a number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function isnumber(str,msg)
!!
!!     character(len=*),intent(in)  :: str
!!     character(len=:),intent(out),allocatable,optional  :: msg
!!
!!##DESCRIPTION
!!     ISNUMBER(3f) returns a value greater than zero if the string represents
!!     a number, and a number less than or equal to zero if it is a bad number.
!!     Blank characters are ignored.
!!
!!##OPTIONS
!!     str  the string to evaluate as to whether it represents a numeric value
!!          or not
!!     msg  An optional message describing the string
!!
!!##RETURNS
!!     isnumber  the following values are returned
!!
!!                1 for an integer             [-+]NNNNN
!!                2 for a whole number         [-+]NNNNN.
!!                3 for a real value           [-+]NNNNN.MMMM
!!                4 for a exponential value    [-+]NNNNN.MMMM[-+]LLLL
!!                                             [-+]NNNNN.MMMM[ed][-+]LLLL
!!
!!               values less than 1 represent an error
!!
!!##EXAMPLES
!!
!!   As the example shows, you can use an internal READ(3f) along with the
!!   IOSTAT= parameter to check (and read) a string as well.
!!
!!     program demo_isnumber
!!     use M_strings, only : isnumber
!!     implicit none
!!     character(len=256) :: line
!!     real               :: value
!!     integer            :: ios1, ios2
!!     integer            :: answer
!!     character(len=256) :: message
!!     character(len=:),allocatable :: description
!!        write(*,*)'Begin entering values, one per line'
!!        do
!!           read(*,'(a)',iostat=ios1)line
!!           !
!!           ! try string as number using list-directed input
!!           line=''
!!           read(line,*,iostat=ios2,iomsg=message) value
!!           if(ios2.eq.0)then
!!              write(*,*)'VALUE=',value
!!           elseif( is_iostat_end(ios1) ) then
!!              stop 'end of file'
!!           else
!!              write(*,*)'ERROR:',ios2,trim(message)
!!           endif
!!           !
!!           ! try string using isnumber(3f)
!!           answer=isnumber(line,msg=description)
!!           if(answer.gt.0)then
!!              write(*,*) &
!!              & ' for ',trim(line),' ',answer,':',description
!!           else
!!              write(*,*) &
!!              & ' ERROR for ',trim(line),' ',answer,':',description
!!           endif
!!           !
!!        enddo
!!     end program demo_isnumber
!!
!!  Example run
!!
!!    > Begin entering values
!!    > ERROR:          -1 End of file
!!    >  ERROR for            -1 :null string
!!    >10
!!    > VALUE=   10.0000000
!!    >  for 10            1 :integer
!!    >20
!!    > VALUE=   20.0000000
!!    >  for 20            1 :integer
!!    >20.
!!    > VALUE=   20.0000000
!!    >  for 20.            2 :whole number
!!    >30.1
!!    > VALUE=   30.1000004
!!    >  for 30.1            3 :real number
!!    >3e1
!!    > VALUE=   30.0000000
!!    >  for 3e1            4 :value with exponent
!!    >1-2
!!    > VALUE=   9.99999978E-03
!!    >  for 1-2            4 :value with exponent
!!    >100.22d-4
!!    > VALUE=   1.00220004E-02
!!    >  for 100.22d-4            4 :value with exponent
!!    >1--2
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1--2           -5 :bad number
!!    >e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e           -6 :missing leading value before exponent
!!    >e1
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e1           -6 :missing leading value before exponent
!!    >1e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e           -3 :missing exponent
!!    >1e+
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+           -4 :missing exponent after sign
!!    >1e+2.0
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+2.0           -5 :bad number
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function isNumber(string,msg,verbose)
implicit none

! ident_51="@(#) M_strings isnumber(3f) Determines if a string is a number of not."

character(len=*),intent(in)    :: string
character(len=:),intent(out),allocatable,optional :: msg
logical,intent(in),optional                      :: verbose
integer                      :: isnumber

integer             :: i,iend
character(len=1),allocatable :: z(:)
character(len=:),allocatable :: message
logical                      :: founddigit
logical                      :: verbose_local

   i=1
   founddigit=.false.
   isnumber=0
   z=switch(trim(nospace(string)))
   iend=size(z)
   message='not a number'
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
   DONE : block
      if(iend.eq.0)then
         isnumber=-1                   ! string is null
         message='null string'
         exit DONE
      endif

      if(index('+-',z(i)).ne.0) i=i+1  ! skip optional leading sign
      if(i.gt.iend)then
         isnumber=-2                   ! string was just a sign
         message='just a sign'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1

      if(i.gt.iend)then
         isnumber=1                    ! [+-]NNNNNN
         message='integer'
         exit DONE
      endif
      if(z(i).eq.'.')then              ! a period would be OK at this point
         i=i+1
      endif

      if(i.gt.iend)then                ! [+-]NNNNNN.
         isnumber=2
         message='whole number'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1
      if(i.gt.iend)then
         isnumber=3                    ! [+-]NNNNNN.MMMM
         message='real number'
         exit DONE
      endif

      if(index('eEdD',z(i)).ne.0)then
         i=i+1
         if(i.eq.2)then
            isnumber=-6                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
            message='missing leading value before exponent'
            exit DONE
         endif
      endif
      if(i.gt.iend)then
         isnumber=-3                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
         message='missing exponent'
         exit DONE
      endif
      if(.not.founddigit)then
         isnumber=-7
         message='missing value before exponent'
         exit DONE
      endif
      if(index('+-',z(i)).ne.0) i=i+1
      if(i.gt.iend)then
         isnumber=-4                   ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow
         message='missing exponent after sign'
         exit DONE
      endif
      call next()                      ! position I to next non-digit or end of string+1
      if(i.gt.iend)then
         isnumber=4                    ! [+-]NNNNNN.MMMMe[+-]LL
         message='value with exponent'
         exit DONE
      endif
      isnumber=-5
      message='bad number'
   endblock DONE
   if(verbose_local)then
      write(*,*)trim(string)//' is '//message
   endif
   if(present(msg))then
      msg=message
   endif

contains
   subroutine next() ! move to next non-digit or end of string+1
      integer :: j
      do j=i,iend
         if(.not.isdigit(z(j)))then
            exit
         endif
         founddigit=.true.
         if(verbose_local) write(*,*)'I=',i,' J=',j,' Z(j)=',z(j)
      enddo
      i=j
      if(verbose_local)then
         write(*,*)'I and J=',i
         if(i.le.iend) then
            write(*,*)'Z(I)=',z(i)
         else
            write(*,*)'====>'
         endif
      endif
   end subroutine next
end function isNumber
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros_(3fp) - [M_strings:NUMERIC] Delete trailing zeros from
!!    numeric decimal string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine trimzeros_(str)
!!
!!     character(len=*)  :: str
!!
!!##DESCRIPTION
!!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a
!!    number. If the resulting string would end in a decimal point, one
!!    trailing zero is added.
!!
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have
!!          trailing zeros removed
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_trimzeros_
!!       use M_strings, only : trimzeros_
!!       character(len=:),allocatable :: string
!!          write(*,*)trimzeros_('123.450000000000')
!!          write(*,*)trimzeros_('12345')
!!          write(*,*)trimzeros_('12345.')
!!          write(*,*)trimzeros_('12345.00e3')
!!       end program demo_trimzeros_
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine trimzeros_(string)

! ident_52="@(#) M_strings trimzeros_(3fp) Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: exp          ! the exponent string if present
integer                      :: ipos         ! where exponent letter appears if present
integer                      :: i, ii
   str=string                                ! working copy of string
   ipos=scan(str,'eEdD')                     ! find end of real number if string uses exponent notation
   if(ipos>0) then                           ! letter was found
      exp=str(ipos:)                         ! keep exponent string so it can be added back as a suffix
      str=str(1:ipos-1)                      ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if(index(str,'.').eq.0)then               ! if no decimal character in original string add one to end of string
      ii=len_trim(str)
      str(ii+1:ii+1)='.'                     ! add decimal to end of string
   endif
   do i=len_trim(str),1,-1                   ! scanning from end find a non-zero character
      select case(str(i:i))
      case('0')                              ! found a trailing zero so keep trimming
         cycle
      case('.')                              ! found a decimal character at end of remaining string
         if(i.le.1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)                        ! found a non-zero character so trim string and exit
         exit
      end select
   enddo
   if(ipos>0)then                            ! if originally had an exponent place it back on
      string=trim(str)//trim(exp)
   else
      string=str
   endif
end subroutine trimzeros_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    listout(3f) - [M_strings:NUMERIC] expand a list of numbers where negative
!!    numbers denote range ends (1 -10 means 1 thru 10)
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine listout(icurve_lists,icurve_expanded,inums,ierr)
!!
!!    integer,intent(in)    :: icurve_lists(:)
!!    integer,intent(out)   :: icurve_expanded(:)
!!    integer,intent(out)   :: inums
!!    integer,intent(out)   :: ierr
!!
!!##DESCRIPTION
!!    expand a list of whole numbers where negative numbers indicate a range.
!!    So [10,-20] would be expanded to [10,11,12,13,14,15,16,17,18,19,20].
!!
!!##OPTIONS
!!    icurve_lists(:)      input array
!!
!!##RETURNS
!!    icurve_expanded(:)   output array; assumed large enough to hold
!!                         returned list
!!    inums                number of icurve_expanded numbers on output
!!    ierr                 zero if no error occurred
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_listout
!!     use M_strings, only : listout
!!     implicit none
!!     integer,allocatable :: icurve_lists(:)
!!     integer :: icurve_expanded(1000)
!!     ! icurve_lists is input array
!!     integer :: inums
!!     ! icurve_expanded is output array
!!     integer :: i
!!     ! number of icurve_lists values on input,
!!     ! number of icurve_expanded numbers on output
!!     integer :: ierr
!!        icurve_lists=[1, 20, -30, 101, 100, 99, 100, -120, 222, -200]
!!        inums=size(icurve_lists)
!!        call listout(icurve_lists,icurve_expanded,inums,ierr)
!!        if(ierr.eq.0)then
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        else
!!           write(*,'(a,i0)')'error occurred in *listout* ',ierr
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        endif
!!     end program demo_listout
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine listout(icurve_lists,icurve_expanded,inums_out,ierr)
implicit none

! ident_53="@(#) M_strings listout(3f) copy icurve_lists to icurve_expanded expanding negative numbers to ranges (1 -10 means 1 thru 10)"

!   Created: 19971231
integer,intent(in)    :: icurve_lists(:)             ! input array
integer,intent(out)   :: icurve_expanded(:)          ! output array
integer,intent(out)   :: inums_out                   ! number of icurve_expanded numbers on output
integer,intent(out)   :: ierr                        ! status variable

character(len=80)     :: temp1
integer               :: i80, i90
integer               :: imin, imax
integer               :: idirection, icount
integer               :: iin
integer               :: inums_max

   ierr=0
   icurve_expanded=0                          ! initialize output array
   inums_out=0                                ! initialize number of significant values in output array

   inums_max=size(icurve_expanded)
   if(inums_max.eq.0)then
      ierr=-2
      return
   endif

   iin=size(icurve_lists)
   if(iin.gt.0)then
      icurve_expanded(1)=icurve_lists(1)
   endif

   icount=2
      do i90=2,iin
         if(icurve_lists(i90).lt.0)then
            imax=abs(icurve_lists(i90))
            imin=abs(icurve_lists(i90-1))
            if(imin.gt.imax)then
               idirection=-1
               imin=imin-1
            elseif(imax.gt.imin)then
               idirection=1
               imin=imin+1
            else
               idirection=1
            endif
            do i80=imin,imax,idirection
               if(icount.gt.inums_max) then
                  write(temp1,'(a,i5,a)')'*listout* only ',inums_max,' values allowed'
                  ierr=-1
                  call journal(temp1)
                  inums_out=icount-1
                  exit
               endif
               icurve_expanded(icount)=i80
               icount=icount+1
            enddo
         else
            icurve_expanded(icount)=icurve_lists(i90)
            icount=icount+1
         endif
      enddo
   inums_out=icount-1

end subroutine listout
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     quote(3f) - [M_strings:QUOTES] add quotes to string as if written
!!     with list-directed input
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function quote(str,mode,clip) result (quoted_str)
!!
!!    character(len=*),intent(in)          :: str
!!    character(len=*),optional,intent(in) :: mode
!!    logical,optional,intent(in)          :: clip
!!    character(len=:),allocatable         :: quoted_str
!!
!!##DESCRIPTION
!!    Add quotes to a CHARACTER variable as if it was written using
!!    list-directed input. This is particularly useful for processing
!!    strings to add to CSV files.
!!
!!##OPTIONS
!!    str    input string to add quotes to, using the rules of
!!           list-directed input (single quotes are replaced by two
!!           adjacent quotes)
!!    mode   alternate quoting methods are supported:
!!
!!             DOUBLE   default. replace quote with double quotes
!!             ESCAPE   replace quotes with backslash-quote instead of
!!                      double quotes
!!
!!    clip   default is to trim leading and trailing spaces from the
!!           string. If CLIP is .FALSE. spaces are not trimmed
!!
!!##RESULT
!!    quoted_str  The output string, which is based on adding quotes to STR.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_quote
!!    use M_strings, only : quote
!!    implicit none
!!    character(len=:),allocatable :: str
!!    character(len=1024)          :: msg
!!    integer                      :: ios
!!    character(len=80)            :: inline
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=ios,iomsg=msg)inline
!!          if(ios.ne.0)then
!!             write(*,*)trim(inline)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'ORIGINAL     ['//trim(inline)//']'
!!
!!          ! the string processed by quote(3f)
!!          str=quote(inline)
!!          write(*,'(a)')'QUOTED     ['//str//']'
!!
!!          ! write the string list-directed to compare the results
!!          write(*,'(a)',iostat=ios,iomsg=msg) 'LIST DIRECTED:'
!!          write(*,*,iostat=ios,iomsg=msg,delim='none') inline
!!          write(*,*,iostat=ios,iomsg=msg,delim='quote') inline
!!          write(*,*,iostat=ios,iomsg=msg,delim='apostrophe') inline
!!       enddo
!!    end program demo_quote
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function quote(str,mode,clip) result (quoted_str)
character(len=*),intent(in)          :: str                ! the string to be quoted
character(len=*),optional,intent(in) :: mode
logical,optional,intent(in)          :: clip
character(len=:),allocatable         :: quoted_str

character(len=1),parameter           :: double_quote = '"'
character(len=20)                    :: local_mode

   if(present(clip))then
      if(clip)then
         quoted_str=adjustl(str)
      else
         quoted_str=str
      endif
   else
      quoted_str=str
   endif

   local_mode=merge_str(mode,'DOUBLE',present(mode))

   select case(lower(local_mode))
   case('double')
      quoted_str=double_quote//trim(replace(quoted_str,'"','""'))//double_quote
   case('escape')
      quoted_str=double_quote//trim(replace(quoted_str,'"','\"'))//double_quote
   case default
      call journal('sc','*quote* ERROR: unknown quote mode ',local_mode)
      quoted_str=str
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
end function quote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     unquote(3f) - [M_strings:QUOTES] remove quotes from string as if
!!     read with list-directed input
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function unquote(quoted_str,esc) result (unquoted_str)
!!
!!    character(len=*),intent(in)          :: quoted_str
!!    character(len=1),optional,intent(in) :: esc
!!    character(len=:),allocatable         :: unquoted_str
!!
!!##DESCRIPTION
!!    Remove quotes from a CHARACTER variable as if it was read using
!!    list-directed input. This is particularly useful for processing
!!    tokens read from input such as CSV files.
!!
!!    Fortran can now read using list-directed input from an internal file,
!!    which should handle quoted strings, but list-directed input does not
!!    support escape characters, which UNQUOTE(3f) does.
!!
!!##OPTIONS
!!    quoted_str  input string to remove quotes from, using the rules of
!!                list-directed input (two adjacent quotes inside a quoted
!!                region are replaced by a single quote, a single quote or
!!                double quote is selected as the delimiter based on which
!!                is encountered first going from left to right, ...)
!!    esc         optional character used to protect the next quote
!!                character from being processed as a quote, but simply as
!!                a plain character.
!!
!!##RESULT
!!    unquoted_str  The output string, which is based on removing quotes
!!                  from quoted_str.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_unquote
!!       use M_strings, only : unquote
!!       implicit none
!!       character(len=128)           :: quoted_str
!!       character(len=:),allocatable :: unquoted_str
!!       character(len=1),parameter   :: esc='\'
!!       character(len=1024)          :: msg
!!       integer                      :: ios
!!       character(len=1024)          :: dummy
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=ios,iomsg=msg)quoted_str
!!          if(ios.ne.0)then
!!             write(*,*)trim(msg)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
!!
!!          ! the string processed by unquote(3f)
!!          unquoted_str=unquote(trim(quoted_str),esc)
!!          write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
!!
!!          ! read the string list-directed to compare the results
!!          read(quoted_str,*,iostat=ios,iomsg=msg)dummy
!!          if(ios.ne.0)then
!!             write(*,*)trim(msg)
!!          else
!!             write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
!!          endif
!!       enddo
!!    end program demo_unquote
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str              ! the string to be unquoted
character(len=1),optional,intent(in) :: esc                     ! escape character
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote                   ! whichever quote is to be used
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(esc))then                           ! select escape character as specified character or special value meaning not set
      iesc=iachar(esc)                            ! allow for an escape character
   else
      iesc=-1                                     ! set to value that matches no character
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   inlen=len(quoted_str)                          ! find length of input string
   allocate(character(len=inlen) :: unquoted_str) ! initially make output string length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(inlen.ge.1)then                             ! double_quote is the default quote unless the first character is single_quote
      if(quoted_str(1:1).eq.single_quote)then
         quote=iachar(single_quote)
      else
         quote=iachar(double_quote)
      endif
   else
      quote=iachar(double_quote)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   before=-2                                      ! initially set previous character to impossible value
   unquoted_str(:)=''                             ! initialize output string to null string
   iput=1
   inside=.false.
   STEPTHROUGH: do i=1,inlen
      current=iachar(quoted_str(i:i))
      if(before.eq.iesc)then                      ! if previous character was escape use current character unconditionally
           iput=iput-1                            ! backup
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2                              ! this could be second esc or quote
      elseif(current.eq.quote)then                ! if current is a quote it depends on whether previous character was a quote
         if(before.eq.quote)then
           unquoted_str(iput:iput)=char(quote)    ! this is second quote so retain it
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before.ne.iesc)then
            inside=.true.
         else                                     ! this is first quote so ignore it except remember it in case next is a quote
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo STEPTHROUGH
!-----------------------------------------------------------------------------------------------------------------------------------
   unquoted_str=unquoted_str(:iput-1)
!-----------------------------------------------------------------------------------------------------------------------------------
end function unquote
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    edit_distance(3f) - [M_strings] returns a naive edit distance using
!!    the Levenshtein distance algorithm
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure elemental function edit_distance(str1,str2) result (distance)
!!
!!     character(len=*),intent(in)   :: str1, str2
!!     integer :: distance
!!
!!##DESCRIPTION
!!
!!   The Levenshtein distance function returns how many edits (deletions,
!!   insertions, transposition) are required to turn one string into another.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_edit_distance
!!    use M_strings, only : edit_distance
!!       write(*,*)edit_distance('kittens','sitting')==3
!!       write(*,*)edit_distance('geek','gesek')==1
!!       write(*,*)edit_distance('Saturday','Sunday')==3
!!    end program demo_edit_distance
!!
!!   Expected output
!!
!!     T
!!     T
!!     T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
! The Levenshtein distance function returns how many edits (deletions,
! insertions, transposition) are required to turn one string into another.
pure elemental integer function edit_distance (a,b)
character(len=*), intent(in) :: a, b
integer                      :: len_a, len_b, i, j, cost
! matrix for calculating Levenshtein distance
integer                      :: matrix(0:len_trim(a), 0:len_trim(b))
   len_a = len_trim(a)
   len_b = len_trim(b)
   matrix(:,0) = [(i,i=0,len_a)]
   matrix(0,:) = [(j,j=0,len_b)]
   do i = 1, len_a
      do j = 1, len_b
         cost=merge(0,1,a(i:i)==b(j:j))
         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)
      enddo
   enddo
   edit_distance = matrix(len_a,len_b)
end function edit_distance
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    cc(3f) - [M_strings] return up to twenty strings of arbitrary length
!!             as an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function cc(str1,str2,...str20,len) result (vec)
!!
!!     character(len=*),intent(in),optional   :: str1, str2 ... str20
!!     integer,intent(in),optional            :: len
!!
!!##DESCRIPTION
!!    Given a list of up to twenty strings create a string array. The
!!    length of the variables with be the same as the maximum length
!!    of the input strings unless explicitly specified via LEN.
!!
!!    This is an alternative to the syntax
!!
!!      [ CHARACTER(LEN=NN) :: str1, str2, ... ]
!!
!!    that calulates the minimum length required to prevent truncation by
!!    default.
!!
!!##OPTIONS
!!    str1,str2, ... str20  input strings to combine into a vector
!!    len   length of returned array variables
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_cc
!!    use M_strings, only: cc
!!    implicit none
!!       print "(*('""',a,'""':,',',1x))", cc("one")
!!       print "(*('""',a,'""':,',',1x))", cc("one","two")
!!       print "(*('""',a,'""':,',',1x))", cc("one","two","three")
!!       print "(*('""',a,'""':,',',1x))", cc("one","two","three",&
!!               & "four","five","six","seven")
!!    end program demo_cc
!!
!!   Expected output
!!
!!    "one"
!!    "one", "two"
!!    "one  ", "two  ", "three"
!!    "one  ", "two  ", "three", "four ", "five ", "six  ", "seven"
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function cc(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,len) result(vec)
! return character array containing present arguments
character(len=*),intent(in),optional  :: x1,x2,x3,x4,x5,x6,x7,x8,x9,x10
character(len=*),intent(in),optional  :: x11,x12,x13,x14,x15,x16,x17,x18,x19,x20
integer,intent(in),optional           :: len
character(len=:),allocatable          :: vec(:)
integer                               :: ilen, icount, iset
   ilen=0
   icount=0
   iset=0
   call increment(x1)
   call increment(x2)
   call increment(x3)
   call increment(x4)
   call increment(x5)
   call increment(x6)
   call increment(x7)
   call increment(x8)
   call increment(x9)
   call increment(x10)
   call increment(x11)
   call increment(x12)
   call increment(x13)
   call increment(x14)
   call increment(x15)
   call increment(x16)
   call increment(x17)
   call increment(x18)
   call increment(x19)
   call increment(x20)

   if(present(len)) ilen=len
   allocate (character(len=ilen) ::vec(icount))

   call set(x1)
   call set(x2)
   call set(x3)
   call set(x4)
   call set(x5)
   call set(x6)
   call set(x7)
   call set(x8)
   call set(x9)
   call set(x10)
   call set(x11)
   call set(x12)
   call set(x13)
   call set(x14)
   call set(x15)
   call set(x16)
   call set(x17)
   call set(x18)
   call set(x19)
   call set(x20)

contains

subroutine increment(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      ilen=max(ilen,len_trim(str))
      icount=icount+1
   endif
end subroutine increment

subroutine set(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      iset=iset+1
      vec(iset)=str
   endif
end subroutine set

end function cc
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    describe(3f) - [M_strings] returns a string describing the name of
!!    a single character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function describe(ch) result (string)
!!
!!     character(len=1),intent(in)   :: ch
!!     character(len=:),allocatable  :: string
!!
!!##DESCRIPTION
!!    describe(3f) returns a string describing long name of a single
!!    character
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_describe
!!     use M_strings, only : describe
!!     implicit none
!!     integer :: i
!!        do i=1,128  ! fill variable with base ASCII character set
!!           write(*,*)describe(char(i-1))
!!        enddo
!!    end program demo_describe
!!
!!   Expected output
!!
!!     ctrl-@ or ctrl-? (NUL) null
!!     ctrl-A (SOH) start of heading
!!     ctrl-B (STX) start of text
!!     ctrl-C (ETX) end of text
!!     ctrl-D (EOT) end of transmission
!!     ctrl-E (ENQ) enquiry
!!     ctrl-F (ACK) acknowledge
!!     ctrl-G (BEL) bell
!!     ctrl-H (BS) backspace
!!     ctrl-I (HT) horizontal tabulation
!!     ctrl-J (LF) line feed
!!     ctrl-K (VT) vertical tabulation
!!     ctrl-L (FF) form feed
!!     ctrl-M (CR) carriage return
!!     ctrl-N (SO) shift out
!!     ctrl-O (SI) shift in
!!     ctrl-P (DLE) data link escape
!!     ctrl-Q (DC1) device control 1
!!     ctrl-R (DC2) device control 2
!!     ctrl-S (DC3) device control 3
!!     ctrl-T (DC4) device control 4
!!     ctrl-U (NAK) negative acknowledge
!!     ctrl-V (SYN) synchronous idle
!!     ctrl-W (ETB) end of transmission block
!!     ctrl-X (CAN) cancel
!!     ctrl-Y (EM) end of medium
!!     ctrl-Z (SUB) substitute
!!     ctrl-[ (ESC) escape
!!     ctrl-\ or ctrl-@ (FS) file separator
!!     ctrl-] (GS) group separator
!!     ctrl-^ or ctrl-= (RS) record separator
!!     ctrl-_ (US) unit separator
!!     space
!!     ! exclamation point
!!     " quotation marks
!!     # number sign
!!     $ currency symbol
!!     % percent
!!     & ampersand
!!     ' apostrophe
!!     ( left parenthesis
!!     ) right parenthesis
!!     * asterisk
!!     + plus
!!     , comma
!!     - minus
!!     . period
!!     / slash
!!     0 zero
!!     1 one
!!     2 two
!!     3 three
!!     4 four
!!     5 five
!!     6 six
!!     7 seven
!!     8 eight
!!     9 nine
!!     : colon
!!     ; semicolon
!!     < less than
!!     = equals
!!     > greater than
!!     ? question mark
!!     @ at sign
!!     majuscule A
!!     majuscule B
!!     majuscule C
!!     majuscule D
!!     majuscule E
!!     majuscule F
!!     majuscule G
!!     majuscule H
!!     majuscule I
!!     majuscule J
!!     majuscule K
!!     majuscule L
!!     majuscule M
!!     majuscule N
!!     majuscule O
!!     majuscule P
!!     majuscule Q
!!     majuscule R
!!     majuscule S
!!     majuscule T
!!     majuscule U
!!     majuscule V
!!     majuscule W
!!     majuscule X
!!     majuscule Y
!!     majuscule Z
!!     [ left bracket
!!     \ backslash
!!     ] right bracket
!!     ^ caret
!!     _ underscore
!!     ` grave accent
!!     miniscule a
!!     miniscule b
!!     miniscule c
!!     miniscule d
!!     miniscule e
!!     miniscule f
!!     miniscule g
!!     miniscule h
!!     miniscule i
!!     miniscule j
!!     miniscule k
!!     miniscule l
!!     miniscule m
!!     miniscule n
!!     miniscule o
!!     miniscule p
!!     miniscule q
!!     miniscule r
!!     miniscule s
!!     miniscule t
!!     miniscule u
!!     miniscule v
!!     miniscule w
!!     miniscule x
!!     miniscule y
!!     miniscule z
!!     { left brace
!!     | vertical line
!!     } right brace
!!     ~ tilde
!!     ctrl-? (DEL) delete
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function describe(ch) result (string)

! ident_54="@(#) M_strings describe(3f) return string describing long name of a single character"

character(len=1),intent(in)   :: ch
character(len=:),allocatable  :: string
! LATER: add hex, octal, decimal, key-press description, alternate names
!  ASCII character codes
   select case (iachar(ch))
   case(     0  ); STRING="ctrl-@ or ctrl-? (NUL) null"
   case(     1  ); STRING="ctrl-A (SOH) start of heading"
   case(     2  ); STRING="ctrl-B (STX) start of text"
   case(     3  ); STRING="ctrl-C (ETX) end of text"
   case(     4  ); STRING="ctrl-D (EOT) end of transmission"
   case(     5  ); STRING="ctrl-E (ENQ) enquiry"
   case(     6  ); STRING="ctrl-F (ACK) acknowledge"
   case(     7  ); STRING="ctrl-G (BEL) bell"
   case(     8  ); STRING="ctrl-H (BS) backspace"
   case(     9  ); STRING="ctrl-I (HT) horizontal tabulation"
   case(    10  ); STRING="ctrl-J (LF) line feed"
   case(    11  ); STRING="ctrl-K (VT) vertical tabulation"
   case(    12  ); STRING="ctrl-L (FF) form feed"
   case(    13  ); STRING="ctrl-M (CR) carriage return"
   case(    14  ); STRING="ctrl-N (SO) shift out"
   case(    15  ); STRING="ctrl-O (SI) shift in"
   case(    16  ); STRING="ctrl-P (DLE) data link escape"
   case(    17  ); STRING="ctrl-Q (DC1) device control 1"
   case(    18  ); STRING="ctrl-R (DC2) device control 2"
   case(    19  ); STRING="ctrl-S (DC3) device control 3"
   case(    20  ); STRING="ctrl-T (DC4) device control 4"
   case(    21  ); STRING="ctrl-U (NAK) negative acknowledge"
   case(    22  ); STRING="ctrl-V (SYN) synchronous idle"
   case(    23  ); STRING="ctrl-W (ETB) end of transmission block"
   case(    24  ); STRING="ctrl-X (CAN) cancel"
   case(    25  ); STRING="ctrl-Y (EM) end of medium"
   case(    26  ); STRING="ctrl-Z (SUB) substitute"
   case(    27  ); STRING="ctrl-[ (ESC) escape"
   case(    28  ); STRING="ctrl-\ or ctrl-@ (FS) file separator"
   case(    29  ); STRING="ctrl-] (GS) group separator"
   case(    30  ); STRING="ctrl-^ or ctrl-= (RS) record separator"
   case(    31  ); STRING="ctrl-_ (US) unit separator"
   case(    32  ); STRING="space"
   case(    33  ); STRING="! exclamation point (screamer, gasper, slammer, startler, bang, shriek, pling)"
   case(    34  ); STRING=""" quotation marks"
   case(    35  ); STRING="# number sign (hash, pound sign, hashtag)"
   case(    36  ); STRING="$ currency symbol"
   case(    37  ); STRING="% percent"
   case(    38  ); STRING="& ampersand"
   case(    39  ); STRING="' apostrophe"
   case(    40  ); STRING="( left parenthesis"
   case(    41  ); STRING=") right parenthesis"
   case(    42  ); STRING="* asterisk"
   case(    43  ); STRING="+ plus"
   case(    44  ); STRING=", comma"
   case(    45  ); STRING="- minus"
   case(    46  ); STRING=". period"
   case(    47  ); STRING="/ slash"
   case(    48  ); STRING="0 zero"
   case(    49  ); STRING="1 one"
   case(    50  ); STRING="2 two"
   case(    51  ); STRING="3 three"
   case(    52  ); STRING="4 four"
   case(    53  ); STRING="5 five"
   case(    54  ); STRING="6 six"
   case(    55  ); STRING="7 seven"
   case(    56  ); STRING="8 eight"
   case(    57  ); STRING="9 nine"
   case(    58  ); STRING=": colon"
   case(    59  ); STRING="; semicolon"
   case(    60  ); STRING="< less than"
   case(    61  ); STRING="= equals"
   case(    62  ); STRING="> greater than"
   case(    63  ); STRING="? question mark"
   case(    64  ); STRING="@ at sign"
   case(    65  ); STRING="A majuscule A"
   case(    66  ); STRING="B majuscule B"
   case(    67  ); STRING="C majuscule C"
   case(    68  ); STRING="D majuscule D"
   case(    69  ); STRING="E majuscule E"
   case(    70  ); STRING="F majuscule F"
   case(    71  ); STRING="G majuscule G"
   case(    72  ); STRING="H majuscule H"
   case(    73  ); STRING="I majuscule I"
   case(    74  ); STRING="J majuscule J"
   case(    75  ); STRING="K majuscule K"
   case(    76  ); STRING="L majuscule L"
   case(    77  ); STRING="M majuscule M"
   case(    78  ); STRING="N majuscule N"
   case(    79  ); STRING="O majuscule O"
   case(    80  ); STRING="P majuscule P"
   case(    81  ); STRING="Q majuscule Q"
   case(    82  ); STRING="R majuscule R"
   case(    83  ); STRING="S majuscule S"
   case(    84  ); STRING="T majuscule T"
   case(    85  ); STRING="U majuscule U"
   case(    86  ); STRING="V majuscule V"
   case(    87  ); STRING="W majuscule W"
   case(    88  ); STRING="X majuscule X"
   case(    89  ); STRING="Y majuscule Y"
   case(    90  ); STRING="Z majuscule Z"
   case(    91  ); STRING="[ left bracket"
   case(    92  ); STRING="\ backslash"
   case(    93  ); STRING="] right bracket"
   case(    94  ); STRING="^ caret"
   case(    95  ); STRING="_ underscore"
   case(    96  ); STRING="` grave accent"
   case(    97  ); STRING="a miniscule a"
   case(    98  ); STRING="b miniscule b"
   case(    99  ); STRING="c miniscule c"
   case(   100  ); STRING="d miniscule d"
   case(   101  ); STRING="e miniscule e"
   case(   102  ); STRING="f miniscule f"
   case(   103  ); STRING="g miniscule g"
   case(   104  ); STRING="h miniscule h"
   case(   105  ); STRING="i miniscule i"
   case(   106  ); STRING="j miniscule j"
   case(   107  ); STRING="k miniscule k"
   case(   108  ); STRING="l miniscule l"
   case(   109  ); STRING="m miniscule m"
   case(   110  ); STRING="n miniscule n"
   case(   111  ); STRING="o miniscule o"
   case(   112  ); STRING="p miniscule p"
   case(   113  ); STRING="q miniscule q"
   case(   114  ); STRING="r miniscule r"
   case(   115  ); STRING="s miniscule s"
   case(   116  ); STRING="t miniscule t"
   case(   117  ); STRING="u miniscule u"
   case(   118  ); STRING="v miniscule v"
   case(   119  ); STRING="w miniscule w"
   case(   120  ); STRING="x miniscule x"
   case(   121  ); STRING="y miniscule y"
   case(   122  ); STRING="z miniscule z"
   case(   123  ); STRING="{ left brace"
   case(   124  ); STRING="| vertical line"
   case(   125  ); STRING="} right brace"
   case(   126  ); STRING="~ tilde"
   case(   127  ); STRING="ctrl-? (DEL) delete"
   case default
         STRING='UNKNOWN'//v2s(IACHAR(ch))
   end select
end function describe
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getvals(3f) - [M_strings:NUMERIC] read arbitrary number of REAL values
!!    from a character variable up to size of VALUES() array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine getvals(line,values,icount,ierr)
!!
!!     character(len=*),intent(in)  :: line
!!     class(*),intent(out)         :: values(:)
!!     integer,intent(out)          :: icount
!!     integer,intent(out),optional :: ierr
!!
!!##DESCRIPTION
!!   GETVALS(3f) reads a relatively arbitrary number of numeric values from
!!   a character variable into a REAL array using list-directed input.
!!
!!   NOTE: In this version null values are skipped instead of meaning to leave
!!         that value unchanged
!!
!!        1,,,,,,,2 / reads VALUES=[1.0,2.0]
!!
!!   Per list-directed rules when reading values, allowed delimiters are
!!   comma, semi-colon and space.
!!
!!   the slash separator can be used to add inline comments.
!!
!!        10.1, 20.43e-1 ; 11 / THIS IS TREATED AS A COMMENT
!!
!!   Repeat syntax can be used up to the size of the output array. These are
!!   equivalent input lines:
!!
!!        4*10.0
!!        10.0, 10.0, 10.0, 10.0
!!
!!##OPTIONS
!!   LINE      A character variable containing the characters representing
!!             a list of numbers
!!
!!##RETURNS
!!   VALUES()  array holding numbers read from string. May be of type
!!             INTEGER, REAL, DOUBLEPRECISION, or CHARACTER. If CHARACTER the
!!             strings are returned as simple words instead of numeric values.
!!   ICOUNT    number of defined numbers in VALUES(). If ICOUNT reaches
!!             the size of the VALUES() array parsing stops.
!!   IERR      zero if no error occurred in reading numbers. Optional.
!!             If not present and an error occurs the program is terminated.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_getvals
!!       use M_strings, only: getvals
!!       implicit none
!!       integer,parameter  :: longest_line=256
!!       character(len=longest_line) :: line
!!       real               :: values(longest_line/2+1)
!!       integer            :: ios,icount,ierr
!!       INFINITE: do
!!          read(*,'(a)',iostat=ios) line
!!          if(ios.ne.0)exit INFINITE
!!          call getvals(line,values,icount,ierr)
!!          write(*,'(4(g0,1x))')'VALUES=',values(:icount)
!!       enddo INFINITE
!!       end program demo_getvals
!!
!!  Sample input lines
!!
!!        10,20 30.4
!!        1 2 3
!!        1
!!
!!        3 4*2.5 8
!!        32.3333 / comment 1
!!        30e3;300,    30.0, 3
!!        even 1 like this! 10
!!        11,,,,22,,,,33
!!
!!  Expected output:
!!
!!     VALUES=   10.0000000       20.0000000       30.3999996
!!     VALUES=   1.00000000       2.00000000       3.00000000
!!     VALUES=   1.00000000
!!     VALUES=
!!     VALUES=   3.00000000       2.50000000       2.50000000
!!     2.50000000       2.50000000       8.00000000
!!     VALUES=   32.3333015
!!     VALUES=   30000.0000       300.000000       30.0000000
!!     3.00000000
!!     *getvals* WARNING:[even] is not a number
!!     *getvals* WARNING:[like] is not a number
!!     *getvals* WARNING:[this!] is not a number
!!     VALUES=   1.00000000       10.0000000
!!     VALUES=   11.0000000       22.0000000       33.0000000
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine getvals(line,values,icount,ierr)
implicit none

! ident_55="@(#) M_strings getvals(3f) read arbitrary number of values from a character variable"

! JSU 20170831

character(len=*),intent(in)  :: line
class(*),intent(out)         :: values(:)
integer,intent(out)          :: icount
integer,intent(out),optional :: ierr

character(len=:),allocatable :: buffer
character(len=len(line))     :: words(size(values))
integer                      :: ios, i, ierr_local,isize

   isize=0
   select type(values)
   type is (integer);          isize=size(values)
   type is (real);             isize=size(values)
   type is (doubleprecision);  isize=size(values)
   type is (character(len=*)); isize=size(values)
   end select

   ierr_local=0

   words=' '                            ! make sure words() is initialized to null+blanks
   buffer=trim(unquote(line))//"/"      ! add a slash to the end so how the read behaves with missing values is clearly defined
   read(buffer,*,iostat=ios) words      ! undelimited strings are read into an array
   icount=0
   do i=1,isize                         ! loop thru array and convert non-blank words to numbers
      if(words(i).eq.' ')cycle

      select type(values)
      type is (integer);          read(words(i),*,iostat=ios)values(icount+1)
      type is (real);             read(words(i),*,iostat=ios)values(icount+1)
      type is (doubleprecision);  read(words(i),*,iostat=ios)values(icount+1)
      type is (character(len=*)); values(icount+1)=words(i)
      end select

      if(ios.eq.0)then
         icount=icount+1
      else
         ierr_local=ios
         write(ERROR_UNIT,*)'*getvals* WARNING:['//trim(words(i))//'] is not a number of specified type'
      endif
   enddo

   if(present(ierr))then
      ierr=ierr_local
   elseif(ierr_local.ne.0)then        ! error occurred and not returning error to main program to print message and stop program
      write(ERROR_UNIT,*)'*getval* error reading line ['//trim(line)//']'
      stop 2
   endif

end subroutine getvals
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_values(3f) - [M_strings:NUMERIC] read a string representing
!!      numbers into a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       subroutine string_to_values(line,iread,values,inums,delims,ierr)
!!
!!        character(len=*) :: line
!!        integer          :: iread
!!        real             :: values(*)
!!        integer          :: inums
!!        character(len=*) :: delims
!!        integer          :: ierr
!!
!!##DESCRIPTION
!!    This routine can take a string representing a series of numbers and
!!    convert it to a numeric array and return how many numbers were found.
!!
!!##OPTIONS
!!       LINE     Input string containing numbers
!!       IREAD    maximum number of values to try to read from input string
!!
!!##RESULTS
!!       VALUES   real array to be filled with numbers
!!       INUMS    number of values successfully read (before error occurs
!!                if one does)
!!       DELIMS   delimiter character(s), usually a space. must not be a
!!                null string. If more than one character, a space must
!!                not be the last character or it will be ignored.
!!       IERR     error flag (0=no error, else column number string starts
!!                at that error occurred on).
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!      program demo_string_to_values
!!       use M_strings, only : string_to_values
!!       implicit none
!!       character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!       integer,parameter  :: isz=10
!!       real               :: array(isz)
!!       integer            :: inums, ierr, ii
!!
!!       call string_to_values(s,10,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       contains
!!          subroutine reportit()
!!             write(*,*)'string_to_values:'
!!             write(*,*)'input string.............',trim(s)
!!             write(*,*)'number of values found...',inums
!!             write(*,*)'values...................',(array(ii),ii=1,inums)
!!          end subroutine reportit
!!      end program demo_string_to_values
!!
!!    Expected output
!!
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000  20000.0000  3.45000005
!!     -4.00299978  1234.00000  5678.00000
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           3
!!     values...................   10.0000000  2.29999995  3.14159989
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine string_to_values(line,iread,values,inums,delims,ierr)
implicit none
!----------------------------------------------------------------------------------------------------------------------------------
!   1989,1997-12-31,2014 John S. Urban

!   given a line of structure , string , string , string process each
!   string as a numeric value and store into an array.
!   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS.
!   There is no direct checking for more values than can fit in VALUES.
!   Quits if encounters any errors in read.
!----------------------------------------------------------------------------------------------------------------------------------

! ident_56="@(#) M_strings string_to_values(3f) reads an array of numbers from a numeric string"

character(len=*),intent(in)  :: line          ! input string
integer,intent(in)           :: iread         ! maximum number of values to try to read into values
real,intent(inout)           :: values(iread) ! real array to be filled with values
integer,intent(out)          :: inums         ! number of values successfully read from string
character(len=*),intent(in)  :: delims        ! allowed delimiters
integer,intent(out)          :: ierr          ! 0 if no error, else column number undecipherable string starts at
!----------------------------------------------------------------------------------------------------------------------------------
character(len=256)           :: delims_local        ! mutable copy of allowed delimiters
integer                      :: istart,iend,lgth,icol
integer                      :: i10,i20,i40
real                         :: rval
integer                      :: ier
integer                      :: delimiters_length
!----------------------------------------------------------------------------------------------------------------------------------
      delims_local=delims                                 ! need a mutable copy of the delimiter list
      if(delims_local.eq.'')then                          ! if delimiter list is null or all spaces make it a space
         delims_local=' '                                 ! delimiter is a single space
         delimiters_length=1                        ! length of delimiter list
      else
         delimiters_length=len_trim(delims)         ! length of variable WITH TRAILING WHITESPACE TRIMMED
      endif
!----------------------------------------------------------------------------------------------------------------------------------
      ierr=0                                        ! initialize error code returned
      inums=0                                       ! initialize count of values successfully returned
      istart=0
!----------------------------------------------------------------------------------------------------------------------------------
      lgth=0                                        ! lgth will be the position of the right-most non-delimiter in the input line
      do i20=len(line),1,-1                         ! loop from end of string to beginning to find right-most non-delimiter
         if(index(delims_local(:delimiters_length),line(i20:i20)).eq.0)then   ! found a non-delimiter
            lgth=i20
            exit
         endif
      enddo
      if(lgth.eq.0)then                             ! command was totally composed of delimiters
         call journal('*string_to_values* blank line passed as a list of numbers')
         return
      endif
!----------------------------------------------------------------------------------------------------------------------------------
!     there is at least one non-delimiter sub-string
!     lgth is the column position of the last non-delimiter character
!     now, starting at beginning of string find next non-delimiter
      icol=1                                                     ! pointer to beginning of unprocessed part of LINE
      LOOP: dO i10=1,iread,1                                     ! each pass should find a value
         if(icol.gt.lgth) EXIT LOOP                              ! everything is done
         INFINITE: do
            if(index(delims_local(:delimiters_length),line(icol:icol)).eq.0)then           ! found non-delimiter
               istart=icol
               iend=0                                            ! FIND END OF SUBSTRING
               do i40=istart,lgth                                ! look at each character starting at left
                  if(index(delims_local(:delimiters_length),line(i40:i40)).ne.0)then       ! determine if character is a delimiter
                     iend=i40                                    ! found a delimiter. record where it was found
                     EXIT                                        ! found end of substring so leave loop
                  endif
               enddo
              if(iend.eq.0)iend=lgth+1                           ! no delimiters found, so this substring goes to end of line
               iend=iend-1                                       ! do not want to pass delimiter to be converted
               rval=0.0
               call string_to_value(line(istart:iend),rval,ier)  ! call procedure to convert string to a numeric value
               if(ier.eq.0)then                                  ! a substring was successfully converted to a numeric value
                  values(i10)=rval                               ! store numeric value in return array
                  inums=inums+1                                  ! increment number of values converted to a numeric value
               else                                              ! an error occurred converting string to value
                  ierr=istart                                    ! return starting position of substring that could not be converted
                  return
               endif
               icol=iend+2                                       ! set to next character to look at
               CYCLE LOOP                                        ! start looking for next value
            else                                                 ! this is a delimiter so keep looking for start of next string
               icol=icol+1                                       ! increment pointer into LINE
               CYCLE INFINITE
            endif
         enddo INFINITE
      enddo LOOP
!     error >>>>> more than iread numbers were in the line.
end subroutine string_to_values
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2vs(3f) - [M_strings:NUMERIC] given a string representing numbers
!!      return a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function s2vs(line[,delim])
!!
!!        character(len=*) :: line
!!        doubleprecision,allocatable :: s2vs(:)
!!
!!##DESCRIPTION
!!    The function S2VS(3f) takes a string representing a series of numbers
!!    and converts it to a numeric doubleprecision array. The string values
!!    may be delimited by spaces, semi-colons, and commas by default.
!!
!!##OPTIONS
!!       LINE   Input string containing numbers
!!       DELIM  optional list of delimiter characters. If a space is
!!              included, it should appear as the left-most character
!!              in the list. The default is " ;," (spaces, semi-colons,
!!              and commas).
!!
!!##RESULTS
!!       S2VS   doubleprecision array
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!      program demo_s2vs
!!      use M_strings, only : s2vs
!!      implicit none
!!      character(len=80) :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!      real,allocatable :: values(:)
!!      integer,allocatable :: ivalues(:)
!!      integer :: ii
!!
!!      values=s2vs(s)
!!      ivalues=int(s2vs(s))
!!      call reportit()
!!
!!      contains
!!        subroutine reportit()
!!          write(*,*)'S2VS:'
!!          write(*,*)'input string.............',&
!!           & trim(s)
!!          write(*,*)'number of values found...',&
!!           & size(values)
!!          write(*,*)'values...................',&
!!           & (values(ii),ii=1,size(values))
!!          write(*,'(*(g0,1x))')'ivalues..................',&
!!           & (ivalues(ii),ii=1,size(values))
!!        end subroutine reportit
!!      end program demo_s2vs
!!
!!   Expected output
!!
!!     S2VS:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000 20000.0000 3.45000005
!!     -4.00299978 1234.00000 5678.00000
!!    ivalues.................. 10 20000 3 -4 1234 5678
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function s2vs(string,delim) result(darray)

! ident_57="@(#) M_strings s2vs(3f) function returns array of values from a string"

character(len=*),intent(in)        :: string                       ! keyword to retrieve value for from dictionary
character(len=*),optional          :: delim                        ! delimiter characters
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)                    ! function type

character(len=:),allocatable       :: carray(:)                    ! convert value to an array using split(3f)
integer                            :: i
integer                            :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(string,carray,delimiters=delim_local)         ! split string into an array
   allocate(darray(size(carray)))                           ! create the output array
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)       ! convert the string to a numeric value
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function s2vs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isprint(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     ASCII printable character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isprint(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isprint
!!
!!##DESCRIPTION
!!     isprint(3f) returns .true. if character is an ASCII printable character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isprint  logical value returns true if character is a
!!             printable ASCII character else false.
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_isprint
!!    use M_strings, only : isprint
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISPRINT: ',pack( string, isprint(string) )
!!    end program demo_isprint
!!
!!   Results:
!!
!!    ISPRINT:  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEF
!!    GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn
!!    opqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isprint(onechar)

! ident_58="@(#) M_strings isprint(3f) indicates if input character is a printable ASCII character"

character,intent(in) :: onechar
logical              :: isprint
   select case (onechar)
      case (' ':'~')   ; isprint=.TRUE.
      case default     ; isprint=.FALSE.
   end select
end function isprint
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isgraph(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable character except a space is considered non-printable
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isgraph(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isgraph
!!
!!##DESCRIPTION
!!    isgraph(3f) returns .true. if character is a printable character
!!    except a space is considered non-printable
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isgraph   logical value returns true if character is a printable
!!              non-space character
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!    program demo_isgraph
!!    use M_strings, only : isgraph
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISGRAPH: ',pack( string, isgraph(string) )
!!    end program demo_isgraph
!!
!!   Results:
!!
!!    ISGRAPH: !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFG
!!    HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno
!!    pqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isgraph(onechar)

! ident_59="@(#) M_strings isgraph(3f) indicates if character is printable ASCII character excluding space"

character,intent(in) :: onechar
logical              :: isgraph
   select case (iachar(onechar))
   case (33:126)
     isgraph=.TRUE.
   case default
     isgraph=.FALSE.
   end select
end function isgraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalpha(3f) - [M_strings:COMPARE] returns .true. if character is a
!!    letter and .false. otherwise
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   elemental function isalpha(onechar)
!!
!!    character,intent(in) :: onechar
!!    logical              :: isalpha
!!
!!##DESCRIPTION
!!    isalpha(3f) returns .true. if character is a letter and
!!    .false. otherwise
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isalpha  logical value returns .true. if character is a ASCII letter
!!             or false otherwise.
!!##EXAMPLE
!!
!!
!!   Sample program
!!
!!     program demo_isalpha
!!     use M_strings, only : isalpha
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISGRAPH: ',pack( string, isalpha(string) )
!!     end program demo_isalpha
!!
!!   Results:
!!
!!    ISGRAPH: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm
!!    nopqrstuvwxyz
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function isalpha(ch) result(res)

! ident_60="@(#) M_strings isalpha(3f) Return .true. if character is a letter and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z','a':'z')
     res=.true.
   case default
     res=.false.
   end select
end function isalpha
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isxdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     hexadecimal digit (0-9, a-f, or A-F).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isxdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isxdigit
!!
!!##DESCRIPTION
!!     isxdigit(3f) returns .true. if character is a hexadecimal digit (0-9,
!!     a-f, or A-F).
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isxdigit  logical value returns true if character is a hexadecimal digit
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!     program demo_isxdigit
!!     use M_strings, only : isxdigit
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISXDIGIT: ',pack( string, isxdigit(string) )
!!     end program demo_isxdigit
!!
!!   Results:
!!
!!    ISXDIGIT: 0123456789ABCDEFabcdef
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isxdigit(ch) result(res)

! ident_61="@(#) M_strings isxdigit(3f) returns .true. if c is a hexadecimal digit (0-9 a-f or A-F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'F','a':'f','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isxdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     digit (0,1,...,9) and .false. otherwise
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isdigit
!!
!!##DESCRIPTION
!!     isdigit(3f) returns .true. if character is a digit (0,1,...,9)
!!     and .false. otherwise
!!
!!##EXAMPLES
!!
!!
!!  Sample Program:
!!
!!     program demo_isdigit
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!            & all(isdigit(switch(string(i))).or.&
!!            & isspace(switch(string(i))))
!!        enddo
!!     end program demo_isdigit
!!
!!  Expected output:
!!
!!        For string[1 2 3 4 5 ] T
!!        For string[letters   ] F
!!        For string[1234567890] T
!!        For string[both 8787 ] F
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isdigit(ch) result(res)

! ident_62="@(#) M_strings isdigit(3f) Returns .true. if ch is a digit (0-9) and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isblank(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     blank character (space or horizontal tab).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isblank(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isblank
!!
!!##DESCRIPTION
!!     isblank(3f) returns .true. if character is a blank character (space
!!     or horizontal tab).
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isblank  logical value returns true if character is a "blank"
!!             ( an ASCII  space or horizontal tab character).
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_isblank
!!     use M_strings, only : isblank
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(*(g0,1x))')'ISXBLANK: ',&
!!        & iachar(pack( string, isblank(string) ))
!!     end program demo_isblank
!!
!!   Results:
!!
!!    ISXBLANK:  9 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isblank(ch) result(res)

! ident_63="@(#) M_strings isblank(3f) returns .true. if character is a blank (space or horizontal tab)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ',char(9))
     res=.true.
   case default
     res=.false.
   end select
end function isblank
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isascii(3f) - [M_strings:COMPARE] returns .true. if the character is
!!     in the range char(0) to char(256)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isascii(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isascii
!!
!!##DESCRIPTION
!!     isascii(3f) returns .true. if the character is in the range char(0)
!!     to char(127)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isupper  logical value returns true if character is an ASCII
!!             character.
!!##EXAMPLE
!!
!!  Sample program
!!
!!     program demo_isascii
!!     use M_strings, only : isascii
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,255)]
!!        write(*,'(10(g0,1x))')'ISASCII: ', &
!!        & iachar(pack( string, isascii(string) ))
!!     end program demo_isascii
!!
!!  Results:
!!
!!    ISASCII:  0 1 2 3 4 5 6 7 8
!!    9 10 11 12 13 14 15 16 17 18
!!    19 20 21 22 23 24 25 26 27 28
!!    29 30 31 32 33 34 35 36 37 38
!!    39 40 41 42 43 44 45 46 47 48
!!    49 50 51 52 53 54 55 56 57 58
!!    59 60 61 62 63 64 65 66 67 68
!!    69 70 71 72 73 74 75 76 77 78
!!    79 80 81 82 83 84 85 86 87 88
!!    89 90 91 92 93 94 95 96 97 98
!!    99 100 101 102 103 104 105 106 107 108
!!    109 110 111 112 113 114 115 116 117 118
!!    119 120 121 122 123 124 125 126 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isascii(ch) result(res)

! ident_64="@(#) M_strings isascii(3f) returns .true. if character is in the range char(0) to char(127)"

character,intent(in) :: ch
logical              :: res
   select case(iachar(ch))
   case(0:127)
     res=.true.
   case default
     res=.false.
   end select
end function isascii
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isspace(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     null, space, tab, carriage return, new line, vertical tab, or formfeed
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isspace(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isspace
!!
!!##DESCRIPTION
!!     isspace(3f) returns .true. if character is a null, space, tab,
!!     carriage return, new line, vertical tab, or formfeed
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isspace  returns true if character is ASCII white space
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_isspace
!!     use M_strings, only : isspace
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISSPACE: ', &
!!        & iachar(pack( string, isspace(string) ))
!!     end program demo_isspace
!!
!!   Results:
!!
!!    ISSPACE:  0 9 10 11 12 13 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isspace(ch) result(res)

! ident_65="@(#) M_strings isspace(3f) true if null space tab return new line vertical tab or formfeed"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ')                 ! space(32)
     res=.true.
   case(char(0))             ! null(0)
     res=.true.
   case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13),
     res=.true.
   case default
     res=.false.
   end select
end function isspace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     iscntrl(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     delete character or ordinary control character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function iscntrl(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: iscntrl
!!
!!##DESCRIPTION
!!     iscntrl(3f) returns .true. if character is a delete character or
!!     ordinary control character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    iscntrl  logical value returns true if character is a control character
!!
!!##EXAMPLE
!!
!!  Sample program
!!
!!     program demo_iscntrl
!!     use M_strings, only : iscntrl
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISCNTRL: ', &
!!        & iachar(pack( string, iscntrl(string) ))
!!     end program demo_iscntrl
!!
!!   Results:
!!
!!    ISCNTRL:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
!!    20 21 22 23 24 25 26 27 28 29 30 31 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function iscntrl(ch) result(res)

! ident_66="@(#) M_strings iscntrl(3f) true if a delete or ordinary control character(0x7F or 0x00-0x1F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(char(127),char(0):char(31))
     res=.true.
   case default
     res=.false.
   end select
end function iscntrl
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     ispunct(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable punctuation character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function ispunct(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: ispunct
!!
!!##DESCRIPTION
!!     ispunct(3f) returns .true. if character is a printable punctuation
!!     character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    ispunct  logical value returns true if character is a printable
!!             punctuation character.
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_ispunct
!!     use M_strings, only : ispunct
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & iachar(pack( string, ispunct(string) ))
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & pack( string, ispunct(string) )
!!     end program demo_ispunct
!!   Results:
!!
!!    ISPUNCT:  33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61
!!    62 63 64 91 92 93 94 95 96 123 124 125 126
!!    ISPUNCT:  ! " # $ % & ' ( ) * + , - . / : ; < =
!!    > ? @ [ \ ] ^ _ ` { | } ~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function ispunct(ch) result(res)

! ident_67="@(#) M_strings ispunct(3f) true if a printable punctuation character (isgraph(c)&&!isalnum(c))"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case (char(33):char(47), char(58):char(64), char(91):char(96), char(123):char(126))
     res=.true.
!  case(' ','0':'9','A':'Z','a':'z',char(128):)
!    res=.true.
!  case(char(0):char(31),char(127))
!    res=.true.
   case default
     res=.false.
   end select
end function ispunct
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     fortran_name(3f) - [M_strings:COMPARE] test if string meets criteria
!!     for being a fortran name
!!
!!##SYNOPSIS
!!
!!
!!     elemental function fortran_name(line) result (lout)
!!
!!      character(len=*),intent(in)  :: line
!!      logical                      :: lout
!!
!!##DESCRIPTION
!!     Determines if a string is an allowed Fortran name. To pass the input
!!     string must be composed of 1 to 63 ASCII characters and start with a
!!     letter and be composed entirely of alphanumeric characters [a-zA-Z0-9]
!!     and underscores.
!!
!!##OPTIONS
!!     LINE   input string to test. Leading spaces are significant but
!!            trailing spaces are ignored.
!!
!!##RETURNS
!!     LOUT   a logical value indicating if the input string passed or failed
!!            the test to see if it is a valid Fortran name or not.
!!
!!##EXAMPLE
!!
!!    Sample program
!!
!!      program demo_fortran_name
!!      use M_strings, only : fortran_name
!!      implicit none
!!      character(len=20),parameter :: names(*)=[character(len=20) ::  &
!!       & '_name',         'long_variable_name', 'name_',         &
!!       & '12L',           'a__b__c  ',          'PropertyOfGas', &
!!       & '3%3',           '$NAME',              ' ',             &
!!       & 'Variable-name', 'A',                  'x@x' ]
!!      integer :: i
!!         write(*,'(i3,1x,a20,1x,l1)')&
!!         & (i,names(i),fortran_name(names(i)),i=1,size(names))
!!      end program demo_fortran_name
!!
!!    Results:
!!
!!       1 _name                F
!!       2 long_variable_name   T
!!       3 name_                T
!!       4 12L                  F
!!       5 a__b__c              T
!!       6 PropertyOfGas        T
!!       7 3%3                  F
!!       8 $NAME                F
!!       9                      F
!!      10 Variable-name        F
!!      11 A                    T
!!      12 x@x                  F
elemental function fortran_name(line) result (lout)

! ident_68="@(#) M_strings fortran_name(3f) Return .true. if name is a valid Fortran name"

! determine if a string is a valid Fortran name ignoring trailing spaces (but not leading spaces)
character(len=*),parameter   :: int='0123456789'
character(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'
character(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
character(len=*),parameter   :: allowed=upper//lower//int//'_'

character(len=*),intent(in)  :: line
character(len=:),allocatable :: name
logical                      :: lout
   name=trim(line)
   if(len(name).ne.0)then
      lout = verify(name(1:1), lower//upper) == 0  &
       & .and. verify(name,allowed) == 0           &
       & .and. len(name) <= 63
   else
      lout = .false.
   endif
end function fortran_name
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isupper(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     uppercase letter (A-Z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isupper(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isupper
!!
!!##DESCRIPTION
!!     isupper(3f) returns .true. if character is an uppercase letter (A-Z)
!!
!!##OPTIONS
!!    onechar  character to test
!!##RETURNS
!!    isupper  logical value returns true if character is an uppercase
!!             ASCII character else false.
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_isupper
!!     use M_strings, only : isupper
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & iachar(pack( string, isupper(string) ))
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & pack( string, isupper(string) )
!!     end program demo_isupper
!!
!!  Results:
!!
!!    ISUPPER:  65 66 67 68 69 70 71 72 73
!!    74 75 76 77 78 79 80 81 82 83
!!    84 85 86 87 88 89 90
!!    ISUPPER:  A B C D E F G H I
!!    J K L M N O P Q R S
!!    T U V W X Y Z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
pure elemental function isupper(ch) result(res)

! ident_69="@(#) M_strings isupper(3f) returns true if character is an uppercase letter (A-Z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z')
     res=.true.
   case default
     res=.false.
   end select
end function isupper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     islower(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     miniscule letter (a-z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function islower(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: islower
!!
!!##DESCRIPTION
!!     islower(3f) returns .true. if character is a miniscule letter (a-z)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    islowe  logical value returns true if character is a lowercase
!!             ASCII character else false.
!!##EXAMPLE
!!
!!  Sample program
!!
!!     program demo_islower
!!     use M_strings, only : islower
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & iachar(pack( string, islower(string) ))
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & pack( string, islower(string) )
!!     end program demo_islower
!!   Results:
!!
!!    ISLOWER:  97 98 99 100 101 102 103 104 105 106 107 108 109 110
!!    111 112 113 114 115 116 117 118 119 120 121 122
!!    ISLOWER:  a b c d e f g h i j k l m n
!!    o p q r s t u v w x y z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function islower(ch) result(res)

! ident_70="@(#) M_strings islower(3f) returns true if character is a miniscule letter (a-z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('a':'z')
     res=.true.
   case default
     res=.false.
   end select
end function islower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalnum,isalpha,iscntrl,isdigit,isgraph,islower,
!!    isprint,ispunct,isspace,isupper,
!!    isascii,isblank,isxdigit(3f) - [M_strings:COMPARE] test membership in
!!    subsets of ASCII set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Where "FUNCNAME" is one of the function names in the group, the
!!    functions are defined by
!!
!!     elemental function FUNCNAME(onechar)
!!     character,intent(in) :: onechar
!!     logical              :: FUNC_NAME
!!##DESCRIPTION
!!
!!       These elemental functions test if a character belongs to various
!!       subsets of the ASCII character set.
!!
!!       isalnum    returns .true. if character is a letter (a-z,A-Z)
!!                  or digit (0-9)
!!       isalpha    returns .true. if character is a letter and
!!                  .false. otherwise
!!       isascii    returns .true. if character is in the range char(0)
!!                  to char(127)
!!       isblank    returns .true. if character is a blank (space or
!!                  horizontal tab).
!!       iscntrl    returns .true. if character is a delete character or
!!                  ordinary control character (0x7F or 0x00-0x1F).
!!       isdigit    returns .true. if character is a digit (0,1,...,9)
!!                  and .false. otherwise
!!       isgraph    returns .true. if character is a printable ASCII
!!                  character excluding space
!!       islower    returns .true. if character is a miniscule letter (a-z)
!!       isprint    returns .true. if character is a printable ASCII character
!!       ispunct    returns .true. if character is a printable punctuation
!!                  character (isgraph(c) && !isalnum(c)).
!!       isspace    returns .true. if character is a null, space, tab,
!!                  carriage return, new line, vertical tab, or formfeed
!!       isupper    returns .true. if character is an uppercase letter (A-Z)
!!       isxdigit   returns .true. if character is a hexadecimal digit
!!                  (0-9, a-f, or A-F).
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isdigit
!!
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!           all(isdigit(switch(string(i))) .or. &
!!           & isspace(switch(string(i))))
!!        enddo
!!
!!     end program demo_isdigit
!!
!!   Expected output:
!!
!!    For string[1 2 3 4 5 ] T
!!    For string[letters   ] F
!!    For string[1234567890] T
!!    For string[both 8787 ] F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental function isalnum(ch) result(res)

! ident_71="@(#) M_strings isalnum(3f) returns true if character is a letter (a-z A-Z) or digit(0-9)"

character,intent(in)       :: ch
logical                    :: res
   select case(ch)
   case('a':'z','A':'Z','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isalnum
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base(3f) - [M_strings:BASE] convert whole number string in base [2-36]
!!    to string in alternate base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function base(x,b,y,a)
!!
!!    character(len=*),intent(in)  :: x
!!    character(len=*),intent(out) :: y
!!    integer,intent(in)           :: b,a
!!##DESCRIPTION
!!
!!    Convert a numeric string from base B to base A. The function returns
!!    FALSE if B is not in the range [2..36] or if string X contains invalid
!!    characters in base B or if result Y is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    x   input string representing numeric whole value
!!    b   assumed base of input string
!!    y   output string
!!    a   base specified for output string
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_base
!!    use M_strings, only : base
!!    implicit none
!!    integer           :: ba,bd
!!    character(len=40) :: x,y
!!
!!    print *,' BASE CONVERSION'
!!    write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!    write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!    INFINITE: do
!!       write(*,'("Enter number in start base (0 to quit): ")',advance='no')
!!       read *, x
!!       if(x.eq.'0') exit INFINITE
!!       if(base(x,bd,y,ba))then
!!            write(*,'("In base ",I2,": ",A20)')  ba, y
!!        else
!!          print *,'Error in decoding/encoding number.'
!!        endif
!!     enddo INFINITE
!!
!!     end program demo_base
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
logical function base(x,b,y,a)
implicit none
character(len=*),intent(in)  :: x
character(len=*),intent(out) :: y
integer,intent(in)           :: b,a
integer                      :: temp

! ident_72="@(#) M_strings base(3f) convert whole number string in base [2-36] to string in alternate base [2-36]"

base=.true.
if(decodebase(x,b,temp)) then
   if(codebase(temp,a,y)) then
   else
      print *,'Error in coding number.'
      base=.false.
   endif
else
   print *,'Error in decoding number.'
   base=.false.
endif

end function base
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base2(3f) - [M_strings:BASE] convert whole number to string in base 2
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function base2(int)
!!
!!    integer,intent(in)           :: int
!!    character(len=:),allocatable :: base2
!!##DESCRIPTION
!!
!!    Convert a whole number to a string in base 2.
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    int   input string representing numeric whole value
!!##RETURNS
!!    base2   string representing input value in base 2
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_base2
!!    use M_strings, only : base2
!!    implicit none
!!       write(*,'(a)') base2(huge(0))
!!       write(*,'(a)') base2(0)
!!       write(*,'(a)') base2(1-huge(0))
!!    end program demo_base2
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
! 0 in binary: 0
! 42 in binary: 101010
! huge(int) in binary: 1111111111111111111111111111111
! 032 in binary is 100000
! itimes=10000000
!      G_TRICK=base2_f(32)   <BASE2_F  >Processor Time =  0.766 seconds.
!      G_TRICK=base2_fdo(32) <BASE2_FDO>Processor Time =  0.958 seconds.
!      G_TRICK=base2_a(32)   <BASE2_A  >Processor Time =  1.022 seconds.
!      G_TRICK=base2_c(32)   <BASE2_C  >Processor Time =  7.208 seconds.
!      G_TRICK=empty(32)     <EMPTY    >Processor Time =  0.132 seconds.
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function base2(x) result(str)
!  return string representing number as a binary number.  Fixed-length string:
integer, intent(in) :: x
integer           :: i
character(len=max(1,bit_size(x)-leadz(x))) :: str
    associate(n => len(str))
      str = repeat('0',n)
      do i = 0,n-1
        if (btest(x,i)) str(n-i:n-i) = '1'
      end do
    end associate
end function base2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function base2_fdo(x) result(str)
!  return string representing number as a binary number.  Fixed-length string: do concurrent
integer, intent(in) :: x
character(len=max(1,bit_size(x)-leadz(x))) :: str

integer :: n, i

    if (x == 0) then
      str(1:1) = '0'
      return
    endif
    n = len(str)
    str = repeat('0',n)
    do concurrent (i = 0:n-1, btest(x,i))
      str(n-i:n-i) = '1'
    end do
end function base2_fdo
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function base2_a(x) result(str)
!  return string representing number as a binary number. Allocatable-length string:
integer, intent(in) :: x
character(len=:), allocatable :: str

integer :: n, i

    n = max(1,bit_size(x)-leadz(x))
    allocate(character(len=n) :: str)
    if (x == 0) then
      str(1:1) = '0'
      return
    endif

    str = repeat('0',n)
    do concurrent (i = 0:n-1, btest(x,i))
      str(n-i:n-i) = '1'
    end do
end function base2_a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function base2_c(x) result(str)
! internal write
integer, intent(in) :: x
character(len=max(1,bit_size(x)-leadz(x))) :: str
    write( str, fmt="(b0)" ) x
end function base2_c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    decodebase(3f) - [M_strings:BASE] convert whole number string in base
!!    [2-36] to base 10 number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function decodebase(string,basein,out10)
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in)           :: basein
!!    integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!    Convert a numeric string representing a whole number in base BASEIN
!!    to base 10. The function returns FALSE if BASEIN is not in the range
!!    [2..36] or if string STRING contains invalid characters in base BASEIN
!!    or if result OUT10 is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_decodebase
!!    use M_strings, only : codebase, decodebase
!!    implicit none
!!    integer           :: ba,bd
!!    character(len=40) :: x,y
!!    integer           :: r
!!
!!    print *,' BASE CONVERSION'
!!    write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!    write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!    INFINITE: do
!!       print *,''
!!       write(*,'("Enter number in start base: ")',advance='no'); read *, x
!!       if(x.eq.'0') exit INFINITE
!!       if(decodebase(x,bd,r)) then
!!          if(codebase(r,ba,y)) then
!!            write(*,'("In base ",I2,": ",A20)')  ba, y
!!          else
!!            print *,'Error in coding number.'
!!          endif
!!       else
!!          print *,'Error in decoding number.'
!!       endif
!!    enddo INFINITE
!!
!!    end program demo_decodebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function decodebase(string,basein,out_baseten)
implicit none

! ident_73="@(#) M_strings decodebase(3f) convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein.eq.0.and.ipound.gt.1)then                                  ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local.ge.0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch.eq.'-'.and.k.eq.1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    codebase(3f) - [M_strings:BASE] convert whole number in base 10 to
!!    string in base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function codebase(in_base10,out_base,answer)
!!
!!    integer,intent(in)           :: in_base10
!!    integer,intent(in)           :: out_base
!!    character(len=*),intent(out) :: answer
!!
!!##DESCRIPTION
!!    Convert a number from base 10 to base OUT_BASE. The function returns
!!    .FALSE. if OUT_BASE is not in [2..36] or if number IN_BASE10 is
!!    too big.
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_codebase
!!    use M_strings, only : codebase
!!    implicit none
!!    character(len=20) :: answer
!!    integer           :: i, j
!!    logical           :: ierr
!!    do j=1,100
!!       do i=2,36
!!          ierr=codebase(j,i,answer)
!!          write(*,*)'VALUE=',j,' BASE=',i,' ANSWER=',answer
!!       enddo
!!    enddo
!!    end program demo_codebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!     Ref.: "Math matiques en Turbo-Pascal by
!!            M. Ducamp and A. Reverchon (2),
!!            Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function codebase(inval10,outbase,answer)
implicit none

! ident_74="@(#) M_strings codebase(3f) convert whole number in base 10 to string in base [2-36]"

integer,intent(in)           :: inval10
integer,intent(in)           :: outbase
character(len=*),intent(out) :: answer
integer                      :: n
real                         :: inval10_local
integer                      :: outbase_local
integer                      :: in_sign
  answer=''
  in_sign=sign(1,inval10)*sign(1,outbase)
  inval10_local=abs(inval10)
  outbase_local=abs(outbase)
  if(outbase_local<2.or.outbase_local>36) then
    print *,'*codebase* ERROR: base must be between 2 and 36. base was',outbase_local
    codebase=.false.
  else
     do while(inval10_local>0.0 )
        n=INT(inval10_local-outbase_local*INT(inval10_local/outbase_local))
        if(n<10) then
           answer=ACHAR(IACHAR('0')+n)//answer
        else
           answer=ACHAR(IACHAR('A')+n-10)//answer
        endif
        inval10_local=INT(inval10_local/outbase_local)
     enddo
     codebase=.true.
  endif
  if(in_sign.eq.-1)then
     answer='-'//trim(answer)
  endif
  if(answer.eq.'')then
     answer='0'
  endif
end function codebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function todecimal(base, instr)

! ident_75="@(#) M_strings todecimal(3f) given string and base return decimal integer"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
character(*),intent(in)      :: instr
character(len=:),allocatable :: instr_local
integer                      :: todecimal
integer                      :: length, i, n

   instr_local=trim(lower(instr))
   todecimal = 0
   length = len(instr_local)
   do i = 1, length
      n = index(alphanum, instr_local(i:i)) - 1
      n = n * base**(length-i)
      todecimal = todecimal + n
   enddo
end function todecimal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function tobase(base, number)

! ident_76="@(#) M_strings tobase(3f) given integer and base return string"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
integer,intent(in)           :: number
character(len=:),allocatable :: tobase
character(len=31)            :: holdit
integer                      :: number_local, i, rem
   number_local=number

   holdit = "                               "
   do i = 31, 1, -1
      if(number_local < base) then
         holdit(i:i) = alphanum(number_local+1:number_local+1)
         exit
      endif
      rem = mod(number_local, base)
      holdit(i:i) = alphanum(rem+1:rem+1)
      number_local = number_local / base
   enddo
   tobase = adjustl(holdit)
end function tobase

!SUBROUTINE DectoBase(decimal, string, base)
! CHARACTER string
!    string = '0'
!    temp = decimal
!    length = CEILING( LOG(decimal+1, base) )   !<<<<<<<< INTERESTING
!    DO i = length, 1, -1
!      n = MOD( temp, base )
!      string(i) = "0123456789abcdefghijklmnopqrstuvwxyz"(n+1)
!      temp = INT(temp / base)
!    ENDDO
! END
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    paragraph(3f) - [M_strings:TOKENS] break a long line into a paragraph
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function paragraph(source_string,length)
!!
!!    character(len=*),intent(in)       :: source_string
!!    integer,intent(in)                :: length
!!    character(allocatable(len=length)    :: paragraph(:)
!!
!!##DESCRIPTION
!!    paragraph(3f) breaks a long line into a simple paragraph of specified
!!    line length.
!!
!!    Given a long string break it on spaces into an array such that no
!!    variable is longer than the specified length. Individual words longer
!!    than LENGTH will be placed in variables by themselves.
!!
!!##OPTIONS
!!     SOURCE_STRING  input string to break into an array of shorter strings
!!                    on blank delimiters
!!     LENGTH         length of lines to break the string into.
!!
!!##RETURNS
!!     PARAGRAPH  character array filled with data from source_string
!!                broken at spaces into variables of length LENGTH.
!!
!!##EXAMPLE
!!
!!  sample program
!!
!!    program demo_paragraph
!!    use M_strings, only : paragraph
!!    implicit none
!!    character(len=:),allocatable :: paragrph(:)
!!    character(len=*),parameter    :: string= '&
!!     &one two three four five &
!!     &six seven eight &
!!     &nine ten eleven twelve &
!!     &thirteen fourteen fifteen sixteen &
!!     &seventeen'
!!
!!    write(*,*)'LEN=',len(string)
!!    write(*,*)'INPUT:'
!!    write(*,*)string
!!
!!    paragrph=paragraph(string,40)
!!    write(*,*)'LEN=',len(paragrph),' SIZE=',size(paragrph)
!!    write(*,*)'OUTPUT:'
!!    write(*,'(a)')paragrph
!!
!!    write(*,'(a)')paragraph(string,0)
!!    write(*,'(3x,a)')paragraph(string,47)
!!
!!    end program demo_paragraph
!!
!!   Results:
!!
!!     LEN=         106
!!     INPUT:
!!     one two three four five six seven eight nine ten eleven twelve
!!     thirteen fourteen fifteen sixteen seventeen
!!     LEN=          40  SIZE=           3
!!     OUTPUT:
!!    one two three four five six seven eight
!!    nine ten eleven twelve thirteen fourteen
!!    fifteen sixteen seventeen
!!    one
!!    two
!!    three
!!    four
!!    five
!!    six
!!    seven
!!    eight
!!    nine
!!    ten
!!    eleven
!!    twelve
!!    thirteen
!!    fourteen
!!    fifteen
!!    sixteen
!!    seventeen
!!       one two three four five six seven eight nine
!!       ten eleven twelve thirteen fourteen fifteen
!!       sixteen seventeen
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function paragraph(source_string,length)

! ident_77="@(#) M_strings paragraph(3f) wrap a long string into a paragraph"

character(len=*),intent(in)       :: source_string
integer,intent(in)                :: length
integer                           :: itoken
integer                           :: istart
integer                           :: iend
character(len=*),parameter        :: delimiters=' '
character(len=:),allocatable      :: paragraph(:)
integer                           :: ilines
integer                           :: ilength
integer                           :: iword, iword_max
integer                           :: i
!-----------------------------------------------------------------------------------------------------------------------------------
!  parse string once to find out how big to make the returned array, then redo everything but store the data
!  could store array of endpoints and leave original whitespace alone or many other options
   do i=1,2
      iword_max=0                                  ! length of longest token
      ilines=1                                     ! number of output line output will go on
      ilength=0                                    ! length of output line so far
      itoken=0                                     ! must set ITOKEN=0 before looping on strtok(3f) on a new string.
      do while ( strtok(source_string,itoken,istart,iend,delimiters) )
         iword=iend-istart+1
         iword_max=max(iword_max,iword)
         if(iword.gt.length)then                   ! this token is longer than the desired line length so put it on a line by itself
            if(ilength.ne.0)then
               ilines=ilines+1
            endif
            if(i.eq.2)then     ! if paragraph has been allocated store data, else just gathering data to determine size of paragraph
               paragraph(ilines)=source_string(istart:iend)//' '
            endif
            ilength=iword+1
         elseif(ilength+iword.le.length)then       ! this word will fit on current line
            if(i.eq.2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(istart:iend)
            endif
            ilength=ilength+iword+1
         else                                      ! adding this word would make line too long so start new line
            ilines=ilines+1
            ilength=0
            if(i.eq.2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(istart:iend)
            endif
            ilength=iword+1
         endif
      enddo
      if(i==1)then                                 ! determined number of lines needed so allocate output array
         allocate(character(len=max(length,iword_max)) :: paragraph(ilines))
         paragraph=' '
      endif
   enddo
   paragraph=paragraph(:ilines)
end function paragraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function setbits8(string) result(answer)
use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit
implicit none
integer(kind=int8)          :: answer
character(len=8),intent(in) :: string
integer                     :: pos
integer                     :: lgth
   answer=0_int8
   lgth=len(string)
   if(lgth.ne.bit_size(answer))then
      write(stderr,*)'*setbits8* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,lgth
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits8* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits8
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits16(string) result(answer)
use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit
implicit none
integer(kind=int16)          :: answer
character(len=16),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int16
   lgth=len(string)
   if(lgth.ne.bit_size(answer))then
      write(stderr,*)'*setbits16* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits16* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits16
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits32(string) result(answer)
use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit
implicit none
integer(kind=int32)          :: answer
character(len=32),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int32
   lgth=len(string)
   if(lgth.ne.bit_size(answer))then
      write(stderr,*)'*setbits32* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits32* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits32
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits64(string) result(answer)
use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit
implicit none
integer(kind=int64)          :: answer
character(len=64),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int64
   lgth=len(string)
   if(lgth.ne.bit_size(answer))then
      write(stderr,*)'*setbits64* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits64* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     msg(3f) - [M_strings] converts any standard scalar type to a string
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!     function msg(g1,g2g3,g4,g5,g6,g7,g8,g9,sep)
!!
!!      class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!      character(len=*),intent(in),optional :: sep
!!      character(len=:),allocatable :: msg
!!
!!##DESCRIPTION
!!     msg(3f) builds a space-separated string from up to nine scalar values.
!!
!!##OPTIONS
!!     g[1-9]  optional value to print the value of after the message. May
!!             be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!             or CHARACTER.
!!     sep     separator between values. Defaults to a space
!!
!!##RETURNS
!!     msg     description to print
!!
!!##EXAMPLES
!!
!!
!!   Sample program:
!!
!!        program demo_msg
!!        use M_strings, only : msg
!!        implicit none
!!        character(len=:),allocatable :: pr
!!        character(len=:),allocatable :: frmt
!!        integer                      :: biggest
!!
!!        pr=msg('HUGE(3f) integers',huge(0),&
!!        & 'and real',huge(0.0),'and double',huge(0.0d0))
!!        write(*,'(a)')pr
!!        pr=msg('real            :',&
!!         & huge(0.0),0.0,12345.6789,tiny(0.0) )
!!        write(*,'(a)')pr
!!        pr=msg('doubleprecision :',&
!!         & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!        write(*,'(a)')pr
!!        pr=msg('complex         :',&
!!         & cmplx(huge(0.0),tiny(0.0)) )
!!        write(*,'(a)')pr
!!
!!        ! create a format on the fly
!!        biggest=huge(0)
!!        frmt=msg('(*(i',int(log10(real(biggest))),':,1x))',sep='')
!!        write(*,*)'format=',frmt
!!
!!        ! although it will often work, using msg(3f) in an I/O statement
!!        ! is not recommended
!!        write(*,*)msg('program will now stop')
!!
!!        end program demo_msg
!!
!!   Output
!!
!!       HUGE(3f) integers 2147483647 and real 3.40282347E+38
!!       and double 1.7976931348623157E+308
!!       real            : 3.40282347E+38 0.00000000
!!       12345.6787 1.17549435E-38
!!       doubleprecision : 1.7976931348623157E+308 0.0000000000000000
!!       12345.678900000001 2.2250738585072014E-308
!!       complex         : (3.40282347E+38,1.17549435E-38)
!!        format=(*(i9:,1x))
!!        program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function msg_scalar(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none

! ident_78="@(#) M_strings msg_scalar(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: generic1 ,generic2 ,generic3 ,generic4 ,generic5
class(*),intent(in),optional  :: generic6 ,generic7 ,generic8 ,generic9
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_scalar=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
      !x!type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
      !x!type is (real(kind=real256));     write(line(istart:),'(1pg0)') generic
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function msg_one(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none

! ident_79="@(#) M_strings msg_one(3fp) writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)           :: generic1(:)
class(*),intent(in),optional  :: generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable   :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real256));     write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//"]"//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split2020(3f) - parse a string into tokens
!!
!!##SYNOPSIS
!!
!!   TOKEN form
!!
!!    subroutine split2020 (string, set, tokens, separator)
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    character(len=:),allocatable,intent(out) :: tokens(:)
!!    character(len=1),allocatable,intent(out),optional :: separator(:)
!!
!!   BOUNDS ARRAY form
!!
!!    subroutine split2020 (string, set, first, last)
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    integer,allocatable,intent(out) :: first(:)
!!    integer,allocatable,intent(out) :: last(:)
!!
!!   STEP THROUGH BY POSITION form
!!
!!    subroutine split2020 (string, set, pos [, back])
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    integer,intent(inout)       :: pos
!!    logical,intent(in),optional :: back
!!
!!##DESCRIPTION
!!    Parse a string into tokens. STRING, SET, TOKENS and SEPARATOR must
!!    all be of the same CHARACTER kind type parameter.
!!
!!##OPTIONS
!!    STRING      string to break into tokens
!!
!!    SET         Each character in SET is a token delimiter. A
!!                sequence of zero or more characters in STRING delimited by
!!                any token delimiter, or the beginning or end of STRING,
!!                comprise a token. Thus, two consecutive token delimiters
!!                in STRING, or a token delimiter in the first or last
!!                character of STRING, indicate a token with zero length.
!!
!!                ??? how about if null defaults to all whitespace characters
!!
!!    TOKENS      It is allocated with the lower bound equal to
!!                one and the upper bound equal to the number of tokens in
!!                STRING, and with character length equal to the length of
!!                the longest token. The tokens in STRING are assigned by
!!                intrinsic assignment, in the order found, to the elements
!!                of TOKENS, in array element order.
!!
!!                ???If input is null it still must be of size 1?
!!
!!    SEPARATOR   Each element in SEPARATOR(i) is assigned the value of
!!                the ith token delimiter in STRING.
!!                It is allocated with the lower bound equal to
!!                one and the upper bound equal to one less than the number
!!                of tokens in STRING, and with character length equal to
!!                one.
!!
!!                ???one less than? '' ' '
!!
!!    FIRST     It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the starting
!!              position of each token in STRING, in the order found. If a
!!              token has zero length, the starting position is equal to one
!!              if the token is at the beginning of STRING, and one greater
!!              than the position of the preceding delimiter otherwise.
!!
!!    LAST      It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the ending
!!              position of each token in STRING, in the order found. If
!!              a token has zero length, the ending position is one less
!!              than the starting position.
!!
!!    POS       If BACK is present with the value .TRUE., the value
!!              of POS shall be in the range 0 < POS     LEN (STRING)+1;
!!              otherwise it shall be in the range 0     POS LEN (STRING).
!!
!!              If BACK is absent or is present with the value .FALSE., POS
!!              is assigned the position of the leftmost token delimiter in
!!              STRING whose position is greater than POS, or if there is
!!              no such character, it is assigned a value one greater than
!!              the length of STRING. This identifies a token with starting
!!              position one greater than the value of POS on invocation,
!!              and ending position one less than the value of POS on return.
!!
!!              If BACK is present with the value true, POS is assigned the
!!              position of the rightmost token delimiter in STRING whose
!!              position is less than POS, or if there is no such character,
!!              it is assigned the value zero. This identifies a token with
!!              ending position one less than the value of POS on invocation,
!!              and starting position one greater than the value of POS
!!              on return.
!!
!!              When SPLIT is invoked with a value for POS of
!!              1 <= POS <= LEN(STRING) and STRING(POS:POS) is not a
!!              token delimiter present in SET, the token identified by
!!              SPLIT does not comprise a complete token as described in the
!!              description of the SET argument, but rather a partial token.
!!
!!    BACK      shall be a logical scalar. It is an INTENT (IN) argument. If
!!              POS does not appear and BACK is present with the value true,
!!              STRING is scanned backwards for tokens starting from the
!!              end. If POS does not appear and BACK is absent or present
!!              with the value false, STRING is scanned forwards for tokens
!!              starting from the beginning.
!!
!!##EXAMPLES
!!
!! Sample of uses
!!
!!    program demo_sort2020
!!    use M_strings, only : split2020
!!    implicit none
!!    character(len=*),parameter :: gen='(*("[",g0,"]":,","))'
!!
!!     ! Execution of TOKEN form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=:), allocatable :: tokens(:)
!!       character (len=*),parameter :: set = " ,"
!!       string = 'first,second,third'
!!       call split2020(string, set, tokens )
!!       write(*,gen)tokens
!!
!!     ! assigns the value ['first ','second','third ' ]
!!     ! to TOKENS.
!!     endblock
!!
!!     ! Execution of BOUNDS form
!!
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer, allocatable        :: first(:), last(:)
!!       string =    'first,second,,forth'
!!       call split2020 (string, set, first, last)
!!       write(*,gen)first
!!       write(*,gen)last
!!
!!     ! will assign the value [ 1, 7, 14, 15 ] to FIRST,
!!     ! and the value [ 5, 12, 13, 19 ] to LAST.
!!     endblock
!!
!!     ! Execution of STEP form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer :: p, istart, iend
!!       string = " one,   last  example  "
!!       do while (p < len(string))
!!         istart = p + 1
!!         call split2020 (string, set, p)
!!         iend=p-1
!!         if(iend.gt.istart)then
!!            print '(t3,a,1x,i0,1x,i0)', string (istart:iend),istart,iend
!!         endif
!!       enddo
!!     endblock
!!    end program demo_sort2020
!!
!!   Results:
!!
!!    [first ],[second],[third ]
!!    [1],[7],[14],[15]
!!    [5],[12],[13],[19]
!!      one 2 4
!!      last 9 12
!!      example 15 21
!!
!!      > ??? option to skip adjacent delimiters (not return null tokens)
!!      >     common with whitespace
!!      > ??? quoted strings, especially CSV both " and ', Fortran adjacent
!!      >     is insert versus other rules
!!      > ??? escape character like \\ .
!!      > ??? multi-character delimiters like \\n, \\t,
!!      > ??? regular expression separator
!!
!!##AUTHOR
!!    Milan Curcic, "milancurcic@hey.com"
!!
!!##LICENSE
!!    MIT
!!
!!##VERSION
!!    version 0.1.0, copyright 2020, Milan Curcic
  pure subroutine split_tokens(string, set, tokens, separator)
     ! Splits a string into tokens using characters in set as token delimiters.
     ! If present, separator contains the array of token delimiters.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    character(:), allocatable, intent(out) :: tokens(:)
    character, allocatable, intent(out), optional :: separator(:)

    integer, allocatable :: first(:), last(:)
    integer :: n

    call split2020(string, set, first, last)
    allocate(character(len=maxval(last - first) + 1) :: tokens(size(first)))

    do concurrent (n = 1:size(tokens))
      tokens(n) = string(first(n):last(n))
    enddo

    if (present(separator)) then
      allocate(separator(size(tokens) - 1))
      do concurrent (n = 1:size(tokens) - 1)
        separator(n) = string(first(n+1)-1:first(n+1)-1)
      enddo
    endif

  end subroutine split_tokens
!===================================================================================================================================
  pure subroutine split_first_last(string, set, first, last)
     ! Computes the first and last indices of tokens in input string, delimited
     ! by the characters in set, and stores them into first and last output
     ! arrays.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    integer, allocatable, intent(out) :: first(:)
    integer, allocatable, intent(out) :: last(:)

    character :: set_array(len(set))
    logical, dimension(len(string)) :: is_first, is_last, is_separator
    integer :: n, slen

    slen = len(string)

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    do concurrent (n = 1:slen)
      is_separator(n) = any(string(n:n) == set_array)
    enddo

    is_first = .false.
    is_last = .false.

    if (.not. is_separator(1)) is_first(1) = .true.

    do concurrent (n = 2:slen-1)
      if (.not. is_separator(n)) then
        if (is_separator(n - 1)) is_first(n) = .true.
        if (is_separator(n + 1)) is_last(n) = .true.
      else
        if (is_separator(n - 1)) then
          is_first(n) = .true.
          is_last(n-1) = .true.
        endif
      endif
    enddo

    if (.not. is_separator(slen)) is_last(slen) = .true.

    first = pack([(n, n = 1, slen)], is_first)
    last = pack([(n, n = 1, slen)], is_last)

  end subroutine split_first_last
!===================================================================================================================================
  pure subroutine split_pos(string, set, pos, back)
     ! If back is absent, computes the leftmost token delimiter in string whose
     ! position is > pos. If back is present and true, computes the rightmost
     ! token delimiter in string whose position is < pos. The result is stored
     ! in pos.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    integer, intent(in out) :: pos
    logical, intent(in), optional :: back

    logical :: backward
    character :: set_array(len(set))
    integer :: n, result_pos

    !TODO use optval when implemented in stdlib
    !backward = optval(back, .false.)
    backward = .false.
    if (present(back)) backward = back

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    if (backward) then
      result_pos = 0
      do n = pos - 1, 1, -1
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    else
      result_pos = len(string) + 1
      do n = pos + 1, len(string)
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    endif

    pos = result_pos

  end subroutine split_pos
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
  pure function string_tokens(string, set) result(tokens)
     ! Splits a string into tokens using characters in set as token delimiters.
    character(*), intent(in) :: string
    character(*), intent(in) :: set
    character(:), allocatable :: tokens(:)
    call split_tokens(string, set, tokens)
  end function string_tokens
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! Duplicate the M_journal module in condensed form for now so can be stand-alone on GITHUB
!                                                                     ll
!                                                                      l
!    j                                                                 l
!                                                                      l
!    j                                                                 l
!    j        oooooo    u      u   r rrrrrr   n nnnnn      aaaa        l
!    j       o      o   u      u   rr         nn     n         a       l
!    j       o      o   u      u   r          n      n    aaaaaa       l
! j  j       o      o   u      u   r          n      n   a     a       l
!  jj         oooooo     uuuuuu u  r          n      n    aaaaa a      l
!
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! @(#) place-holder for journal module
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)

!@(#) M_journal::where_write_message(3fp): basic message routine used for journal files

character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O

character(len=:),allocatable,save  :: prefix_template   ! string to run thru now_ex(3f) to make prefix
character(len=:),allocatable       :: prefix            ! the prefix string to add to output
logical,save                       :: prefix_it=.false. ! flag whether time prefix mode is on or not
character(len=4096)                :: mssge
!-----------------------------------------------------------------------------------------------------------------------------------
   adv='yes'
!-----------------------------------------------------------------------------------------------------------------------------------
   prefix=''
!-----------------------------------------------------------------------------------------------------------------------------------
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
          !elseif(times.eq.0)then
          !   write(stdout,'(a)',advance=adv)prefix//trim(msg)
          !   times=times+1
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('S','s')
         write(stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('+'); adv='no'
      !-----------------------------------------------------------------------------------------------------------------------------
      case('>'); debug=.true.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('<'); debug=.false.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('%')                       ! setting timestamp prefix
         if(msg.eq.'')then            ! if message is blank turn off prefix
            prefix_it=.false.
         else                         ! store message as string to pass to now_ex() on subsequent calls to make prefix
            prefix_template=msg
            prefix_it=.true.
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('N')                                                   ! new name for stdout
         if(msg.ne.' '.and.msg.ne.'#N#'.and.msg.ne.'"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios.eq.0)then
               stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg.eq.' ')then
            close(unit=last_int,iostat=ios)
            stdout=6
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times.eq.0)then
             ! write(stdout,'(2a)',advance=adv)prefix,trim(msg)
             ! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times.eq.0)then
               write(stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios.ne.0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg.ne.'')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg.ne.'')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine where_write_message
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine flush_trail()
call where_write_message('F','IGNORE THIS STRING')
end subroutine flush_trail
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine set_stdout_lun(iounit)
integer,intent(in)                   :: iounit
   stdout=iounit
end subroutine set_stdout_lun
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message_all(where, g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,nospace)
implicit none

!$(#) M_journal::where_write_message_all(3f): writes a message to a string composed of any standard scalar types

character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
logical,intent(in),optional   :: nospace
 !call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,nospace))
end subroutine where_write_message_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine write_message_only(message)

!$(#) M_journal::write_message_only(3fp): calls JOURNAL('sc',message)

character(len=*),intent(in)          :: message
!-----------------------------------------------------------------------------------------------------------------------------------
   call where_write_message('sc',trim(message))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine write_message_only
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function str_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
implicit none
class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:), allocatable :: str_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
character(len=:),allocatable  :: sep_local
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=''
   if(present(generic0))call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   str_scalar=trim(line)
contains
!===================================================================================================================================
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
      !x!type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
      !x!type is (real(kind=real256));     write(line(istart:),'(1pg0)') generic
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic

end function str_scalar
!===================================================================================================================================
function str_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none
class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: str_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   str_one=trim(line)
contains

subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
      !x!type is (real(kind=real256));     write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         stop 'unknown type in *print_generic*'
   end select
   line=trim(line)//"]"//sep_local
   istart=len_trim(line)+increment
end subroutine print_generic

end function str_one
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function lowercase(str) result(lcstr)

! convert string to lower case leaving quoted strings as is

character (len=*):: str
character (len=len_trim(str)):: lcstr
integer :: lgth
integer :: ioffset
integer :: iquote
integer :: i
integer :: iav
integer :: iqc

lgth=len_trim(str)
ioffset=iachar('A')-iachar('a')
iquote=0
lcstr=str
do i=1,lgth
  iav=iachar(str(i:i))
  if(iquote==0 .and. (iav==34 .or.iav==39)) then
    iquote=1
    iqc=iav
    cycle
  endif
  if(iquote==1 .and. iav==iqc) then
    iquote=0
    cycle
  endif
  if (iquote==1) cycle
  if(iav >= iachar('A') .and. iav <= iachar('Z')) then
    lcstr(i:i)=achar(iav-ioffset)
  else
    lcstr(i:i)=str(i:i)
  endif
enddo

end function lowercase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function uppercase(str) result(ucstr)

! convert string to upper case leaving quoted strings as is

character (len=*):: str
character (len=len_trim(str)):: ucstr
integer :: lgth
integer :: ioffset
integer :: iquote
integer :: i
integer :: iav
integer :: iqc

lgth=len_trim(str)
ioffset=iachar('A')-iachar('a')
iquote=0
ucstr=str
do i=1,lgth
  iav=iachar(str(i:i))
  if(iquote==0 .and. (iav==34 .or.iav==39)) then
    iquote=1
    iqc=iav
    cycle
  endif
  if(iquote==1 .and. iav==iqc) then
    iquote=0
    cycle
  endif
  if (iquote==1) cycle
  if(iav >= iachar('a') .and. iav <= iachar('z')) then
    ucstr(i:i)=achar(iav+ioffset)
  else
    ucstr(i:i)=str(i:i)
  endif
enddo

end function uppercase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine matching_delimiter(str,ipos,imatch)

! Sets imatch to the position in string of the delimiter matching the delimiter
! in position ipos. Allowable delimiters are (), [], {}, <>.

character(len=*) :: str
character :: delim1,delim2,ch
integer :: ipos
integer :: imatch
integer :: lenstr
integer :: idelim2
integer :: istart, iend
integer :: inc
integer :: isum
integer :: i

lenstr=len_trim(str)
delim1=str(ipos:ipos)
select case(delim1)
   case('(')
      idelim2=iachar(delim1)+1
      istart=ipos+1
      iend=lenstr
      inc=1
   case(')')
      idelim2=iachar(delim1)-1
      istart=ipos-1
      iend=1
      inc=-1
   case('[','{','<')
      idelim2=iachar(delim1)+2
      istart=ipos+1
      iend=lenstr
      inc=1
   case(']','}','>')
      idelim2=iachar(delim1)-2
      istart=ipos-1
      iend=1
      inc=-1
   case default
      write(*,*) delim1,' is not a valid delimiter'
      return
end select
if(istart < 1 .or. istart > lenstr) then
   write(*,*) delim1,' has no matching delimiter'
   return
endif
delim2=achar(idelim2) ! matching delimiter

isum=1
do i=istart,iend,inc
   ch=str(i:i)
   if(ch /= delim1 .and. ch /= delim2) cycle
   if(ch == delim1) isum=isum+1
   if(ch == delim2) isum=isum-1
   if(isum == 0) exit
enddo
if(isum /= 0) then
   write(*,*) delim1,' has no matching delimiter'
   return
endif
imatch=i

end subroutine matching_delimiter
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_common_substring(3f) - [M_strings] function that returns the
!!                                   longest common substring of two strings.
!!##SYNOPSIS
!!
!!    function longest_common_substring(a,b) result(match)
!!
!!     character(len=*),intent(in)  :: a, b
!!     character(len=:),allocatable :: match
!!##DESCRIPTION
!!    function that returns the longest common substring of two strings.
!!
!!    Note that substrings are consecutive characters within a string.
!!    This distinguishes them from subsequences, which is any sequence of
!!    characters within a string, even if there are extraneous characters in
!!    between them.
!!
!!    Hence, the longest common subsequence between "thisisatest" and
!!    "testing123testing" is "tsitest", whereas the longest common substring
!!    is just "test".
!!##OPTIONS
!!    a,b  strings to search for the longest common substring.
!!##RETURNS
!!    longest_common_substring  the longest common substring found
!!##EXAMPLE
!!
!!  Sample program
!!
!!    program demo_longest_common_substring
!!    use M_strings, only : longest_common_substring
!!    implicit none
!!       call compare('testing123testingthing','thisis',              'thi')
!!       call compare('testing',             'sting',               'sting')
!!       call compare('thisisatest_stinger', 'testing123testingthing','sting')
!!       call compare('thisisatest_stinger', 'thisis',              'thisis')
!!       call compare('thisisatest',         'testing123testing',   'test')
!!       call compare('thisisatest',         'thisisatest',         'thisisatest')
!!    contains
!!
!!    subroutine compare(a,b,answer)
!!    character(len=*),intent(in) :: a, b, answer
!!    character(len=:),allocatable :: match
!!    character(len=*),parameter :: g='(*(g0))'
!!    integer :: i
!!       match=longest_common_substring(a,b)
!!       write(*,g) 'comparing "',a,'" and "',b,'"'
!!       write(*,g) merge('(PASSED) "','(FAILED) "',answer.eq.match), &
!!       & match,'"; expected "',answer,'"'
!!    end subroutine compare
!!
!!    end program demo_longest_common_substring
!!
!!   expected output
!!
!!    comparing "testing123testingthing" and "thisis"
!!    (PASSED) "thi"; expected "thi"
!!    comparing "testing" and "sting"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "testing123testingthing"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "thisis"
!!    (PASSED) "thisis"; expected "thisis"
!!    comparing "thisisatest" and "testing123testing"
!!    (PASSED) "test"; expected "test"
!!    comparing "thisisatest" and "thisisatest"
!!    (PASSED) "thisisatest"; expected "thisisatest"
function longest_common_substring(a,b) result(match)
character(len=*),intent(in)  :: a, b
character(len=:),allocatable :: match
character(len=:),allocatable :: a2, b2
integer :: left, foundat, len_a, i
   if(len(a).lt.len(b))then ! to reduce required comparisions look for shortest string in longest string
      a2=a
      b2=b
   else
      a2=b
      b2=a
   endif

   match=''

   do i=1,len(a2)-1
      len_a=len(a2)
      do left=1,len_a
         foundat=index(b2,a2(left:))
         if(foundat.ne.0.and.len(match).lt.len_a-left+1)then
            if(len(a2(left:)).gt.len(match))then
               match=a2(left:)
               exit
            endif
         endif
      enddo

      if(len(a2).lt.len(match))exit
      a2=a2(:len(a2)-1)

   enddo

end function longest_common_substring
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_strings
 
 
!>>>>> build/dependencies/M_escape/src/M_list2.f90
!>
!!##NAME
!!    M_list2(3f) - [M_list2] maintain simple lists
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    use M_list2, only : insert, replace, remove
!!    use M_list2, only : dictionary
!!
!!##DESCRIPTION
!!
!!    The M_list2(3fm) module allows for maintaining an array as a sorted
!!    list. An example is given that creates a keyword-value dictionary
!!    using the lists.
!!
!!    The lists are maintained as simple allocatable arrays. Each time an
!!    entry is added or deleted the array is re-allocated. Because of the
!!    expense of reallocating the data these routines are best suited for
!!    maintaining small lists that do not change size frequently.
!!
!!    The advantage is that the dictionary components are simple arrays
!!    which can be easily accessed with standard routines.
!!
!!    BASIC LIST
!!
!!    subroutine locate(list,value,place,ier,errmsg)  finds the index where a
!!                                                    value is found or should
!!                                                    be in a sorted array and
!!                                                    flag if the value exists
!!                                                    already
!!    subroutine insert(list,value,place)     insert entry into an allocatable
!!                                            array at specified position
!!    subroutine replace(list,value,place)    replace entry in an allocatable
!!                                            array at specified position
!!    subroutine remove(list,place)           remove entry from an allocatable
!!                                            array at specified position
!!
!!    BASIC DICTIONARY
!!
!!    Due to bugs in gfortran up to at least 7.4.0, this next section
!!    does not work.
!!
!!    type dictionary
!!
!!       character(len=:),allocatable :: key(:)
!!       character(len=:),allocatable :: value(:)
!!       integer,allocatable          :: count(:)
!!
!!    %get      get value from type(dictionary) given an existing key
!!    %set      set or replace value for type(dictionary) given a key
!!    %del      delete an existing key from type(dictionary)
!!    %clr      empty a type(dictionary)
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_M_list
!!    use M_list2, only : insert, locate, replace, remove
!!    ! create a dictionary with character keywords, values, and value lengths
!!    ! using the routines for maintaining a list
!!
!!     use M_list2, only : locate, insert, replace
!!     implicit none
!!     character(len=:),allocatable   :: keywords(:)
!!     character(len=:),allocatable   :: values(:)
!!     integer,allocatable            :: counts(:)
!!     integer                        :: i
!!     ! insert and replace entries
!!     call update('b','value of b')
!!     call update('a','value of a')
!!     call update('c','value of c')
!!     call update('c','value of c again')
!!     call update('d','value of d')
!!     call update('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>","[",a,"]",/))')(trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords))
!!     ! remove some entries
!!     call update('a')
!!     call update('c')
!!     write(*,'(*(a,"==>","[",a,"]",/))')(trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords))
!!     ! get some values
!!     write(*,*)'get b=>',get('b')
!!     write(*,*)'get d=>',get('d')
!!     write(*,*)'get notthere=>',get('notthere')
!!
!!     contains
!!     subroutine update(key,valin)
!!     character(len=*),intent(in)           :: key
!!     character(len=*),intent(in),optional  :: valin
!!     integer                               :: place
!!     integer                               :: ilen
!!     character(len=:),allocatable          :: val
!!     if(present(valin))then
!!        val=valin
!!        ilen=len_trim(val)
!!        ! find where string is or should be
!!        call locate(keywords,key,place)
!!        ! if string was not found insert it
!!        if(place.lt.1)then
!!           call insert(keywords,key,iabs(place))
!!           call insert(values,val,iabs(place))
!!           call insert(counts,ilen,iabs(place))
!!        else
!!           call replace(values,val,place)
!!           call replace(counts,ilen,place)
!!        endif
!!     else
!!        call locate(keywords,key,place)
!!        if(place.gt.0)then
!!           call remove(keywords,place)
!!           call remove(values,place)
!!           call remove(counts,place)
!!        endif
!!     endif
!!     end subroutine update
!!     function get(key) result(valout)
!!     character(len=*),intent(in)   :: key
!!     character(len=:),allocatable  :: valout
!!     integer                       :: place
!!        ! find where string is or should be
!!        call locate(keywords,key,place)
!!        if(place.lt.1)then
!!           valout=''
!!        else
!!           valout=values(place)(:counts(place))
!!        endif
!!     end function get
!!    end program demo_M_list
!!
!!   Results:
!!
!!    d==>[value of d]
!!    c==>[value of c again]
!!    b==>[value of b]
!!    a==>[value of a again]
!!
!!    d==>[value of d]
!!    b==>[value of b]
!!
!!     get b=>value of b
!!     get d=>value of d
!!     get notthere=>
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
module M_list2
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,stdout=>OUTPUT_UNIT    ! access computing environment
implicit none
private

public locate        ! [M_list2] find PLACE in sorted character array where value can be found or should be placed
   private locate_c
   private locate_d
   private locate_r
   private locate_i
public insert        ! [M_list2] insert entry into a sorted allocatable array at specified position
   private insert_c
   private insert_d
   private insert_r
   private insert_i
   private insert_l
public replace       ! [M_list2] replace entry by index from a sorted allocatable array if it is present
   private replace_c
   private replace_d
   private replace_r
   private replace_i
   private replace_l
public remove        ! [M_list2] delete entry by index from a sorted allocatable array if it is present
   private remove_c
   private remove_d
   private remove_r
   private remove_i
   private remove_l

!character(len=*),parameter::ident_1="&
!&@(#)M_list2::locate(3f): Generic subroutine locates where element is or should be in sorted allocatable array"
interface locate
   module procedure locate_c, locate_d, locate_r, locate_i
end interface

!character(len=*),parameter::ident_2="&
!&@(#)M_list2::insert(3f): Generic subroutine inserts element into allocatable array at specified position"
interface insert
   module procedure insert_c, insert_d, insert_r, insert_i, insert_l
end interface

!character(len=*),parameter::ident_3="&
!&@(#)M_list2::replace(3f): Generic subroutine replaces element from allocatable array at specified position"
interface replace
   module procedure replace_c, replace_d, replace_r, replace_i, replace_l
end interface

!character(len=*),parameter::ident_4="&
!&@(#)M_list2::remove(3f): Generic subroutine deletes element from allocatable array at specified position"
interface remove
   module procedure remove_c, remove_d, remove_r, remove_i, remove_l
end interface

logical,save :: debug=.false.
!-----------------------------------------------------------------------------------------------------------------------------------
public dictionary

type dictionary
   character(len=:),allocatable :: key(:)
   character(len=:),allocatable :: value(:)
   integer,allocatable          :: count(:)
   contains
      procedure,private :: get => dict_get
      procedure,private :: set => dict_add    ! insert entry by name into a sorted allocatable character array if it is not present
      procedure,private :: del => dict_delete ! delete entry by name from a sorted allocatable character array if it is present
end type dictionary
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    locate(3f) - [M_list2] finds the index where a string is found or should be in a sorted array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine locate(list,value,place,ier,errmsg)
!!
!!    character(len=:)|doubleprecision|real|integer,allocatable :: list(:)
!!    character(len=*)|doubleprecision|real|integer,intent(in)  :: value
!!    integer, intent(out)                  :: PLACE
!!
!!    integer, intent(out),optional         :: IER
!!    character(len=*),intent(out),optional :: ERRMSG
!!
!!##DESCRIPTION
!!
!!    LOCATE(3f) finds the index where the VALUE is found or should
!!    be found in an array. The array must be sorted in descending
!!    order (highest at top). If VALUE is not found it returns the index
!!    where the name should be placed at with a negative sign.
!!
!!    The array and list must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL,INTEGER)
!!
!!##OPTIONS
!!
!!    VALUE         the value to locate in the list.
!!    LIST          is the list array.
!!
!!##RETURNS
!!    PLACE         is the subscript that the entry was found at if it is
!!                  greater than zero(0).
!!
!!                  If PLACE is negative, the absolute value of
!!                  PLACE indicates the subscript value where the
!!                  new entry should be placed in order to keep the
!!                  list alphabetized.
!!
!!    IER           is zero(0) if no error occurs.
!!                  If an error occurs and IER is not
!!                  present, the program is stopped.
!!
!!    ERRMSG        description of any error
!!
!!##EXAMPLES
!!
!!
!!    Find if a string is in a sorted array, and insert the string into
!!    the list if it is not present ...
!!
!!     program demo_locate
!!     use M_sort, only : sort_shell
!!     use M_list2, only : locate
!!     implicit none
!!     character(len=:),allocatable  :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, plus, ii, end
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     write(*,*)'for "'//string//'" index is ',place, size(arr)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        plus=abs(place)
!!        ii=len(arr)
!!        end=size(arr)
!!        ! empty array
!!        if(end.eq.0)then
!!           arr=[character(len=ii) :: string ]
!!        ! put in front of array
!!        elseif(plus.eq.1)then
!!           arr=[character(len=ii) :: string, arr]
!!        ! put at end of array
!!        elseif(plus.eq.end)then
!!           arr=[character(len=ii) :: arr, string ]
!!        ! put in middle of array
!!        else
!!           arr=[character(len=ii) :: arr(:plus-1), string,arr(plus:) ]
!!        endif
!!        ! show array
!!        write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     endif
!!     end subroutine update
!!     end program demo_locate
!!
!!   Results:
!!
!!     for "b" index is            2           5
!!     for "[" index is           -4           5
!!    SIZE=5 xxx,b,aaa,[,ZZZ,
!!     for "c" index is           -2           6
!!    SIZE=6 xxx,c,b,aaa,[,ZZZ,
!!     for "ZZ" index is           -7           7
!!    SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     for "ZZZZ" index is           -6           8
!!    SIZE=8 xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!     for "z" index is           -1           9
!!    SIZE=9 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine locate_c(list,value,place,ier,errmsg)

!character(len=*),parameter::ident_5="&
!&@(#)M_list2::locate_c(3f): find PLACE in sorted character array where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
character(len=:),allocatable            :: list(:)
integer,intent(out),optional            :: ier
character(len=*),intent(out),optional   :: errmsg
integer                                 :: i
character(len=:),allocatable            :: message
integer                                 :: arraysize
integer                                 :: maxtry
integer                                 :: imin, imax
integer                                 :: error
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_c* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=int(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',trim(value)//' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_c* END PLACE=',place,' ARRAYSIZE=',size(list),' LENGTH=',len(list)
end subroutine locate_c
subroutine locate_d(list,value,place,ier,errmsg)

!character(len=*),parameter::ident_6="&
!&@(#)M_list2::locate_d(3f): find PLACE in sorted doubleprecision array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

doubleprecision,allocatable            :: list(:)
doubleprecision,intent(in)             :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_d* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=int(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_d* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_d
subroutine locate_r(list,value,place,ier,errmsg)

!character(len=*),parameter::ident_7="&
!&@(#)M_list2::locate_r(3f): find PLACE in sorted real array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

real,allocatable                       :: list(:)
real,intent(in)                        :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[real :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_r* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=int(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_r* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_r
subroutine locate_i(list,value,place,ier,errmsg)

!character(len=*),parameter::ident_8="&
!&@(#)M_list2::locate_i(3f): find PLACE in sorted integer array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

integer,allocatable                    :: list(:)
integer,intent(in)                     :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_i* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=int(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_i* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    remove(3f) - [M_list2] remove entry from an allocatable array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine remove(list,place)
!!
!!    character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)
!!    integer, intent(out) :: PLACE
!!
!!##DESCRIPTION
!!
!!    Remove a value from an allocatable array at the specified index.
!!    The array is assumed to be sorted in descending order. It may be of
!!    type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!
!!##OPTIONS
!!
!!    list    is the list array.
!!    PLACE   is the subscript for the entry that should be removed
!!
!!##EXAMPLES
!!
!!
!!    Sample program
!!
!!     program demo_remove
!!     use M_sort, only : sort_shell
!!     use M_list2, only : locate, remove
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!     integer                       :: end
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'Z', 'aaa', 'b', 'b', 'ab', 'bb', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,1)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,4)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end program demo_remove
!!
!!   Results:
!!
!!    Expected output
!!
!!     SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=7 bb,b,b,aaa,ZZZ,Z,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine remove_c(list,place)

!character(len=*),parameter::ident_9="@(#)M_list2::remove_c(3fp): remove string from allocatable string array at specified position"

character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii, end
   if(debug) write(stderr,*)'*remove_c* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[character(len=2) :: ]
   endif
   ii=len(list)
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[character(len=ii) :: list(:place-1) ]
   else
      list=[character(len=ii) :: list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_c* END PLACE=',place,' NEWSIZE=',size(list),' LENGTH=',len(list)
end subroutine remove_c
subroutine remove_d(list,place)

!character(len=*),parameter::ident_10="&
!&@(#)M_list2::remove_d(3fp): remove doubleprecision value from allocatable array at specified position"

doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(debug) write(stderr,*)'*remove_d* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_d* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_d
subroutine remove_r(list,place)

!character(len=*),parameter::ident_11="@(#)M_list2::remove_r(3fp): remove value from allocatable array at specified position"

real,allocatable    :: list(:)
integer,intent(in)  :: place
integer             :: end
   if(debug) write(stderr,*)'*remove_r* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_r* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_r
subroutine remove_l(list,place)

!character(len=*),parameter::ident_12="@(#)M_list2::remove_l(3fp): remove value from allocatable array at specified position"

logical,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(debug) write(stderr,*)'*remove_l* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_l* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_l
subroutine remove_i(list,place)

!character(len=*),parameter::ident_13="@(#)M_list2::remove_i(3fp): remove value from allocatable array at specified position"
integer,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(debug) write(stderr,*)'*remove_i* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_i* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_list2] replace entry in a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine replace(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer, intent(out)          :: PLACE
!!
!!##DESCRIPTION
!!
!!    replace a value in an allocatable array at the specified index. Unless the
!!    array needs the string length to increase this is merely an assign of a value
!!    to an array element.
!!
!!    The array may be of type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER>
!!    It is assumed to be sorted in descending order without duplicate values.
!!
!!    The value and list must be of the same type.
!!
!!##OPTIONS
!!
!!    VALUE         the value to place in the array
!!    LIST          is the array.
!!    PLACE         is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!!   Replace key-value pairs in a dictionary
!!
!!     program demo_replace
!!     use M_list2, only  : insert, locate, replace
!!     ! Find if a key is in a list and insert it
!!     ! into the key list and value list if it is not present
!!     ! or replace the associated value if the key existed
!!     implicit none
!!     character(len=20)            :: key
!!     character(len=100)           :: val
!!     character(len=:),allocatable :: keywords(:)
!!     character(len=:),allocatable :: values(:)
!!     integer                      :: i
!!     integer                      :: place
!!     call update('b','value of b')
!!     call update('a','value of a')
!!     call update('c','value of c')
!!     call update('c','value of c again')
!!     call update('d','value of d')
!!     call update('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>",a,/))')(trim(keywords(i)),trim(values(i)),i=1,size(keywords))
!!
!!     call locate(keywords,'a',place)
!!     if(place.gt.0)then
!!        write(*,*)'The value of "a" is',trim(values(place))
!!     else
!!        write(*,*)'"a" not found'
!!     endif
!!
!!     contains
!!     subroutine update(key,val)
!!     character(len=*),intent(in)  :: key
!!     character(len=*),intent(in)  :: val
!!     integer                      :: place
!!
!!     ! find where string is or should be
!!     call locate(keywords,key,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(keywords,key,abs(place))
!!        call insert(values,val,abs(place))
!!     else ! replace
!!        call replace(values,val,place)
!!     endif
!!
!!     end subroutine update
!!    end program demo_replace
!!
!!   Expected output
!!
!!    d==>value of d
!!    c==>value of c again
!!    b==>value of b
!!    a==>value of a again
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine replace_c(list,value,place)

!character(len=*),parameter::ident_14="@(#)M_list2::replace_c(3fp): replace string in allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: tlen
integer                      :: end
   if(debug) write(stderr,*)'*replace_c* START VALUE=',trim(value),' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   tlen=len_trim(value)
   end=size(list)
   if(place.lt.0.or.place.gt.end)then
           write(stderr,*)'*replace_c* error: index out of range. end=',end,' index=',place
   elseif(len_trim(value).le.len(list))then
      list(place)=value
   else  ! increase length of variable
      ii=max(tlen,len(list))
      kludge=[character(len=ii) :: list ]
      list=kludge
      list(place)=value
   endif
   if(debug)write(stderr,*)'*replace_c* END VALUE=',trim(value),' PLACE=',place,' NEWSIZE=',size(list),' LENGTH=',len(list)
end subroutine replace_c
subroutine replace_d(list,value,place)

!character(len=*),parameter::ident_15="&
!&@(#)M_list2::replace_d(3fp): place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)   :: value
doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(debug) write(stderr,*)'*replace_d* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_d* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_d* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_d
subroutine replace_r(list,value,place)

!character(len=*),parameter::ident_16="@(#)M_list2::replace_r(3fp): place value into allocatable array at specified position"

real,intent(in)       :: value
real,allocatable      :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(debug) write(stderr,*)'*replace_r* START REPLACE_R VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_r* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_r* END REPLACE_R VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_r
subroutine replace_l(list,value,place)

!character(len=*),parameter::ident_17="@(#)M_list2::replace_l(3fp): place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*replace_l* START REPLACE_L VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_l* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_l* END REPLACE_L VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_l
subroutine replace_i(list,value,place)

!character(len=*),parameter::ident_18="@(#)M_list2::replace_i(3fp): place value into allocatable array at specified position"

integer,intent(in)    :: value
integer,allocatable   :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*replace_i* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_i* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_i* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    insert(3f) - [M_list2] insert entry into a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine insert(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer,intent(in)    :: place
!!
!!##DESCRIPTION
!!
!!    Insert a value into an allocatable array at the specified index.
!!    The list and value must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL, or INTEGER)
!!
!!##OPTIONS
!!
!!    list    is the list array. Must be sorted in descending order.
!!    value   the value to place in the array
!!    PLACE   is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!!    Find if a string is in a sorted array, and insert the string into
!!    the list if it is not present ...
!!
!!     program demo_insert
!!     use M_sort, only : sort_shell
!!     use M_list2, only : locate, insert
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!     ! add or replace values
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, end
!!
!!     end=size(arr)
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(arr,string,abs(place))
!!     endif
!!     ! show array
!!     end=size(arr)
!!     write(*,'("array is now SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end subroutine update
!!     end program demo_insert
!!
!!   Results:
!!
!!     array is now SIZE=5 xxx,b,aaa,ZZZ,,
!!     array is now SIZE=6 xxx,b,aaa,[,ZZZ,,
!!     array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,
!!     array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!     array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine insert_c(list,value,place)

!character(len=*),parameter::ident_19="@(#)M_list2::insert_c(3fp): place string into allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: end
   if(debug) write(stderr,*)'*insert_c* START VALUE=',trim(value),' PLACE=',place,' ORIGINALSIZE=',size(list)

   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif

   ii=max(len_trim(value),len(list),2)
   end=size(list)

   if(end.eq.0)then                                          ! empty array
      list=[character(len=ii) :: value ]
   elseif(place.eq.1)then                                    ! put in front of array
      kludge=[character(len=ii) :: value, list]
      list=kludge
   elseif(place.gt.end)then                                  ! put at end of array
      kludge=[character(len=ii) :: list, value ]
      list=kludge
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      kludge=[character(len=ii) :: list(:place-1), value,list(place:) ]
      list=kludge
   else                                                      ! index out of range
      write(stderr,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_c* END VALUE=',trim(value),' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_c
subroutine insert_r(list,value,place)

!character(len=*),parameter::ident_20="@(#)M_list2::insert_r(3fp): place real value into allocatable array at specified position"

real,intent(in)       :: value
real,allocatable      :: list(:)
integer,intent(in)    :: place
integer               :: end

   if(debug) write(stderr,*)'*insert_r* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif

   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                   ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_r* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_r* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_r
subroutine insert_d(list,value,place)

!character(len=*),parameter::ident_21="&
!&@(#)M_list2::insert_d(3fp): place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)       :: value
doubleprecision,allocatable      :: list(:)
integer,intent(in)               :: place
integer                          :: end
   if(debug) write(stderr,*)'*insert_d* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_d* error: index out of range. end=',end,' index=',place,' value=',value
   endif
   if(debug)write(stderr,*)'*insert_d* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_d
subroutine insert_l(list,value,place)

!character(len=*),parameter::ident_22="@(#)M_list2::insert_l(3fp): place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*insert_l* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_l* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_l* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_l
subroutine insert_i(list,value,place)

!character(len=*),parameter::ident_23="@(#)M_list2::insert_i(3fp): place value into allocatable array at specified position"

integer,allocatable   :: list(:)
integer,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*insert_i* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_i* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_i* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    dict_delete(3f) - [M_list2] delete entry by name from an allocatable sorted string array if it is present
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine dict_delete(key,dict)
!!
!!    character(len=*),intent(in) :: key
!!    type(dictionary)            :: dict
!!
!!##DESCRIPTION
!!
!!    Find if a string is in a sorted array, and delete the string
!!    from the dictionary if it is present.
!!
!!##OPTIONS
!!
!!    KEY           the key name to find and delete from the dictionary.
!!    DICTIONARY    the dictionary.
!!
!!##EXAMPLES
!!
!!
!!    delete a key from a dictionary by name.
!!
!!     program demo_dict_delete
!!     use M_list2, only : dictionary
!!     implicit none
!!     type(dictionary) :: caps
!!     integer                       :: i
!!     call caps%set(caps,'A','aye')
!!     call caps%set(caps,'B','bee')
!!     call caps%set(caps,'C','see')
!!     call caps%set(caps,'D','dee')
!!
!!     write(*,101)(trim(arr(i)),i=1,size(caps%keys)) ! show array
!!     call  caps%del(caps,'A')
!!     call  caps%del(caps,'C')
!!     call  caps%del(caps,'z')
!!     write(*,101)(trim(arr(i)),i=1,size(arr)) ! show array
!!     101 format (1x,*("[",a,"]",:,","))
!!     end program demo_dict_delete
!!
!!    Results:
!!
!!     [z],[xxx],[c],[b],[b],[aaa],[ZZZ],[ZZ]
!!     [z],[xxx],[b],[b],[aaa],[ZZZ],[ZZ]
!!     [z],[xxx],[b],[b],[aaa],[ZZZ],[ZZ]
!!     [z],[xxx],[b],[b],[aaa],[ZZZ],[ZZ]
!!     [z],[xxx],[aaa],[ZZZ],[ZZ]
!!     [z],[xxx],[aaa],[ZZZ]
!!     [z],[xxx],[aaa],[ZZZ]
!!     [xxx],[aaa],[ZZZ]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_delete(self,key)

!character(len=*),parameter::ident_24="@(#)M_list2::dict_delete(3f): remove string from sorted allocatable string array if present"

class(dictionary),intent(inout) :: self
character(len=*),intent(in)     :: key
integer                         :: place

   call locate(self%key,key,place)
   if(place.ge.1)then
      call remove(self%key,place)
      call remove(self%value,place)
      call remove(self%count,place)
   endif

end subroutine dict_delete
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    dict_get(3f) - [M_list2] get value of key-value pair in a dictionary given key
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine dict_get(dict,key,value)
!!
!!    type(dictionary)            :: dict
!!    character(len=*),intent(in) :: key
!!    character(len=*),intent(in) :: VALUE
!!
!!##DESCRIPTION
!!
!!    get a value given a key from a key-value dictionary
!!
!!    If key is not found in dictionary , return a blank
!!
!!##OPTIONS
!!
!!    DICT     is the dictionary.
!!    KEY      key name
!!    VALUE    value associated with key
!!
!!##EXAMPLES
!!
!!
!!     program demo_locate
!!     use M_list2, only : dictionary
!!     implicit none
!!     type(dictionary)             :: table
!!     character(len=:),allocatable :: val
!!     integer          :: i
!!
!!     call table%set('A','value for A')
!!     call table%set('B','value for B')
!!     call table%set('C','value for C')
!!     call table%set('D','value for D')
!!     call table%set('E','value for E')
!!     call table%set('F','value for F')
!!     call table%set('G','value for G')
!!     write(*,*)table%get('A')
!!     write(*,*)table%get('B')
!!     write(*,*)table%get('C')
!!     write(*,*)table%get('D')
!!     write(*,*)table%get('E')
!!     write(*,*)table%get('F')
!!     write(*,*)table%get('G')
!!     write(*,*)table%get('H')
!!     end program demo_locate
!!
!!    Results:
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function dict_get(self,key) result(value)

!character(len=*),parameter::ident_25="@(#)M_list2::dict_get(3f): get value of key-value pair in dictionary, given key"

!!class(dictionary),intent(inout) :: self
class(dictionary)               :: self
character(len=*),intent(in)     :: key
character(len=:),allocatable    :: value
integer                         :: place
   call locate(self%key,key,place)
   if(place.lt.1)then
      value=''
   else
      value=self%value(place)(:self%count(place))
   endif
end function dict_get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    dict_add(3f) - [M_list2] add or replace a key-value pair in a dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine dict_add(dict,key,value)
!!
!!    type(dictionary)            :: dict
!!    character(len=*),intent(in) :: key
!!    character(len=*),intent(in) :: VALUE
!!
!!##DESCRIPTION
!!    Add or replace a key-value pair in a dictionary.
!!
!!##OPTIONS
!!    DICT     is the dictionary.
!!    key      key name
!!    VALUE    value associated with key
!!
!!##EXAMPLES
!!
!!    If string is not found in a sorted array, insert the string
!!
!!     program demo_add
!!     use M_list2, only : dictionary
!!     implicit none
!!     type(dictionary) :: dict
!!     integer          :: i
!!
!!     call dict%set('A','b')
!!     call dict%set('B','^')
!!     call dict%set('C',' ')
!!     call dict%set('D','c')
!!     call dict%set('E','ZZ')
!!     call dict%set('F','ZZZZ')
!!     call dict%set('G','z')
!!     call dict%set('A','new value for A')
!!     write(*,'(*(a,"==>","[",a,"]",/))')(trim(dict%key(i)),dict%value(i)(:dict%count(i)),i=1,size(dict%key))
!!     end program demo_add
!!
!!    Results:
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_add(self,key,value)

!character(len=*),parameter::ident_26="@(#)M_list2::dict_add(3f): place key-value pair into dictionary, adding the key if required"

class(dictionary),intent(inout) :: self
character(len=*),intent(in)     :: key
character(len=*),intent(in)     :: value
integer                         :: place
integer                         :: place2
   call locate(self%key,key,place)
   if(place.lt.1)then
      place2=iabs(place)
      call insert( self%key,   key,             place2 )
      call insert( self%value, value,           place2 )
      call insert( self%count, len_trim(value), place2 )
   elseif(place.gt.0)then  ! replace instead of insert
      call insert( self%value, value,           place )
      call insert( self%count, len_trim(value), place )
   endif
end subroutine dict_add
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_list2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
 
 
!>>>>> build/dependencies/M_escape/src/M_escape.f90
!>
!!##NAME
!!    M_escape(3f) - [M_escape::INTRO] substitute escape sequences for HTML-like
!!                   syntax in strings
!!
!!##SYNOPSIS
!!
!!     use M_escape, only : esc, esc_mode, update
!!     use M_escape, only : attr
!!     use M_escape, only : color, color_mode
!!
!!##DESCRIPTION
!!    M_escape is a Fortran module for using HTML-like syntax to add
!!    attributes to terminal output such as color.
!!
!!    ANSI escape sequences are not universally supported by all terminal
!!    emulators; and normally should be suppressed when not going to a tty
!!    device. This routine provides the basic structure to support such
!!    behaviors, or to perhaps in the future generate a CSS style sheet
!!    and HTML instead of text to the terminal, ...
!!
!!    Alternatively, direct use of the escape sequences is supported,
!!    as well as a functional interface, and an object-oriented approach.
!!
!!    The original concept was to allow formatting by using an existing
!!    HTML library to allow the user to write HTML and to format it on a
!!    terminal like w3m, lynx, and link do. And in some ways this is an
!!    opposite approach in that it is directly formatting the text by using
!!    a similar syntax to directly generate text attributes; but it is a
!!    much simpler approach programmatically.
!!
!!    Typically, you should use M_system::system_istty(3f) or the common
!!    Fortran extension ISATTY() to set the default
!!    to "plain" instead of "color" when the output file is not a terminal.
!!
!!##MAJOR FEATURES
!!    o Add ANSI terminal escape sequences with an HTML-like syntax with
!!      ESC(3f).
!!    o suppress the escape sequence output with ESC_MODE(3f).
!!    o add, delete, and replace what strings are produced using UPDATE(3f).
!!
!!##LIMITATIONS
!!      o colors are not nestable, keywords are case-sensitive,
!!      o not all terminals obey the sequences. On Windows, it is best if
!!        you use Windows 10+ and/or the Linux mode; although it has worked
!!        with all CygWin and MinGW and Putty windows and mintty(1).
!!
!!##FUTURE
!!     Full support for alternate output formats like HTML and popular markdown
!!     syntax. For example
!!
!!       ANSI  HTML        Markdown
!!             <h1></h1>   #
!!             <h2></h2>   ##
!!             <b></b>     ** and **
!!             <i></i>     __ and __
!!
!!    Apparently have to make a stack of colors to allow nesting colors
!!
!!    How common are extensions like xterm-256 has to set RGB values for
!!    colors and so on?
!!
!!    Should a call to system_istty(3f) be built in to turn off escape sequences
!!    when a terminal is not present?
!!
!!    For color or pre-defined words a case statement could be used to call
!!    specific functions to support platforms like old Microsoft consoles that
!!    require a function call to assign text attributes instead of in-band ANSI
!!    escape control sequences. See the "Rosetta Code" web site for examples
!!    of generating color in Microsoft consoles.
!!
!!    Attributes are currently ended at the end of each call to esc(3f). Perhaps
!!    allow multi-line formatting?
!!
!!    Ultimately, an object-oriented package with capabilities like ncurses to
!!    define a "pad" and move and resize and format it would be ideal and very
!!    useful. Also see fixedform(3f) in the GPF (General Fortran Package).
!!
!!    It is a shame xterm(1) does not support pixel-oriented abilities to define
!!    a "graphics" area or support canvas(3c)-like in-band graphics, somewhat
!!    like Tektronix terminals, although it does have a Tektronix 4010 mode.
!!
!!    Perhaps overload + to replace //
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_M_escape
!!    use M_escape, only : esc, esc_mode
!!    implicit none
!!    character(len=1024) :: line
!!    real :: value
!!       write(*,'(a)')&
!!       &esc('<r><W>ERROR:</W>This should appear as red text</y>')
!!       write(*,'(a)')&
!!       &esc('<y><B>WARNING:</B></y> This should appear as default text')
!!
!!       value=3.4567
!!       if( (value>0.0) .and. (value<100.0))then
!!          write(line,fmt=&
!!          &'("<w><G>GREAT</G></w>:&
!!          &The new value <Y><b>",f8.4,"</b></Y> is in range")')value
!!       else
!!          write(line,fmt=&
!!          &'("<R><e>ERROR</e></R>:&
!!          &The new value <Y><b>",g0,"</b></Y> is out of range")')value
!!       endif
!!
!!       write(*,'(a)')esc(trim(line))
!!       ! write as plain text
!!       call esc_mode(manner='plain')
!!       write(*,'(a)')esc(trim(line))
!!
!!    end program demo_M_escape
!!
!!##ALTERNATE DIRECT USE
!!
!!   Alternatively, you may use the escape sequences directly
!!
!!    program direct
!!       use M_escape, only : &
!!      ! FOREGROUND COLORS
!!         & fg_red, fg_cyan, fg_magenta, fg_blue, &
!!         & fg_green, fg_yellow, fg_white, fg_ebony, &
!!         & fg_default, &
!!      ! BACKGROUND COLORS
!!         & bg_red, bg_cyan, bg_magenta, bg_blue, &
!!         & bg_green, bg_yellow, bg_white, bg_ebony, &
!!         & bg_default, &
!!      ! ATTRIBUTES
!!         & bold, italic, inverse, underline,  &
!!         & unbold, unitalic, uninverse, ununderline,  &
!!         & reset, &
!!      ! DISPLAY
!!         & clear
!!       implicit none
!!         write(*,'(*(g0))')fg_red,bg_green,bold,'Hello!',reset
!!    end program direct
!!
!!##ALTERNATE FUNCTIONAL INTERFACE
!!
!!  If you prefer a functional interface, use the attr(3f) function with
!!  the same keywords as with the esc(3f) function. Note that esc_mode(3f)
!!  will work with this function.
!!
!!    program functional
!!    use M_escape, only : attr, esc_mode
!!    implicit none
!!         call printme('color')
!!         call printme('plain')
!!         call printme('raw')
!!    contains
!!    subroutine printme(mymode)
!!    character(len=*),intent(in) :: mymode
!!       call esc_mode(mymode)
!!       write(*,'(a)')mymode
!!       write(*,'(*(g0))',advance='no') &
!!        & attr('red:BLUE:bold','Hello!'), &
!!        & 'and everything is back to defaults or ', &
!!        & attr('RED:blue:bold'),'Hello Again!', &
!!        & attr('/BLUE'),' Well, the text color is still on.',attr('reset')
!!       write(*,'(*(g0))',advance='yes')' Back to normal writes.'
!!    end subroutine printme
!!    end program functional
module M_escape
use M_list2, only : insert, locate, replace, remove
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,stdin=>INPUT_UNIT    ! access computing environment
use, intrinsic :: iso_c_binding, only: c_int
implicit none
private
public esc
public esc_mode
public update
public print_dictionary
public M_escape_initialize

!-!public flush_colors, init_colors
public attr

! direct use of constant strings
public color
public color_mode
logical,save :: G_color=.true.

logical,save :: debug=.false.

character(len=:),allocatable,save :: keywords(:)
character(len=:),allocatable,save :: values(:)
integer,allocatable,save :: counts(:)

character(len=:),allocatable,save :: mode

! DECIMAL
! *-------*-------*-------*-------*-------*-------*-------*-------*
! | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|
! | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si |
! | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb|
! | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us |
! | 32 sp | 33  ! | 34  " | 35  # | 36  $ | 37  % | 38  & | 39  ' |
! | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / |
! | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 |
! | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? |
! | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G |
! | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O |
! | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W |
! | 88  X | 89  Y | 90  Z | 91  [ | 92  \ | 93  ] | 94  ^ | 95  _ |
! | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g |
! |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o |
! |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w |
! |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del|
! *-------*-------*-------*-------*-------*-------*-------*-------*

! mnemonics
character(len=*),parameter  :: NL=new_line('a')                     ! New line character.
character(len=*),parameter  :: HT=char(09)                          ! Horizontal tab
character(len=*),parameter  :: ESCAPE=achar(27)                     ! "\" character.
! codes
character(len=*),parameter  :: CODE_START=ESCAPE//'['               ! Start ANSI code, "\[".
character(len=*),parameter  :: CODE_END='m'                         ! End ANSI code, "m".
character(len=*),parameter  :: CODE_RESET=CODE_START//'0'//CODE_END ! Clear all styles, "\[0m".

character(len=*),parameter  :: CLEAR_DISPLAY=CODE_START//'2J'
character(len=*),parameter  :: HOME_DISPLAY=CODE_START//'H'
character(len=*),parameter  :: BELL=achar(7)
character(len=*),parameter  :: NEWLINE=achar(7)

character(len=*),parameter  :: BOLD_ON='1',   ITALIC_ON='3',   UNDERLINE_ON='4',   INVERSE_ON='7'
character(len=*),parameter  :: BOLD_OFF='22', ITALIC_OFF='23', UNDERLINE_OFF='24', INVERSE_OFF='27'

character(len=*),parameter  :: COLOR_FG_BLACK='30', COLOR_FG_RED='31',     COLOR_FG_GREEN='32', COLOR_FG_YELLOW='33'
character(len=*),parameter  :: COLOR_FG_BLUE='34',  COLOR_FG_MAGENTA='35', COLOR_FG_CYAN='36',  COLOR_FG_WHITE='37'
character(len=*),parameter  :: COLOR_FG_DEFAULT='39'

character(len=*),parameter  :: COLOR_FG_BLACK_INTENSE='90', COLOR_FG_RED_INTENSE='91'
character(len=*),parameter  :: COLOR_FG_GREEN_INTENSE='92', COLOR_FG_YELLOW_INTENSE='93'
character(len=*),parameter  :: COLOR_FG_BLUE_INTENSE='94',  COLOR_FG_MAGENTA_INTENSE='95'
character(len=*),parameter  :: COLOR_FG_CYAN_INTENSE='96',  COLOR_FG_WHITE_INTENSE='97'

character(len=*),parameter  :: COLOR_BG_BLACK='40', COLOR_BG_RED='41',     COLOR_BG_GREEN='42', COLOR_BG_YELLOW='43'
character(len=*),parameter  :: COLOR_BG_BLUE='44',  COLOR_BG_MAGENTA='45', COLOR_BG_CYAN='46',  COLOR_BG_WHITE='47'

character(len=*),parameter  :: COLOR_BG_DEFAULT='49'

character(len=*),parameter  :: COLOR_BG_BLACK_INTENSE='100', COLOR_BG_RED_INTENSE='101'
character(len=*),parameter  :: COLOR_BG_GREEN_INTENSE='102', COLOR_BG_YELLOW_INTENSE='103'
character(len=*),parameter  :: COLOR_BG_BLUE_INTENSE='104',  COLOR_BG_MAGENTA_INTENSE='105'
character(len=*),parameter  :: COLOR_BG_CYAN_INTENSE='106',  COLOR_BG_WHITE_INTENSE='107'

! for direct use of escape sequences

! foreground colors
character(len=*),parameter,public :: fg_red      =  CODE_START//COLOR_FG_RED//CODE_END
character(len=*),parameter,public :: fg_cyan     =  CODE_START//COLOR_FG_CYAN//CODE_END
character(len=*),parameter,public :: fg_magenta  =  CODE_START//COLOR_FG_MAGENTA//CODE_END
character(len=*),parameter,public :: fg_blue     =  CODE_START//COLOR_FG_BLUE//CODE_END
character(len=*),parameter,public :: fg_green    =  CODE_START//COLOR_FG_GREEN//CODE_END
character(len=*),parameter,public :: fg_yellow   =  CODE_START//COLOR_FG_YELLOW//CODE_END
character(len=*),parameter,public :: fg_white    =  CODE_START//COLOR_FG_WHITE//CODE_END
character(len=*),parameter,public :: fg_ebony    =  CODE_START//COLOR_FG_BLACK//CODE_END
character(len=*),parameter,public :: fg_black    =  CODE_START//COLOR_FG_BLACK//CODE_END
character(len=*),parameter,public :: fg_default  =  CODE_START//COLOR_FG_DEFAULT//CODE_END

! background colors
character(len=*),parameter,public :: bg_red      =  CODE_START//COLOR_BG_RED//CODE_END
character(len=*),parameter,public :: bg_cyan     =  CODE_START//COLOR_BG_CYAN//CODE_END
character(len=*),parameter,public :: bg_magenta  =  CODE_START//COLOR_BG_MAGENTA//CODE_END
character(len=*),parameter,public :: bg_blue     =  CODE_START//COLOR_BG_BLUE//CODE_END
character(len=*),parameter,public :: bg_green    =  CODE_START//COLOR_BG_GREEN//CODE_END
character(len=*),parameter,public :: bg_yellow   =  CODE_START//COLOR_BG_YELLOW//CODE_END
character(len=*),parameter,public :: bg_white    =  CODE_START//COLOR_BG_WHITE//CODE_END
character(len=*),parameter,public :: bg_ebony    =  CODE_START//COLOR_BG_BLACK//CODE_END
character(len=*),parameter,public :: bg_black    =  CODE_START//COLOR_BG_BLACK//CODE_END
character(len=*),parameter,public :: bg_default  =  CODE_START//COLOR_BG_DEFAULT//CODE_END

! attributes
character(len=*),parameter,public :: bold        =  CODE_START//BOLD_ON//CODE_END
character(len=*),parameter,public :: italic      =  CODE_START//ITALIC_ON//CODE_END
character(len=*),parameter,public :: inverse     =  CODE_START//INVERSE_ON//CODE_END
character(len=*),parameter,public :: underline   =  CODE_START//UNDERLINE_ON//CODE_END
character(len=*),parameter,public :: unbold      =  CODE_START//BOLD_OFF//CODE_END
character(len=*),parameter,public :: unitalic    =  CODE_START//ITALIC_OFF//CODE_END
character(len=*),parameter,public :: uninverse   =  CODE_START//INVERSE_OFF//CODE_END
character(len=*),parameter,public :: ununderline =  CODE_START//UNDERLINE_OFF//CODE_END

character(len=*),parameter,public :: reset       =  CODE_RESET
character(len=*),parameter,public :: clear       =  HOME_DISPLAY//CLEAR_DISPLAY

interface
    function M_escape_initialize() result(r) bind(c, name="M_escape_initialize")
        import c_int
        integer(kind=c_int) :: r
    end function
end interface


contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    esc(3f) - [M_escape] substitute escape sequences for HTML-like syntax
!!              in strings
!!
!!##SYNOPSIS
!!
!!     function esc(string,clear_at_end) result (expanded)
!!
!!       character(len=*),intent(in) :: string
!!       logical,intent(in),optional :: clear_at_end
!!       character(len=:),allocatable :: expanded
!!
!!##DESCRIPTION
!!    Use HTML-like syntax to add attributes to terminal output such as color.
!!
!!    ANSI escape sequences are not universally supported by all terminal
!!    emulators; and normally should be suppressed when not going to a
!!    tty device. This routine provides the basic structure to support
!!    such behaviors.
!!
!!##OPTIONS
!!    string        input string  of form
!!
!!                    "<attribute_name>string</attribute_name> ...".
!!
!!                   where the current attributes are color names,
!!                   bold, italic, underline, ...
!!
!!    clear_at_end   By default, a sequence to clear all text attributes
!!                   is sent at the end of the returned text if an escape
!!                   character appears in the output string. This can be
!!                   turned off by setting this value to false.
!!##KEYWORDS
!!    current keywords
!!
!!     colors:
!!       r,         red,       R,  RED
!!       g,         green,     G,  GREEN
!!       b,         blue,      B,  BLUE
!!       m,         magenta,   M,  MAGENTA
!!       c,         cyan,      C,  CYAN
!!       y,         yellow,    Y,  YELLOW
!!       e,         ebony,     E,  EBONY
!!       w,         white,     W,  WHITE
!!     attributes:
!!       it,        italic
!!       bo,        bold
!!       un,        underline
!!      other:
!!       clear
!!       esc,       escape
!!       default
!!       gt
!!       lt
!!
!!    By default, if the color mnemonics (ie. the keywords) are uppercase
!!    they change the background color. If lowercase, the foreground color.
!!
!!    The "default" keyword is typically used explicitly when
!!    clear_at_end=.false.
!!
!!    Add, delete, and replace what strings are produced using UPDATE(3f).
!!
!!##LIMITATIONS
!!      o colors are not nestable, keywords are case-sensitive,
!!      o not all terminals obey the sequences. On Windows, it is best if
!!        you use Windows 10+ and/or the Linux mode; although it has worked
!!        with all CygWin and MinGW and Putty windows and mintty.
!!      o you should use "<gt>" and "<lt>" instead of ">" and "<" in a string
!!        processed by esc(3f) instead of in any plain text output so that
!!        the raw mode will create correct input for the esc(3f) function
!!        if read back in.
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_esc
!!    use M_escape, only : esc, esc_mode, update
!!       write(*,'(a)') esc('<clear>TEST DEFAULTS:')
!!       call printstuff()
!!
!!       write(*,'(a)') esc('TEST MANNER=PLAIN:')
!!       call esc_mode(manner='plain')
!!       call printstuff()
!!
!!       write(*,'(a)') esc('TEST MANNER=RAW:')
!!       call esc_mode(manner='raw')
!!       call printstuff()
!!
!!       write(*,'(a)') esc('TEST MANNER=color:')
!!       call esc_mode(manner='color')
!!       call printstuff()
!!
!!       write(*,'(a)') esc('TEST ADDING A CUSTOM SEQUENCE:')
!!       call update('blink',char(27)//'[5m')
!!       call update('/blink',char(27)//'[38m')
!!       write(*,'(a)') esc('<blink>Items for Friday</blink>')
!!
!!    contains
!!    subroutine printstuff()
!!
!!      write(*,'(a)') esc('<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>')
!!      write(*,'(a)') esc('<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>')
!!      write(*,'(a)') esc('<w>WHITE</w> and <e>EBONY</e>')
!!
!!      write(*,'(a)') esc('Adding <bo>bold</bo>')
!!      write(*,'(a)') esc('<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>')
!!      write(*,'(a)') esc('<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>')
!!      write(*,'(a)') esc('<bo><w>WHITE</w> and <e>EBONY</e></bo>')
!!
!!      write(*,'(a)') esc('Adding <ul>underline</ul>')
!!      write(*,'(a)') esc(&
!!       &'<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>')
!!      write(*,'(a)') esc(&
!!       &'<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>')
!!      write(*,'(a)') esc('<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>')
!!
!!      write(*,'(a)') esc('Adding <ul>italic</ul>')
!!      write(*,'(a)') esc(&
!!       &'<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>')
!!      write(*,'(a)') esc(&
!!       &'<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>')
!!      write(*,'(a)') esc('<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>')
!!
!!      write(*,'(a)') esc('Adding <in>inverse</in>')
!!      write(*,'(a)') esc(&
!!       &'<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,&
!!       &<b>BLUE</b></it></ul></bo></in>')
!!      write(*,'(a)') esc(&
!!       &'<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,&
!!       &<y>YELLOW</it></y></ul></bo></in>')
!!      write(*,'(a)') esc(&
!!       &'<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>')
!!    end subroutine printstuff
!!
!!    end program demo_esc
function esc(string,clear_at_end) result (expanded)
character(len=*),intent(in)  :: string
logical,intent(in),optional  :: clear_at_end
logical                      :: clear_at_end_local
character(len=:),allocatable :: padded
character(len=:),allocatable :: expanded
character(len=:),allocatable :: name
integer                      :: i
integer                      :: ii
integer                      :: maxlen
integer                      :: place
if(present(clear_at_end))then
   clear_at_end_local=clear_at_end
else
   clear_at_end_local=.false.
endif
if(.not.allocated(mode))then  ! set substitution mode
   mode='color' ! 'color'|'raw'|'plain'
   call vt102()
endif

if(mode=='raw')then
   expanded=string
   return
endif

maxlen=len(string)
padded=string//' '
i=1
expanded=''
do
   if(debug)write(*,*)'DEBUG:*esc*: processing',padded(i:i),' from',string(i:),' EXPANDED=',expanded
   select case(padded(i:i))
   case('>')  ! should not get here unless unmatched
      i=i+1
      expanded=expanded//'>'
   case('<')  ! assuming not nested for now
      ii=index(padded(i+1:),'>')
      if(ii.eq.0)then
         expanded=expanded//'<'
         i=i+1
      else
         name=padded(i+1:i+ii-1)
         name=trim(adjustl(name))
         if(debug)write(*,*)'DEBUG:*esc* 1: NAME=',name,get(name)
         call locate(keywords,name,place)
         if(debug)write(*,*)'DEBUG:*esc* 1: LOCATE=',place

         if(mode.eq.'plain')then
         elseif(place.le.0)then     ! unknown name; print what you found
            expanded=expanded//padded(i:i+ii)
         else
            expanded=expanded//get(name)
         endif
         if(name.eq.'debug')debug=.true.   !! development version
         if(name.eq.'/debug')debug=.false. !! development version
         i=ii+i+1
      endif
   case default
      expanded=expanded//padded(i:i)
      i=i+1
   end select
   if(i >= maxlen+1)exit
enddo
if( (index(expanded,escape).ne.0).and.(.not.clear_at_end_local))then
   if((mode.ne.'raw').and.(mode.ne.'plain'))then
      expanded=expanded//CODE_RESET                                   ! Clear all styles
   endif
endif
end function esc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    color(3f) - [M_escape] colorize text using a simple function-based approach
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    use M_escape, only : color, color_mode, &
!!
!!     ! FOREGROUND COLORS
!!         & fg_red, fg_cyan, fg_magenta, fg_blue, &
!!         & fg_green, fg_yellow, fg_white, fg_ebony, &
!!         & fg_default, &
!!     ! BACKGROUND COLORS
!!         & bg_red, bg_cyan, bg_magenta, bg_blue, &
!!         & bg_green, bg_yellow, bg_white, bg_ebony, &
!!         & bg_default, &
!!      ! ATTRIBUTES
!!         & bold, italic, inverse, underline,  &
!!         & unbold, unitalic, uninverse, ununderline,  &
!!         & reset, &
!!      ! DISPLAY
!!         & clear
!!
!!     function color(string,fg,bg,style) result (out)
!!
!!      character(len=*),intent(in)          :: string
!!      character(len=*),intent(in),optional :: fg
!!      character(len=*),intent(in),optional :: bg
!!      character(len=*),intent(in),optional :: style
!!
!!##DESCRIPTION
!!     The color constant strings can be used directly but unconditionally
!!     in an output statement. To allow the attributes to be ignored they
!!     can be called with the color(3f) routine, which the color_mode(3f)
!!     procedure can be used to toggle on and off. Note that this routine
!!     does an implicit reset at the end of each use.
!!
!!##OPTIONS
!!    string     string to assign attributes to
!!    fg         foreground color constant
!!    bg         background color constant
!!    style      style keyword or concatenated style keywords
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_color
!!       use M_escape, only : color, color_mode, &
!!      ! FOREGROUND COLORS
!!         & fg_red, fg_cyan, fg_magenta, fg_blue, &
!!         & fg_green, fg_yellow, fg_white, fg_ebony, &
!!         & fg_default, &
!!      ! BACKGROUND COLORS
!!         & bg_red, bg_cyan, bg_magenta, bg_blue, &
!!         & bg_green, bg_yellow, bg_white, bg_ebony, &
!!         & bg_default, &
!!      ! ATTRIBUTES
!!         & bold, italic, inverse, underline,  &
!!         & unbold, unitalic, uninverse, ununderline,  &
!!         & reset, &
!!      ! DISPLAY
!!         & clear
!!       implicit none
!!         write(*,'(*(g0))')fg_red,bg_green,bold,' Hello! ',reset
!!
!!         write(*,'(a)')color(' Hello! ',&
!!          & fg=fg_white,bg=bg_red,style=italic//bold)
!!         call color_mode(.false.)
!!         write(*,'(a)')color(' Hello! ',&
!!          & fg=fg_red,bg=bg_red,style=italic//bold)
!!    end program demo_color
!!
!!##AUTHOR
!!    John S. Urban, 2020
!!##LICENSE
!!    Public Domain
function color(string,fg,bg,style) result (out)

! ident_1="@(#)use the color string constants, optionally ignoring them if G_switch is .false. as set by color_mode(3f)"

character(len=*),intent(in)          :: string
character(len=*),intent(in),optional :: fg
character(len=*),intent(in),optional :: bg
character(len=*),intent(in),optional :: style
character(len=:),allocatable         :: out
out=''
if(G_color)then
   if(present(style))out=out//style
   if(present(bg))out=out//bg
   if(present(fg))out=out//fg
   out=out//string
   out=out//reset
else
   out=string
endif
end function color
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    color_mode(3f) - [M_escape] toggle style effects of color(3f) on and off
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine color_mode(switch)
!!
!!      logical,intent(in) :: switch
!!
!!##DESCRIPTION
!!     The color constant strings can be used directly but unconditionally
!!     in an output statement. To allow the attributes to be ignored they
!!     can be called with the color(3f) routine, which the color_mode(3f)
!!     procedure can be used to toggle on and off. Note that this routine
!!     does an implicit reset at the end of each use.
!!
!!##OPTIONS
!!     switch   turn attributes set by color(3f) on and off
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_color_mode
!!       use M_escape, only : color, color_mode, &
!!      ! FOREGROUND COLORS
!!         & fg_red, fg_cyan, fg_magenta, fg_blue, &
!!         & fg_green, fg_yellow, fg_white, fg_ebony, &
!!         & fg_default, &
!!      ! BACKGROUND COLORS
!!         & bg_red, bg_cyan, bg_magenta, bg_blue, &
!!         & bg_green, bg_yellow, bg_white, bg_ebony, &
!!         & bg_default, &
!!      ! ATTRIBUTES
!!         & bold, italic, inverse, underline,  &
!!         & unbold, unitalic, uninverse, ununderline,  &
!!         & reset, &
!!      ! DISPLAY
!!         & clear
!!       implicit none
!!         write(*,'(*(g0))')fg_red,bg_green,bold,' Hello! ',reset
!!
!!         write(*,'(a)')color(' Hello! ',&
!!          & fg=fg_white,bg=bg_red,style=italic//bold)
!!         call color_mode(.false.)
!!         write(*,'(a)')color(' Hello! ',&
!!          & fg=fg_red,bg=bg_red,style=italic//bold)
!!    end program demo_color_mode
!!
!!##AUTHOR
!!    John S. Urban, 2020
!!##LICENSE
!!    Public Domain
subroutine color_mode(switch)
logical,intent(in) :: switch
   G_color=switch
end subroutine color_mode
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine vt102()
! create a dictionary with character keywords, values, and value lengths
! using the routines for maintaining a list

   call wipe_dictionary()
   ! insert and replace entries

   call update('bold',bold)
   call update('/bold',unbold)
   call update('bo',bold)
   call update('/bo',unbold)
   call update('livid',bold)
   call update('/livid',unbold)
   call update('li',bold)
   call update('/li',unbold)

   call update('italic',italic)
   call update('/italic',unitalic)
   call update('it',italic)
   call update('/it',unitalic)

   call update('inverse',inverse)
   call update('/inverse',uninverse)
   call update('in',inverse)
   call update('/in',uninverse)

   call update('underline',underline)
   call update('/underline',ununderline)
   call update('un',underline)
   call update('/un',ununderline)

   call update('esc',ESCAPE)
   call update('escape',ESCAPE)

   call update('clear',clear)
   call update('reset',reset)
   call update('bell',BELL)
   call update('n',NL)
   call update('t',HT)
   call update('gt','>')
   call update('lt','<')

   ! foreground colors
   call update('r',fg_red)
       call update('/r',fg_default)
       call update('red',fg_red)
       call update('/red',fg_default)
   call update('c',fg_cyan)
       call update('/c',fg_default)
       call update('cyan',fg_cyan)
       call update('/cyan',fg_default)
   call update('m',fg_magenta)
       call update('/m',fg_default)
       call update('magenta',fg_magenta)
       call update('/magenta',fg_default)
   call update('b',fg_blue)
       call update('/b',fg_default)
       call update('blue',fg_blue)
       call update('/blue',fg_default)
   call update('g',fg_green)
       call update('/g',fg_default)
       call update('green',fg_green)
       call update('/green',fg_default)
   call update('y',fg_yellow)
       call update('/y',fg_default)
       call update('yellow',fg_yellow)
       call update('/yellow',fg_default)
   call update('w',fg_white)
       call update('/w',fg_default)
       call update('white',fg_white)
       call update('/white',fg_default)
   call update('e',fg_ebony)
       call update('/e',fg_default)
       call update('ebony',fg_ebony)
       call update('/ebony',fg_default)
   call update('x',fg_ebony)
       call update('/x',fg_default)
       call update('black',fg_ebony)
       call update('/black',fg_default)

   ! background colors
   call update('R',bg_red)
       call update('/R',bg_default)
       call update('RED',bg_red)
       call update('/RED',bg_default)
   call update('C',bg_cyan)
       call update('/C',bg_default)
       call update('CYAN',bg_cyan)
       call update('/CYAN',bg_default)
   call update('M',bg_magenta)
       call update('/M',bg_default)
       call update('MAGENTA',bg_magenta)
       call update('/MAGENTA',bg_default)
   call update('B',bg_blue)
       call update('/B',bg_default)
       call update('BLUE',bg_blue)
       call update('/BLUE',bg_default)
   call update('G',bg_green)
       call update('/G',bg_default)
       call update('GREEN',bg_green)
       call update('/GREEN',bg_default)
   call update('Y',bg_yellow)
       call update('/Y',bg_default)
       call update('YELLOW',bg_yellow)
       call update('/YELLOW',bg_default)
   call update('W',bg_white)
       call update('/W',bg_default)
       call update('WHITE',bg_white)
       call update('/WHITE',bg_default)
   call update('E',bg_ebony)
       call update('/E',bg_default)
       call update('EBONY',bg_ebony)
       call update('/EBONY',bg_default)
   call update('X',bg_ebony)
       call update('/X',bg_default)
       call update('BLACK',bg_ebony)
       call update('/BLACK',bg_default)

end subroutine vt102
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    esc_mode(3f) - [M_escape] select processing mode for output from esc(3f)
!!
!!##SYNOPSIS
!!
!!    subroutine esc_mode(manner)
!!
!!       character(len=*),intent(in) :: manner
!!
!!##DESCRIPTION
!!       Turn off the generation of strings associated with the HTML keywords
!!       in the string generated by the esc(3f) function, or display the
!!       text in raw mode as it was passed to esc(3f) or return to ANSI
!!       escape control sequence generation.
!!
!!##OPTIONS
!!    MANNER  The current manners or modes supported via the ESC_MODE(3f)
!!            procedure are
!!
!!        plain          suppress the output associated with keywords
!!        color(default) commonly supported escape sequences
!!        raw            echo the input to ESC(3f) as its output
!!        reload         restore original keyword meanings deleted or
!!                       replaced by calls to update(3f).
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_esc_mode
!!    use M_escape, only : esc, esc_mode
!!    implicit none
!!    character(len=1024) :: line
!!    real :: value
!!
!!      value=3.4567
!!      if( (value>0.0) .and. (value<100.0))then
!!        write(line,fmt='("&
!!       &<w><G>GREAT</G></w>: The value <Y><b>",f8.4,"</b></Y> is in range &
!!       &")')value
!!      else
!!        write(line,fmt='("&
!!       &<R><e>ERROR</e></R>:The new value <Y><b>",g0,"</b></Y> is out of range&
!!       & ")')value
!!      endif
!!
!!      write(*,'(a)')esc(trim(line))
!!
!!      call esc_mode(manner='plain') ! write as plain text
!!      write(*,'(a)')esc(trim(line))
!!      call esc_mode(manner='raw')   ! write as-is
!!      write(*,'(a)')esc(trim(line))
!!      call esc_mode(manner='ansi')  ! return to default mode
!!      write(*,'(a)')esc(trim(line))
!!
!!    end program demo_esc_mode
subroutine esc_mode(manner)
character(len=*),intent(in) :: manner
   if(.not.allocated(mode))then  ! set substitution mode
      mode='color'
      call vt102()
   endif
   select case(manner)
   case('vt102','ANSI','ansi','color','COLOR')
      mode='color'
   case('reload')
      call vt102()
      mode='color'
   case('xterm')
      mode=manner
   case('raw')
      mode=manner
   case('dummy','plain','text')
      mode='plain'
   case default
      write(*,*)'unknown manner. Try color|raw|plain'
      mode='color'
   end select
end subroutine esc_mode
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine wipe_dictionary()
   if(allocated(keywords))deallocate(keywords)
   allocate(character(len=0) :: keywords(0))
   if(allocated(values))deallocate(values)
   allocate(character(len=0) :: values(0))
   if(allocated(counts))deallocate(counts)
   allocate(counts(0))
end subroutine wipe_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    update(3f) - [M_escape] update internal dictionary given keyword and value
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine update(key,val)
!!
!!    character(len=*),intent(in)           :: key
!!    character(len=*),intent(in),optional  :: val
!!
!!##DESCRIPTION
!!    Update internal dictionary in M_escape(3fm) module.
!!
!!##OPTIONS
!!    key  name of keyword to add, replace, or delete from dictionary
!!    val  if present add or replace value associated with keyword. If not
!!         present remove keyword entry from dictionary.
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_update
!!    use M_escape, only : esc, update
!!       write(*,'(a)') esc('<clear>TEST CUSTOMIZED:')
!!       ! add custom keywords
!!       call update('blink',char(27)//'[5m')
!!       call update('/blink',char(27)//'[38m')
!!
!!       write(*,'(a)') esc('<blink>Items for Friday</blink>')
!!
!!       write(*,'(a)',advance='no') esc('<r>RED</r>,')
!!       write(*,'(a)',advance='no') esc('<b>BLUE</b>,')
!!       write(*,'(a)',advance='yes') esc('<g>GREEN</g>')
!!
!!       ! delete
!!       call update('r')
!!       call update('/r')
!!       ! replace
!!       call update('b','<<<<')
!!       call update('/b','>>>>')
!!       write(*,'(a)',advance='no') esc('<r>RED</r>,')
!!       write(*,'(a)',advance='no') esc('<b>BLUE</b>,')
!!       write(*,'(a)',advance='yes') esc('<g>GREEN</g>')
!!
!!    end program demo_update
!!
!!##AUTHOR
!!    John S. Urban, 2020
!!
!!##LICENSE
!!    Public Domain
subroutine update(key,valin)
character(len=*),intent(in)           :: key
character(len=*),intent(in),optional  :: valin
integer                               :: place
integer                               :: iilen
character(len=:),allocatable          :: val
if(present(valin))then
   val=valin
   iilen=len_trim(val)
   ! find where string is or should be
   call locate(keywords,key,place)
   ! if string was not found insert it
   if(place.lt.1)then
      call insert(keywords,key,iabs(place))
      call insert(values,val,iabs(place))
      call insert(counts,iilen,iabs(place))
   else
      call replace(values,val,place)
      call replace(counts,iilen,place)
   endif
else
   call locate(keywords,key,place)
   if(place.gt.0)then
      call remove(keywords,place)
      call remove(values,place)
      call remove(counts,place)
   endif
endif
end subroutine update
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function get(key) result(valout)
character(len=*),intent(in)   :: key
character(len=:),allocatable  :: valout
integer                       :: place
   ! find where string is or should be
   call locate(keywords,key,place)
   if(place.lt.1)then
      valout=''
   else
      valout=values(place)(:counts(place))
   endif
end function get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    print_dictionary(3f) - [ARGUMENTS:M_CLI2] print internal dictionary
!!                           created by calls to update(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    subroutine print_dictionary(header)
!!
!!     character(len=*),intent(in),optional :: header
!!
!!##DESCRIPTION
!!    Print the internal dictionary created by calls to update(3f).
!!    This routine is intended to print the state of the argument list
!!    if an error occurs in using the update(3f) procedure.
!!
!!##OPTIONS
!!     HEADER  label to print before printing the state of the command
!!             argument list.
!!##EXAMPLE
!!
!!
!!   Typical usage:
!!
!!    program demo_print_dictionary
!!    use M_escape, only : esc, update, print_dictionary
!!    implicit none
!!       write(*,'(a)') esc('<clear>TEST CUSTOMIZED:')
!!       ! add custom keywords
!!       call update('blink',char(27)//'[5m')
!!       call update('/blink',char(27)//'[38m')
!!       call print_dictionary('DICTIONARY')
!!       write(*,'(a)') esc('<blink>Items for Friday</blink>')
!!    end program demo_print_dictionary
!!
!!   Sample output
!!
!!    demo_print_dictionary |cat -v -e -t
!!
!!##AUTHOR
!!      John S. Urban, 2020
!!
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine print_dictionary(header)
character(len=*),intent(in),optional :: header
integer          :: i
   if(present(header))then
      if(header.ne.'')then
         write(stderr,'(a)')header
      endif
   endif
   if(allocated(keywords))then
      if(size(keywords).gt.0)then
         write(stderr,'(*(a,t30,a))')'KEYWORD','VALUE'
         write(stderr,'(*(a,t30,"[",a,"]",/))')(trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords))
      endif
   endif
end subroutine print_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine split(input_line,array,delimiters)
!-----------------------------------------------------------------------------------------------------------------------------------

!$@(#) M_escape::split(3f): parse string on delimiter characters and store tokens into an allocatable array

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
integer                       :: ii                     ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: iilen                  ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters.ne.'')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   if(allocated(iterm))deallocate(iterm)
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   iilen=len(input_line)                                          ! IILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (iilen)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (:0)                                                      ! command was totally blank
!-----------------------------------------------------------------------------------------------------------------------------------
   case default                                                   ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,iilen,1                                  ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)).eq.0)then  ! if current character is not a delimiter
            iterm(i30)=iilen                                      ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):iilen),dlim(i10:i10))
               IF(ifound.gt.0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol.gt.iilen)then                                    ! no text left
            exit INFINITE
         endif
      enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
      ireturn=inotnull
   if(allocated(array))deallocate(array)
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
!-----------------------------------------------------------------------------------------------------------------------------------
   ii=1
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20).lt.ibegin(i20))then
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+1
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   if(allocated(ibegin))deallocate(ibegin)
   if(allocated(iterm))deallocate(iterm)
   end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    attr(3f) - [M_escape] colorize text using a simple function-based approach
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function attr(attribute) result (out)
!!
!!    character(len=*),intent(in)  :: attribute
!!    character(len=:),allocatable :: out
!!
!!##DESCRIPTION
!!    attr(3f) uses the same keywords as esc(3f) to send ANSI escape
!!    sequences to the display screen, except instead of using a pseudo-HTML
!!    string to select the codes it uses a simple colon-delimited list of
!!    the keywords.
!!
!!##OPTIONS
!!    attribute  colon, space, or comma-delimited list of attribute keywords
!!               as defined in the esc(3f) procedure.
!!    text       if supplied it is printed and then an attribute reset is added
!!
!!##RETURNS
!!    out        output the strings assigned by the keywords (by default
!!    ANSI video
!!               display escape sequences, see update(3f) )
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_attr
!!    use M_escape, only : attr, esc_mode
!!    implicit none
!!         call printme('color')
!!         call printme('plain')
!!         call printme('raw')
!!    contains
!!    subroutine printme(mymode)
!!    character(len=*),intent(in) :: mymode
!!       call esc_mode(mymode)
!!       write(*,'(a)')mymode
!!       write(*,'(*(g0))',advance='no')attr('red:BLUE:bold','Hello!'), &
!!        & 'and everything is back to defaults or ', &
!!        & attr('RED:blue:bold'),'Hello Again!', &
!!        & attr('/RED'),' Well, the text color is still blue.',attr('reset')
!!       write(*,'(*(g0))',advance='yes')' Back to a normal write statement.'
!!    end subroutine printme
!!    end program demo_attr
!!
!!##AUTHOR
!!    John S. Urban, 2020
!!
!!##LICENSE
!!    Public Domain
function attr(attribute,text) result(out)
! colon,space, or comma-delimited string of attributes
character(len=*),intent(in)          :: attribute
character(len=*),intent(in),optional :: text
character(len=:),allocatable         :: out
character(len=:),allocatable         :: array(:)
integer                              :: i
   if(.not.allocated(mode))then  ! set substitution mode
      mode='color'
      call vt102()
   endif
   out=''
   call split(attribute,array,delimiters=' :,')
   do i=1,size(array)
      if(mode=='raw')then
         out=out//'<'//trim(array(i))//'>'
      elseif(mode=='plain')then
         out=''
      else
         out=out//get(trim(array(i)))
      endif
   enddo
   if(present(text))then
   out=out//text//esc('<reset>')
   endif
end function attr
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
! one question would be if the strings should not be parameters so you could flush and reset them.
!-!subroutine color_reset()
!-!! for direct use of escape sequences
!-!
!-!! foreground colors
!-! fg_red      =  CODE_START//COLOR_FG_RED//CODE_END
!-! fg_cyan     =  CODE_START//COLOR_FG_CYAN//CODE_END
!-! fg_magenta  =  CODE_START//COLOR_FG_MAGENTA//CODE_END
!-! fg_blue     =  CODE_START//COLOR_FG_BLUE//CODE_END
!-! fg_green    =  CODE_START//COLOR_FG_GREEN//CODE_END
!-! fg_yellow   =  CODE_START//COLOR_FG_YELLOW//CODE_END
!-! fg_white    =  CODE_START//COLOR_FG_WHITE//CODE_END
!-! fg_ebony    =  CODE_START//COLOR_FG_BLACK//CODE_END
!-! fg_default  =  CODE_START//COLOR_FG_DEFAULT//CODE_END
!-!
!-!! background colors
!-! bg_red      =  CODE_START//COLOR_BG_RED//CODE_END
!-! bg_cyan     =  CODE_START//COLOR_BG_CYAN//CODE_END
!-! bg_magenta  =  CODE_START//COLOR_BG_MAGENTA//CODE_END
!-! bg_blue     =  CODE_START//COLOR_BG_BLUE//CODE_END
!-! bg_green    =  CODE_START//COLOR_BG_GREEN//CODE_END
!-! bg_yellow   =  CODE_START//COLOR_BG_YELLOW//CODE_END
!-! bg_white    =  CODE_START//COLOR_BG_WHITE//CODE_END
!-! bg_ebony    =  CODE_START//COLOR_BG_BLACK//CODE_END
!-! bg_default  =  CODE_START//COLOR_BG_DEFAULT//CODE_END
!-!
!-!! attributes
!-! bold        =  CODE_START//BOLD_ON//CODE_END
!-! italic      =  CODE_START//ITALIC_ON//CODE_END
!-! inverse     =  CODE_START//INVERSE_ON//CODE_END
!-! underline   =  CODE_START//UNDERLINE_ON//CODE_END
!-! unbold      =  CODE_START//BOLD_OFF//CODE_END
!-! unitalic    =  CODE_START//ITALIC_OFF//CODE_END
!-! uninverse   =  CODE_START//INVERSE_OFF//CODE_END
!-! ununderline =  CODE_START//UNDERLINE_OFF//CODE_END
!-!
!-! reset       =  CODE_RESET
!-! clear       =  CLEAR_DISPLAY
!-!subroutine color_reset()
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!-!subroutine color_flush()
!-!! for direct use of escape sequences
!-!
!-!! foreground colors
!-! fg_red      =  ''
!-! fg_cyan     =  ''
!-! fg_magenta  =  ''
!-! fg_blue     =  ''
!-! fg_green    =  ''
!-! fg_yellow   =  ''
!-! fg_white    =  ''
!-! fg_ebony    =  ''
!-! fg_default  =  ''
!-!
!-!! background colors
!-! bg_red      =  ''
!-! bg_cyan     =  ''
!-! bg_magenta  =  ''
!-! bg_blue     =  ''
!-! bg_green    =  ''
!-! bg_yellow   =  ''
!-! bg_white    =  ''
!-! bg_ebony    =  ''
!-! bg_default  =  ''
!-!
!-!! attributes
!-! bold        =  ''
!-! italic      =  ''
!-! inverse     =  ''
!-! underline   =  ''
!-! unbold      =  ''
!-! unitalic    =  ''
!-! uninverse   =  ''
!-! ununderline =  ''
!-!
!-! reset       =  CODE_RESET
!-! clear       =  CLEAR_DISPLAY
!-!end subroutine color_flush
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_escape
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
 
 
!>>>>> app/fpm-man.f90
program fman
use M_intrinsics, only : help_intrinsics
use M_CLI2,       only : set_args, sget, lget, topics=>unnamed
use M_match,      only : getpat, match, regex_pattern
use M_match,      only : YES, ERR
use M_strings,    only : lower, indent, atleast
use M_escape,     only : esc
implicit none
type(regex_pattern)          :: p
character(len=:),allocatable :: help_text(:), version_text(:)
character(len=256),allocatable :: manual(:),section(:)
character(len=:),allocatable :: regex
integer                      :: i, j, k
logical                      :: topic
logical                      :: prefix, ignorecase, demo, color
integer                      :: start_keep, end_keep
    ! process command line
    call setup()
    call set_args(' --regex:e " " --ignorecase:i F --topic_only:t F --demo:d F --color:c',&
    & help_text,version_text)
    regex=sget('regex')
    topic=lget('topic_only')
    ignorecase=lget('ignorecase')
    demo=lget('demo')
    color=lget('color')

    ! if -t then just show topic names and exit
    if(topic)then
       manual = help_intrinsics('',topic=topic)
       ! could truncate if name is too long, could get a bit fancier or use
       ! M_display(3f) and have default just print one per line
       write(*,'(3(g0))') ( [character(len=80/3) :: manual(i)], i=1, size(manual) )
       stop
    endif

    ! compile any regular expression
    ! Also, if doing a regular expression and not the single topic "toc"
    ! add a section prefix when building manual


    ! initially assume prefixing is off unless a regular expression is used
    if(regex.ne.' ')then
       prefix=.true.
    else
       prefix=.false.
    endif

    ! normalize the topics list
    ! ensure there is at least one topic by applying a default
    if(size(topics).eq.0)then
       topics=['toc']
    endif

    if( ( size(topics).eq.1 .and. topics(1).eq.'toc') )then
       prefix=.false.
       ignorecase=.true.
    endif

    if(regex.ne.' ')then
       if (getpat(merge(lower(regex),regex,ignorecase), p%pat) .eq. ERR) then
          stop '*fman* Illegal pattern.'
       endif
    endif

    if(lget('verbose'))then
       write(*,'(*(g0:,1x))')'<INFO>AFTER NORMALIZING:'
       write(*,'(*(g0:,1x))')'<INFO>REGEX       ',regex
       write(*,'(*(g0:,1x))')'<INFO>IGNORECASE  ',ignorecase
       write(*,'(*(g0:,1x))')'<INFO>TOPIC_ONLY  ',topic
       write(*,'(*(g0:,1x))')'<INFO>PREFIX      ',prefix
       write(*,'(*(g0:,1x))')'<INFO>DEMO        ',demo
       write(*,'(*(g0:,1x))')'<INFO>TOPICS      ',topics
    endif
    ! build text to display or search
    manual=[character(len=0) ::]
    do i=1, size(topics)
       section = help_intrinsics(topics(i),prefix=prefix)
       if(color)section=crayons(section)

       ! extract demo program if found (has to follow specific format)
       if(demo)then
          call find_demo()
       endif

       manual = [character(len=max(len(manual),len(section))) :: manual,section]
    enddo

    ! display selected text
    if(size(manual).eq.0)then
       write(*,'(g0)')'Sorry. did not find that. Perhaps you should search the TOC. try'
       write(*,'(g0)')'   fman -e TOPIC'
       write(*,'(g0)')'or search the entire manual:'
       write(*,'(g0)')'   fman manual -i -e TOPIC'
       stop 1
    else
       ! display what was found
       do i=1,size(manual)
          if(regex.ne.'')then
             select case(ignorecase)
             case(.true.)
                if(match(lower(trim(manual(i)))//char(10), p%pat) .eq. YES) then
                  write(*,'(g0)')trim(manual(i))
                endif
             case(.false.)
                if (match(trim(manual(i))//char(10), p%pat) .eq. YES) then
                  write(*,'(g0)')trim(manual(i))
                endif
             end select
          else
             write(*,'(g0)')trim(manual(i))
          endif
       enddo
    endif
contains
subroutine find_demo()
character(len=256),allocatable :: newsection(:)
integer :: ii,jj,kk
   if(allocated(newsection)) deallocate(newsection)
   allocate(newsection(0))
   if(demo)then
      start_keep=0
      end_keep=0
      jj=0
      do ii=1,size(section)
         jj=jj+1
         if(jj.gt.size(section))exit
         if(index(lower(section(jj)),'program demo_').ne.0)then
            start_keep=jj
            do kk=start_keep+1,size(section)
               if(kk.gt.size(section))exit
               if(index(lower(section(kk)),'end program demo_').ne.0)then
                  end_keep=kk
                  if(start_keep.ne.0 .and. end_keep.ne.0)then
                     newsection=[character(len=max(len(newsection),len(section))) :: newsection,section(start_keep:end_keep)]
                     jj=kk+1
                  endif
                  exit
               endif
            enddo
         endif
      enddo
    endif
    if(size(newsection).eq.0)then
       write(*,*)'!<ERROR> *fman* standard demo code format not found for ',trim(topics(i))
       section=['']
    else
       section=newsection
       deallocate(newsection)
    endif
end subroutine find_demo
function crayons(oldblock) result(newblock)
! just playing. There is a lot of stuff not done robustly here
character(len=256),intent(in),allocatable :: oldblock(:)
character(len=256),allocatable :: newblock(:)
integer :: ilen
integer :: lead
logical :: program_text
   program_text=.false.
   newblock= oldblock
   do j=1,size(oldblock)
      if( index(oldblock(j),'end program demo_') .eq. 0 .and. index(oldblock(j),'program demo_') .ne. 0)then
         program_text=.true.
         lead=indent(oldblock(j))
      endif
      if(program_text .eqv. .true.)then
        newblock(j)=esc('<E>'//repeat(' ',lead)//'<E><y>'//atleast(oldblock(j)(lead+1:),80-lead) )
      elseif(verify(oldblock(j)(1:1), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' ) == 0 .and. &
      & verify(oldblock(j), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ _') == 0 )then
         ilen=len_trim(oldblock(j))
         newblock(j)=esc('<E><y><bo> '//trim(oldblock(j))//' </bo>'//repeat(' ',max(0,80-ilen-2))//'<reset>')
       else
          ilen=len_trim(oldblock(j))
          ilen=len_trim(than(oldblock(j)))-ilen
          newblock(j)=esc('<E><w>'//atleast(than(oldblock(j)),80+ilen)//'<reset>')
       endif
      if( index(oldblock(j),'end program demo_') .ne.0)then
         program_text=.false.
      endif
   enddo
end function crayons

function than(in) result(out)
character(len=*),intent(in)  :: in
character(len=:),allocatable :: out
integer                      :: i
   out=''
   do i=1,len_trim(in)
      select case(in(i:i))
      case('<')
         out=out//'<lt>'
      case('>')
         out=out//'<gt>'
      case default
         out=out//in(i:i)
      endselect
   enddo
end function than

subroutine setup()
help_text=[ CHARACTER(LEN=128) :: &
'NAME                                                                            ',&
'    fman(1f) - [DEVELOPER] output descriptions of Fortran intrinsics         ',&
'    (LICENSE:PD)                                                                ',&
'                                                                                ',&
'SYNOPSIS                                                                        ',&
'    fman NAME(s) [[-ignorecase][--regex Regular_Expression]]|[-topic_only]   ',&
'                [--color][--demo]                                               ',&
'                                                                                ',&
'    fman [ --help| --version]                                                ',&
'                                                                                ',&
'DESCRIPTION                                                                     ',&
'   fman(1) prints descriptions of Fortran intrinsics as simple flat text.    ',&
'                                                                                ',&
'   The text is formatted in the txt2man(1) markdown language so one can easily  ',&
'   generate man-pages on ULS (Unix-Like Systems).                               ',&
'                                                                                ',&
'OPTIONS                                                                         ',&
'  TOPIC(s)          A list of Fortran intrinsic names or the special names      ',&
'                    "toc" and "manual" (which generate a table of contents      ',&
'                    and the entire set of documents respecively).               ',&
'                    The default is "toc" and to ignore case.                    ',&
'  --regex,-e        Search all output per the provided Regular Expression.      ',&
'                    Output is prefixed with the topic it was found in.          ',&
'  --itopic_only,-t  Only show topic names. Other switches are ignored.          ',&
'  --ignorecase,-i   Ignore case when searching for a Regular Expression.        ',&
'  --demo,-d         extract first demo program found for a topic (starting with ',&
'                    "program demo_" and ending with "end program demo_").       ',&
'  --color           Use ANSI in-line escape sequences to display the text in    ',&
'                    set colors. Does not work with all terminal emulators or    ',&
'                    terminals. Must use the -r switch with less(1) for less(1)  ',&
'                    to display colors.                                          ',&
'  --help            Display this help and exit                                  ',&
'  --version         Output version information and exit                         ',&
'                                                                                ',&
'EXAMPLES                                                                        ',&
'  Sample commands                                                               ',&
'                                                                                ',&
'   fman                 # list table of contents                             ',&
'   fman -e character    # check TOC for string. try "trigo","size","complex" ',&
'   fman tan|less        # display a description of tan(3f)                   ',&
'                                                                                ',&
'   fman --regex ''character'' # look for string in the TOC ignoring case     ',&
'                                                                                ',&
'   fman manual>fortran.txt    # create a copy of all descriptions            ',&
'                                                                                ',&
'   # list the topic "scan" if found and lines containing "scan" from the entire ',&
'   # manual, prefixing the lines with the section name, while ignoring case.    ',&
'   fman -e scan -i manual                                                    ',&
'                                                                                ',&
'   fman -d verify >demo_verify.f90 # get sample program to try VERIFY(3f).   ',&
'']

version_text=[ CHARACTER(LEN=128) :: &
'PRODUCT:         GPF (General Purpose Fortran) utilities and examples           ',&
'PROGRAM:         fman(1)                                                     ',&
'DESCRIPTION:     output Fortran intrinsic descriptions                          ',&
!'VERSION:         1.0.0, 20201215                                               ',&
!'VERSION:         1.0.1, 20201217                                               ',&
'VERSION:         1.0.2, 202100108                                               ',&
'AUTHOR:          John S. Urban                                                  ',&
'HOME PAGE:       http://www.urbanjost.altervista.org/index.html                 ',&
'LICENSE:         MIT License                                                    ',&
'']

end subroutine setup
end program fman
! kludge1: older versions of gfortran do not handle character arrays with both line and size allocatable
 
