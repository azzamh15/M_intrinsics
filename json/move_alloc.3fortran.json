{"blocks":[{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"Name"}]}]]},{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"move_alloc"}]},{"t":"Str","c":"(3)"},{"t":"Space"},{"t":"Str","c":"-"},{"t":"Space"},{"t":"Str","c":"[MEMORY]"},{"t":"Space"},{"t":"Str","c":"Move"},{"t":"Space"},{"t":"Str","c":"allocation"},{"t":"Space"},{"t":"Str","c":"from"},{"t":"Space"},{"t":"Str","c":"one"},{"t":"Space"},{"t":"Str","c":"object"},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Str","c":"another"}]},{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"Synopsis"}]}]]},{"t":"CodeBlock","c":[["",["fortran"],[]],"    call move_alloc(from, to [,stat] [,errmsg] )\n"]},{"t":"CodeBlock","c":[["",["fortran"],[]],"     subroutine move_alloc(from, to)\n\n      type(TYPE(kind=**)),intent(inout),allocatable :: from(..)\n      type(TYPE(kind=**)),intent(out),allocatable   :: to(..)\n      integer(kind=**),intent(out)   :: stat\n      character(len=*),intent(inout) :: errmsg\n"]},{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"Characteristics"}]}]]},{"t":"BulletList","c":[[{"t":"Plain","c":[{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"Space"},{"t":"Str","c":"may"},{"t":"Space"},{"t":"Str","c":"be"},{"t":"Space"},{"t":"Str","c":"of"},{"t":"Space"},{"t":"Str","c":"any"},{"t":"Space"},{"t":"Str","c":"type"},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"kind."}]}],[{"t":"Plain","c":[{"t":"Strong","c":[{"t":"Str","c":"to"}]},{"t":"Space"},{"t":"Str","c":"shall"},{"t":"Space"},{"t":"Str","c":"be"},{"t":"Space"},{"t":"Str","c":"of"},{"t":"Space"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"same"},{"t":"Space"},{"t":"Str","c":"type,"},{"t":"Space"},{"t":"Str","c":"kind"},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"rank"},{"t":"Space"},{"t":"Str","c":"as"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"Str","c":"."}]}]]},{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"Description"}]}]]},{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"move_alloc"}]},{"t":"Str","c":"(3)"},{"t":"Space"},{"t":"Str","c":"moves"},{"t":"Space"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"allocation"},{"t":"Space"},{"t":"Str","c":"from"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"Space"},{"t":"Str","c":"to"},{"t":"SoftBreak"},{"t":"Strong","c":[{"t":"Str","c":"to"}]},{"t":"Str","c":"."},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"Space"},{"t":"Str","c":"will"},{"t":"Space"},{"t":"Str","c":"become"},{"t":"Space"},{"t":"Str","c":"deallocated"},{"t":"Space"},{"t":"Str","c":"in"},{"t":"Space"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"process."}]},{"t":"Para","c":[{"t":"Str","c":"This"},{"t":"Space"},{"t":"Str","c":"is"},{"t":"Space"},{"t":"Str","c":"potentially"},{"t":"Space"},{"t":"Str","c":"more"},{"t":"Space"},{"t":"Str","c":"efficient"},{"t":"Space"},{"t":"Str","c":"than"},{"t":"Space"},{"t":"Str","c":"other"},{"t":"Space"},{"t":"Str","c":"methods"},{"t":"Space"},{"t":"Str","c":"of"},{"t":"Space"},{"t":"Str","c":"assigning"},{"t":"SoftBreak"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"values"},{"t":"Space"},{"t":"Str","c":"in"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"to"}]},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"explicitly"},{"t":"Space"},{"t":"Str","c":"deallocating"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"Str","c":","},{"t":"SoftBreak"},{"t":"Str","c":"which"},{"t":"Space"},{"t":"Str","c":"are"},{"t":"Space"},{"t":"Str","c":"far"},{"t":"Space"},{"t":"Str","c":"more"},{"t":"Space"},{"t":"Str","c":"likely"},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Str","c":"require"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"temporary"},{"t":"Space"},{"t":"Str","c":"object"},{"t":"Space"},{"t":"Str","c":"or"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"copy"},{"t":"Space"},{"t":"Str","c":"of"},{"t":"SoftBreak"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"elements"},{"t":"Space"},{"t":"Str","c":"of"},{"t":"Space"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"array."}]},{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"Options"}]}]]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"SoftBreak"},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"The"},{"t":"Space"},{"t":"Str","c":"data"},{"t":"Space"},{"t":"Str","c":"object"},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Str","c":"be"},{"t":"Space"},{"t":"Str","c":"moved"},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"to"}]},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"deallocated."}]}],[{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"to"}]},{"t":"SoftBreak"},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"The"},{"t":"Space"},{"t":"Str","c":"destination"},{"t":"Space"},{"t":"Str","c":"data"},{"t":"Space"},{"t":"Str","c":"object"},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Str","c":"move"},{"t":"Space"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"allocated"},{"t":"Space"},{"t":"Str","c":"data"},{"t":"Space"},{"t":"Str","c":"object"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"SoftBreak"},{"t":"Str","c":"to."},{"t":"Space"},{"t":"Str","c":"Typically,"},{"t":"Space"},{"t":"Str","c":"it"},{"t":"Space"},{"t":"Str","c":"is"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"different"},{"t":"Space"},{"t":"Str","c":"shape"},{"t":"Space"},{"t":"Str","c":"than"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"from"}]},{"t":"Str","c":"."}]}],[{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"stat"}]},{"t":"SoftBreak"},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"If"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"stat"}]},{"t":"Space"},{"t":"Str","c":"is"},{"t":"Space"},{"t":"Str","c":"present"},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"execution"},{"t":"Space"},{"t":"Str","c":"is"},{"t":"Space"},{"t":"Str","c":"successful,"},{"t":"Space"},{"t":"Str","c":"it"},{"t":"Space"},{"t":"Str","c":"is"},{"t":"Space"},{"t":"Str","c":"assigned"},{"t":"Space"},{"t":"Str","c":"the"},{"t":"SoftBreak"},{"t":"Str","c":"value"},{"t":"Space"},{"t":"Str","c":"zero."},{"t":"SoftBreak"},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"If"},{"t":"Space"},{"t":"Str","c":"an"},{"t":"Space"},{"t":"Str","c":"error"},{"t":"Space"},{"t":"Str","c":"condition"},{"t":"Space"},{"t":"Str","c":"occurs,"}]},{"t":"CodeBlock","c":[["",[],[]],"o if **stat** is absent, error termination is initiated;\no otherwise, if **from** is a coarray and the current team contains a\n  stopped image, **stat** is assigned the value STAT\\_STOPPED\\_IMAGE\n  from the intrinsic module ISO\\_FORTRAN\\_ENV;\no otherwise, if **from** is a coarray and the current team contains\na failed image, and no other error condition\n  occurs, **stat** is assigned the value STAT\\_FAILED\\_IMAGE from the\n  intrinsic module ISO\\_FORTRAN\\_ENV;\no otherwise, **stat** is assigned a processor-dependent positive value\n  that differs from that of STAT\\_STOPPED\\_IMAGE or STAT\\_FAILED\\_IMAGE.\n"]}],[{"t":"Para","c":[{"t":"Strong","c":[{"t":"Str","c":"errmsg"}]},{"t":"SoftBreak"},{"t":"Str","c":":"},{"t":"Space"},{"t":"Str","c":"If"},{"t":"Space"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"errmsg"}]},{"t":"Space"},{"t":"Str","c":"argument"},{"t":"Space"},{"t":"Str","c":"is"},{"t":"Space"},{"t":"Str","c":"present"},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"an"},{"t":"Space"},{"t":"Str","c":"error"},{"t":"Space"},{"t":"Str","c":"condition"},{"t":"Space"},{"t":"Str","c":"occurs,"},{"t":"SoftBreak"},{"t":"Str","c":"it"},{"t":"Space"},{"t":"Str","c":"is"},{"t":"Space"},{"t":"Str","c":"assigned"},{"t":"Space"},{"t":"Str","c":"an"},{"t":"Space"},{"t":"Str","c":"explanatory"},{"t":"Space"},{"t":"Str","c":"message."},{"t":"Space"},{"t":"Str","c":"If"},{"t":"Space"},{"t":"Str","c":"no"},{"t":"Space"},{"t":"Str","c":"error"},{"t":"Space"},{"t":"Str","c":"condition"},{"t":"Space"},{"t":"Str","c":"occurs,"},{"t":"SoftBreak"},{"t":"Str","c":"the"},{"t":"Space"},{"t":"Str","c":"definition"},{"t":"Space"},{"t":"Str","c":"status"},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"value"},{"t":"Space"},{"t":"Str","c":"of"},{"t":"Space"},{"t":"Strong","c":[{"t":"Str","c":"errmsg"}]},{"t":"Space"},{"t":"Str","c":"are"},{"t":"Space"},{"t":"Str","c":"unchanged."}]}]]},{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"Examples"}]}]]},{"t":"Para","c":[{"t":"Str","c":"Basic"},{"t":"Space"},{"t":"Str","c":"sample"},{"t":"Space"},{"t":"Str","c":"program"},{"t":"Space"},{"t":"Str","c":"to"},{"t":"Space"},{"t":"Str","c":"allocate"},{"t":"Space"},{"t":"Str","c":"a"},{"t":"Space"},{"t":"Str","c":"bigger"},{"t":"Space"},{"t":"Str","c":"grid"}]},{"t":"CodeBlock","c":[["",["fortran"],[]],"program demo_move_alloc\nimplicit none\n! Example to allocate a bigger GRID\nreal, allocatable :: grid(:), tempgrid(:)\ninteger :: n, i\n\n   ! initialize small GRID\n   n = 3\n   allocate (grid(1:n))\n   grid = [ (real (i), i=1,n) ]\n\n   ! initialize TEMPGRID which will be used to replace GRID\n   allocate (tempgrid(1:2*n))    ! Allocate bigger grid\n   tempgrid(::2)  = grid         ! Distribute values to new locations\n   tempgrid(2::2) = grid + 0.5   ! initialize other values\n\n   ! move TEMPGRID to GRID\n   call MOVE_ALLOC (from=tempgrid, to=grid)\n\n   ! TEMPGRID should no longer be allocated\n   ! and GRID should be the size TEMPGRID was\n   if (size (grid) /= 2*n .or. allocated (tempgrid)) then\n      print *, \"Failure in move_alloc!\"\n   endif\n   print *, allocated(grid), allocated(tempgrid)\n   print '(99f8.3)', grid\nend program demo_move_alloc\n"]},{"t":"Para","c":[{"t":"Str","c":"Results:"}]},{"t":"CodeBlock","c":[["",["text"],[]],"    T F\n      1.000   1.500   2.000   2.500   3.000   3.500\n"]},{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"Standard"}]}]]},{"t":"Para","c":[{"t":"Str","c":"Fortran"},{"t":"Space"},{"t":"Str","c":"2003,"},{"t":"Space"},{"t":"Str","c":"STAT"},{"t":"Space"},{"t":"Str","c":"and"},{"t":"Space"},{"t":"Str","c":"ERRMSG"},{"t":"Space"},{"t":"Str","c":"options"},{"t":"Space"},{"t":"Str","c":"added"},{"t":"Space"},{"t":"Str","c":"2018"}]},{"t":"Header","c":[3,["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"See"},{"t":"Space"},{"t":"Str","c":"Also"}]}]]},{"t":"Para","c":[{"t":"Link","c":[["",[],[]],[{"t":"Strong","c":[{"t":"Str","c":"allocated"}]},{"t":"Str","c":"(3)"}],["#allocated",""]]}]},{"t":"Para","c":[{"t":"Emph","c":[{"t":"Str","c":"fortran-lang"},{"t":"Space"},{"t":"Str","c":"intrinsic"},{"t":"Space"},{"t":"Str","c":"descriptions"}]}]},{"t":"RawBlock","c":["html","<!--\n    35  2 Class. Subroutine, pure if and only if FROM is not a coarray.\n    1   3 Arguments.\n    2     FROM      may be of any type, rank, and corank. It shall be allocatable and shall not be a coindexed object.\n    3               It is an INTENT (INOUT) argument.\n    4     TO        shall be type compatible (7.3.2.3) with FROM and have the same rank and corank. It shall be\n    5               allocatable and shall not be a coindexed object. It shall be polymorphic if FROM is polymorphic.\n    6               It is an INTENT (OUT) argument. Each nondeferred parameter of the declared type of TO shall\n    7               have the same value as the corresponding parameter of the declared type of FROM.\n    8     STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an\n    9               INTENT (OUT) argument.\n    10    ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.\n\n    11  4 If execution of MOVE_ALLOC is successful, or if STAT_FAILED_IMAGE is assigned to STAT,\n    12          On invocation of MOVE_ALLOC, if the allocation status of TO is allocated, it is deallocated. Then,\n    13        if FROM has an allocation status of allocated on entry to MOVE_ALLOC, TO becomes allocated with\n    14        dynamic type, type parameters, bounds, cobounds, and value identical to those that FROM had on entry\n    15        to MOVE_ALLOC. Note that if FROM and TO are the same variable, it shall be unallocated when\n    16        MOVE_ALLOC is invoked.\n    17          If TO has the TARGET attribute, any pointer associated with FROM on entry to MOVE_ALLOC becomes\n    18        correspondingly associated with TO. If TO does not have the TARGET attribute, the pointer association\n    19        status of any pointer associated with FROM on entry becomes undefined.\n    20          The allocation status of FROM becomes unallocated.\n    21  5 When a reference to MOVE_ALLOC is executed for which the FROM argument is a coarray, there is an implicit\n    22    synchronization of all active images of the current team. On those images, execution of the segment (11.6.2)\n    23    following the CALL statement is delayed until all other active images of the current team have executed the same\n    24    statement the same number of times. When such a reference is executed, if any image of the current team has\n    25    stopped or failed, an error condition occurs.\n    38  9 Example. The example below demonstrates reallocation of GRID to twice its previous size, with its previous\n    39    contents evenly distributed over the new elements so that intermediate points can be inserted.\n    40          REAL,ALLOCATABLE :: GRID(:),TEMPGRID(:)\n    41          . . .\n    42          ALLOCATE(GRID(-N:N))   ! initial allocation of GRID\n    43          . . .\n    44          ALLOCATE(TEMPGRID(-2*N:2*N)) ! allocate bigger grid\n    45          TEMPGRID(::2)=GRID ! distribute values to new locations\n    46          CALL MOVE_ALLOC(TO=GRID,FROM=TEMPGRID)\n     1      The old grid is deallocated because TO is INTENT (OUT), and GRID then takes over the new grid allocation.\n                NOTE1\n                It is expected that the implementation of allocatable objects will typically involve descriptors to locate the\n                allocated storage; MOVE_ALLOC could then be implemented by transferring the contents of the descriptor\n                for FROM to the descriptor for TO and clearing the descriptor for FROM.\n-->\n"]}],"pandoc-api-version":[1,17,5,4],"meta":{}}
