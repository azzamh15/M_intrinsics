." Text automatically generated by txt2man
.TH "lle" "3fortran" "October 07, 2020" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------
.SH NAME
\fBlle(3f) \fP- [FORTRAN:INTRINSIC:CHARACTER] Lexical less than or equal
\fB
.SH SYNTAX
result = \fBlle\fP(STR_A, STR_B)
.PP
\fBcharacter\fP(len=*),intent(in) :: STR_A, STR_B
or
\fBcharacter\fP(len=*),intent(in) :: STR_A, \fBSTR_B\fP(*)
logical :: result
.SH DESCRIPTION
Determines whether one string is lexically less than or equal to
another string, where the two strings are interpreted as containing
ASCII character codes. If the String A and String B are not the same
length, the shorter is compared as if spaces were appended to it to
form a value that has the same length as the longer. Leading spaces
are significant.
.PP
In general, the lexical comparison intrinsics LGE, LGT, LLE, and LLT
differ from the corresponding intrinsic operators .ge., .gt., .le.,
and .lt., in that the latter use the processor's character ordering
(which is not ASCII on some targets), whereas the former always use
the ASCII ordering.
.SH ARGUMENTS
.TP
.B STR_A
variable or array of default CHARACTER type.
.TP
.B STR_B
variable or array of default CHARACTER type.
.PP
.nf
.fam C
            if STR_A and STR_B are both arrays they must be of the
            same shape.

.fam T
.fi
.SH RETURN VALUE
.TP
.B RESULT
Returns .TRUE. if STR_A <= STR_B, and .FALSE.
otherwise, based on the ASCII ordering.
.SH EXAMPLE
Sample program:
.PP
.nf
.fam C
   program demo_lle
   implicit none
   integer             :: i
      write(*,'(*(a))')(char(i),i=32,126)
        write(*,*) lle('abc','ABC')              ! F lowercase is > uppercase
        write(*,*) lle('abc','abc  ')            ! T trailing spaces
        ! If both strings are of zero length the result is true.
        write(*,*) lle('','')                    ! T
        write(*,*) lle('','a')                   ! T the null string is padded
        write(*,*) lle('a','')                   ! F
        write(*,*) lle('abc',['abc','123'])      ! [T,F] scalar and array
        write(*,*) lle(['cba', '123'],'abc')     ! [F,T]
        write(*,*) lle(['abc','123'],['cba','123']) ! [T,T] both arrays
   end program demo_lle

.fam T
.fi
.RS
Results:
.PP
.nf
.fam C
   > !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
   > [\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
   > F
   > T
   > T
   > T
   > F
   > T F
   > F T
   > T T

.fam T
.fi
.SH STANDARD
[[FORTRAN 77]] and later
.SH CLASS
[[Elemental procedure|Elemental function]]
.SH SEE ALSO
\fBlge\fP(3), \fBlgt\fP(3), \fBllt\fP(3)
.PP
Functions that perform operations on character strings, return lengths
of arguments, and search for certain arguments:
.TP
.B Elemental:
\fBadjustl\fP(3), \fBadjustr\fP(3), \fBindex\fP(3), \fBlen_trim\fP(3),
\fBscan\fP(3), \fBverify\fP(3)
.TP
.B Nonelemental:
\fBrepeat\fP(3), \fBtrim\fP(3)
