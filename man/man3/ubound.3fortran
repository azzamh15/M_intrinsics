." Text automatically generated by txt2man
.TH "ubound" "3fortran" "July 01, 2020" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------
.SH NAME
\fB
\fBubound(3f) \fP- [FORTRAN:INTRINSIC:ARRAY INQUIRY] Upper dimension bounds of an array
\fB
.SH SYNTAX

result = \fBubound\fP(array [, dim [, kind]])
.SH DESCRIPTION

Returns the upper bounds of an array, or a single upper bound
along the DIM dimension.
.SH ARGUMENTS

.TP
.B ARRAY
Shall be an array, of any type.
.TP
.B DIM
(Optional) Shall be a scalar INTEGER.
.TP
.B KIND
(Optional) An INTEGER initialization expression
indicating the kind parameter of the result.
.SH RETURN VALUE

The return value is of type INTEGER and of kind KIND. If KIND is
absent, the return value is of default integer kind. If DIM is absent,
the result is an array of the upper bounds of ARRAY. If DIM is present,
the result is a scalar corresponding to the upper bound of the array
along that dimension. If ARRAY is an expression rather than a whole
array or array structure component, or if it has a zero extent along
the relevant dimension, the upper bound is taken to be the number of
elements along the relevant dimension.
.SH EXAMPLE
Note that in my opinion this function should not be used on assumed-size arrays
or in any function without an explicit interface. Errors can occur if there is
no interface defined.
.RE
.PP
Sample program
.PP
.nf
.fam C
  ! program demo_ubound
  module m_bounds
   contains
      subroutine msub(arr)
         !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array
         integer,intent(in) :: arr(:)
         write(*,*)'MSUB: LOWER=',lbound(arr),'UPPER=',ubound(arr),'SIZE=',size(arr)
      end subroutine msub
   end module m_bounds

   use m_bounds, only : msub
   implicit none
   interface
      subroutine esub(arr)
      integer,intent(in) :: arr(:)
      end subroutine esub
   end interface
   integer :: arr(-10:10)
      write(*,*)'MAIN: LOWER=',lbound(arr),'UPPER=',ubound(arr),'SIZE=',size(arr)
      call csub()
      call msub(arr)
      call esub(arr)
   contains
      subroutine csub
         write(*,*)'CSUB: LOWER=',lbound(arr),'UPPER=',ubound(arr),'SIZE=',size(arr)
      end subroutine csub
   end

   subroutine esub(arr)
   integer,intent(in) :: arr(:)
      ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)
      write(*,*)'ESUB: LOWER=',lbound(arr),'UPPER=',ubound(arr),'SIZE=',size(arr)
   end subroutine esub
  !end program demo_ubound

.fam T
.fi
.RS
Expected output
.PP
.nf
.fam C
  MAIN: LOWER=         -10 UPPER=          10 SIZE=          21
  CSUB: LOWER=         -10 UPPER=          10 SIZE=          21
  MSUB: LOWER=           1 UPPER=          21 SIZE=          21
  ESUB: LOWER=           1 UPPER=          21 SIZE=          21

.fam T
.fi
.SH STANDARD

[[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later
.SH CLASS

[[Inquiry function]]
.SH SEE ALSO

[[lbound]], [[co_ubound]], [[co_lbound]]
