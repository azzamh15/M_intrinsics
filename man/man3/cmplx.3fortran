." Text automatically generated by txt2man
.TH "cmplx" "3fortran" "November 20, 2021" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------
.SH NAME
\fBcmplx\fP(3f) - [FORTRAN:INTRINSIC:NUMERIC:TYPE] Complex conversion function

.SH SYNTAX
result = \fBcmplx\fP(x [, y [, kind]])
.SH DESCRIPTION
To convert numeric variables to complex, use the CMPLX function.
Constants can be used to define a complex variable using the syntax
.PP
.nf
.fam C
      z8 = (1.2345678901234567d0, 1.2345678901234567d0)

.fam T
.fi
but this will not work for variables. You must use the CMPLX function.
.PP
\fBCMPLX\fP(X [, Y [, KIND]]) returns a complex number where X is converted
to the real component. If X is complex then Y must not be present.
If Y is present it is converted to the imaginary component. If Y is
not present then the imaginary component is set to 0.0.
.SS   CMPLX AND DOUBLE PRECISION

The Fortran 90 language defines \fBCMPLX\fP() as always returning a result
that is type \fBCOMPLEX\fP(KIND=KIND(0.0)).
.PP
This means `\fBCMPLX\fP(D1,D2)', where `D1' and `D2' are DOUBLEPRECISION,
is treated as:
.PP
.nf
.fam C
      CMPLX(SNGL(D1), SNGL(D2))

.fam T
.fi
DOUBLEPRECISION complex numbers require specifying a precision.
.PP
It was necessary for Fortran 90 to specify this behavior for
DOUBLEPRECISION arguments, since that is the behavior mandated by
FORTRAN 77.
.PP
So Fortran 90 extends the \fBCMPLX\fP() intrinsic by adding an extra argument
used to specify the desired kind of complex result.
.PP
.nf
.fam C
      integer,parameter :: dp=kind(0.0d0)
      complex(kind=dp) :: z8
      !
      ! NO: result is just the precision of default REAL values
      !     because KIND parameter is not specified
      !
      ! note this was stored with default real precision
      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0)
      print *, 'NO, Z8=',z8,real(z8),aimag(z8)
      z8 = cmplx(1.2345678901234567e0_dp, 1.2345678901234567e0_dp)
      ! again, note components are just REAL
      print *, 'NO, Z8=',z8,real(z8),aimag(z8)
      !
      ! YES
      !
      ! kind= makes it work
      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp)
      print *, 'YES, Z8=',z8,real(z8),aimag(z8)

.fam T
.fi
F2018 COMPONENT SYNTAX
The real and imaginary parts of a complex entity can be accessed
independently with a component-like syntax in f2018:
.PP
A complex-part-designator is
.PP
.nf
.fam C
      designator % RE
      or
      designator % IM.

.fam T
.fi
Where the designator is of complex type.
.PP
So designator%RE designates the real part of a complex value,
designator%IM designates the imaginary part of complex value. The
type of a complex-part-designator is REAL, and its kind and shape
are those of the designator.
.PP
The following are examples of complex part designators:
.PP
.nf
.fam C
       impedance%re           !-- Same value as REAL(impedance)
       fft%im                 !-- Same value as AIMAG(fft)
       x%im = 0.0             !-- Sets the imaginary part of X to zero

.fam T
.fi
.SH ARGUMENTS
.TP
.B X
The type may be INTEGER, REAL, or COMPLEX.
.TP
.B Y
(Optional; only allowed if X is not COMPLEX.).
May be INTEGER or REAL.
.TP
.B KIND
(Optional) An INTEGER initialization expression
indicating the kind parameter of the result.
.SH RETURN VALUE
The return value is of COMPLEX type, with a kind equal to
KIND if it is specified. If KIND is not specified, the
result is of the default COMPLEX kind, regardless of the kinds of
X and Y.
.RE
.PP

.SH EXAMPLE
Sample program:
.PP
.nf
.fam C
   program demo_aimag
   implicit none
   integer,parameter :: dp=kind(0.0d0)
   complex          :: z4
   complex(kind=dp) :: z8
      z4 = cmplx(1.23456789, 1.23456789)
      print *, 'Z4=',z4
      ! using kind=dp makes it keep DOUBLEPRECISION precision
      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp)
      print *, 'Z8=',z8
      ! NOTE:
      ! The following is intuitive and works without calling cmplx(3f)
      ! but does not work for variables just constants
      z8 = (1.2345678901234567d0 , 1.2345678901234567d0 )
      print *, 'Z8 defined with constants=',z8
   end program demo_aimag

.fam T
.fi
Typical Results:
.PP
.nf
.fam C
    Z4= (1.23456788,1.23456788)
    Z8= (1.2345678901234567,1.2345678901234567)
    Z8 defined with constants= (1.2345678901234567,1.2345678901234567)

.fam T
.fi
.SH SEE ALSO
.IP \(bu 3
\fBaimag\fP(3f) - Imaginary part of complex number
.IP \(bu 3
\fBcmplx\fP(3f) - Complex conversion function
.IP \(bu 3
\fBconjg\fP(3f) - Complex conjugate function
.IP \(bu 3
\fBreal\fP(3f) - Convert to real type
.SH STANDARD
[[FORTRAN 77]] and later
.SH CLASS
[[Elemental procedure|Elemental function]]
