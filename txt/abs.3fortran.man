NAME

ABS(3) - [NUMERIC] Absolute value

SYNTAX

      result = abs(a)

       TYPE(kind=KIND) elemental function abs(a)

       TYPE(kind=KIND),intent(in) :: a

where the TYPE and KIND is determined by the type and type attributes of
A, which may be any real, integer, or complex value.

If the type of A is complex the type returned will be real with the same
kind as the real part of the input value.

Otherwise the returned type will be the same type as A.

DESCRIPTION

ABS(A) computes the absolute value of numeric argument A.

In mathematics, the absolute value or modulus of a real number X,
denoted |X|, is the magnitude of X without regard to its sign.

The absolute value of a number may be thought of as its distance from
zero, which is the definition used by ABS(3) when dealing with complex
values (see below).

ARGUMENTS

-   A : the type of the argument shall be an integer, real, or complex
    scalar or array.

RETURNS

If A is of type integer or real, the value of the result is |A| and of
the same type and kind as the input argument.

(Take particular note) if A is complex with value (X, Y), the result is
a real equal to a processor-dependent approximation to SQRT(X**2 + Y**2)
computed without undue overflow or underflow.

EXAMPLES

Sample program:

    program demo_abs
    implicit none
    integer           :: i = -1
    real              :: x = -1.0
    complex           :: z = (-3.0,-4.0)
    doubleprecision   :: rr = -45.78d+00
    character(len=*),parameter :: &
     frmt =  '(1x,a15,1x," In: ",g0,            T51," Out: ",g0)', &
     frmtc = '(1x,a15,1x," In: (",g0,",",g0,")",T51," Out: ",g0)'
    integer,parameter :: dp=kind(0.0d0)

      ! any integer, real, or complex type
        write(*, frmt)  'integer         ',  i, abs(i)
        write(*, frmt)  'real            ',  x, abs(x)
        write(*, frmt)  'doubleprecision ', rr, abs(rr)
        write(*, frmtc) 'complex         ',  z, abs(z)

      ! any value whose positive value is representable
      ! A dusty corner is that abs(-huge(0)-1) would input a representable
      ! negative value but result in a positive value out of range.
        write(*, *) 'abs range test : ', abs(huge(0)), abs(-huge(0))
        write(*, *) 'abs range test : ', abs(huge(0.0)), abs(-huge(0.0))
        write(*, *) 'abs range test : ', abs(tiny(0.0)), abs(-tiny(0.0))

      ! elemental
        write(*, *) 'abs is elemental: ', abs([20,  0,  -1,  -3,  100])

      ! complex input produces real output  
        write(*, *)  cmplx(30.0,40.0)

      ! the returned value for complex input can be thought of as the
      ! distance from the origin <0,0>
        write(*, *) 'distance of <XX,YY> from zero is', &
                   & distance(30.0_dp,40.0_dp)

        contains

        real(kind=dp) elemental function distance(x,y)
        real(kind=dp),intent(in) :: x,y
           ! dusty corners:
           ! note that KIND=DP is NOT optional
           ! if the desired result is KIND=dp.
           ! See cmplx(3).
           distance=abs( cmplx(x,y,kind=dp) )
        end function distance

    end program demo_abs

Results:

        integer          In: -1                     Out: 1
        real             In: -1.000000              Out: 1.000000
        doubleprecision  In: -45.78000000000000     Out: 45.78000000000000
        complex          In: (-3.000000,-4.000000)  Out: 5.000000
        abs range test :   2147483647  2147483647
        abs range test :   3.4028235E+38  3.4028235E+38
        abs range test :   1.1754944E-38  1.1754944E-38
        abs is elemental: 20 0 1 3 100
        (30.00000,40.00000)
        distance of <XX,YY> from zero is   50.0000000000000     

STANDARD

FORTRAN 77 and later

fortran-lang intrinsic descriptions (license: MIT) @urbanjost
