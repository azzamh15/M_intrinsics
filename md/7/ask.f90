While helping someone find a bug I found his problem was he thought
he was deallocating a target by deallocating a pointer to it, but when
questioned why there was no error generated by the DEALLOCATE statement
(which I incorrectly said was an illegal statement) I found it did
something else (not the indirect allocation he thought, though). But the
statement seemed slightly incorrect if I now understand what it does do.
So for 6.6.3.3 I have two questions (Q1 and Q2):

         6.6.3.3   Deallocation of pointer targets
     
      1 If a pointer appears in a DEALLOCATE statement, its association
        status shall be defined. Deallocating a pointer
        that is disassociated or whose target was not created by an
        ALLOCATE statement causes an error condition in the DEALLOCATE
        statement. If a pointer is associated with an allocatable entity,
        the pointer shall not be deallocated.
Q1:  > 
     >  should this say the "target shall not be deallocated" instead
     >  of the "pointer shall not be deallocated"??  I do not think of
     >  a pointer as being "allocated", I think of the target as being
     >  "allocated".
     
      2 If a pointer appears in a DEALLOCATE statement, it shall be
        associated with the whole of an object that was
        created by allocation. Deallocating a pointer target causes
        the pointer association status of any other pointer that
        is associated with the target or a portion of the target to
        become undefined.
Q2:  
     > Is this talking about DEALLOCATE(a_pointer) or
     > DEALLOCATE(a_target)? If talking about DEALLOCATE(a_pointer) like
     > the previous sentence if I understand 6.6.3.3.1 then the target
     > is not touched by the DEALLOCATE so why on earth would other
     > pointers to the target be undefined? When I tested it, no other
     > pointer was affected, but of course  the definition of "undefined"
     > is that the compiler is free to do that. This seems to imply the
     > DEALLOCATE below in the code is not exactly equivalent in this case
     > to NULLIFY(P1) because NULLIFY would not affect other pointers
     > such as P2 but I cannot fathom why it would behave differently
     > than a NULLIFY. Does not seem to make sense unless talking about
     > deallocating an allocatable instead of talking about deallocating
     > a pointer to an allocatable.

Seems like there should be two sections if one sentence is talking about
"deallocating a pointer to an allocated target" and the other is talking
about "deallocating a target that has pointers to it".

A code sample that tests (my one interpretation of) 6.6.3.3:

program wrong_array
implicit none
real, target, allocatable     :: big(:,:)
real, pointer, dimension(:,:) :: p1, p2
character(len=255)            :: message
integer                       :: istat
   allocate(big(600,700))
   p1 => big
   p2 => big
   message='NO ERROR'
   deallocate &
   (p1,stat=istat,errmsg=message)  ! NO: indirect deallocation is not allowed
                                   ! OOPS; this statement is not illegal
   ! Well, it does not DO indirect allocation, but the statement just
   ! does something else other than indirect deallocation. 
   write(*,*)'STAT=',istat,' MESSAGE=',trim(message)
   if(associated(p2))then 
      write(*,*)'P2: P2 is technically undefined? Try it'
      write(*,*)'SIZE=',size(p2),' LBOUND=',lbound(p2),' UBOUND=',ubound(p2)
   endif
   if(associated(p1))then
      write(*,*)'If P1 is associated, reading 6.6.3.3 wrong'
   endif
   if(allocated(big))then
      write(*,*)'BIG: NOTE NOT DEALLOCATED EVEN THOUGH P1 WAS POINTING TO IT AND P1 WAS DEALLOCATED'
      write(*,*)'SIZE=',size(p1),' LBOUND=',lbound(p1),' UBOUND=',ubound(p1)
   endif
end program wrong_array
