<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace}
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="index.html">[UP]</a></h5>
-->
<button type="button" onclick="javascript:history.back()">Back</button>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>ubound (3fortran)</NOBR><HR></H1>
</CENTER>
<BLOCKQUOTE>
the result has a value equal to the upper bound for subscript DIM of ARRAY. Otherwise, if DIM
is present and ARRAY is assumed-rank, the value of the result is as if ARRAY were a whole array,
with the extent of the ﬁnal dimension of ARRAY when ARRAY is associated with an assumed-size
array being considered to be −1. Otherwise, if DIM is present, the result has a value equal to the
number of elements in dimension DIM of ARRAY.
</BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>ubound (3fortran)</NOBR><HR></H1>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>Case (ii):</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
If ARRAY has rank zero, UBOUND (ARRAY) has a value that is a zero-sized array. Otherwise,
th
UBOUND(ARRAY)hasavaluewhosei elementisequaltoUBOUND(ARRAY,i),fori = 1, 2,
th
<TABLE width=100% cellpadding=3><!-- tsb: If ARRAY has rank zero, UBOUND (ARRAY) has a value that is a zero-sized array. Otherwise,
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>: : : ,</B> </TD><TD valign=bottom>
n, where n is the rank of ARRAY. UBOUND (ARRAY, KIND=KIND) has a value whose i
element is equal to UBOUND (ARRAY, i, KIND=KIND), for i = 1, 2, :::, n, where n is the
rank of ARRAY.
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
Examples. If A is declared by the statement REAL A (2:3, 7:10) then
UBOUND (A) is [3, 10] and UBOUND (A, DIM = 2) is 10. NOTE1 If
ARRAYisassumed-rankandhasrankzero,DIMcannotbepresentsinceitcannotsatisfytherequirement
1 ≤ DIM ≤ 0.
</TD></TR>
<TR><TD colspan=2>
<P>
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
ubound
</TD></TR>
<TR></TR></TABLE><A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<P>
UBOUND(3) - [ARRAY:INQUIRY] Upper dimension bounds of an array
<P>
</BLOCKQUOTE>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
result = ubound(array [,dim] [,kind] )
<P>
<PRE>
         elemental TYPE(kind=KIND) function ubound(array,dim,kind)
<P>
          TYPE(kind=KIND),intent(in)  :: array
          integer(kind=**),intent(in),optional :: dim
          integer(kind=**),intent(in),optional :: kind
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>CHARACTERISTICS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
a kind designated as ** may be any supported kind for the type
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
ARRAY shall be assumed-rank or an array, of any type. It cannot be
an unallocated allocatable array or a pointer that is not
associated.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
DIM shall be a scalar integer.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND an integer initialization expression indicating the kind
parameter of the result.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The return value is of type integer and of kind KIND. If KIND is
absent, the return value is of default integer kind.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<P>
UBOUND(3) returns the upper bounds of an array, or a single upper bound
along the DIM dimension.
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
ARRAY : The assumed-rank or array of any type whose upper bounds are
to be determined. If allocatable it must be allocated; if a pointer
it must be associated. If an assumed-size array, DIM must be
present.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
DIM : a specific dimension of ARRAY to determine the bounds of. If
DIM is absent, the result is an array of the upper bounds of ARRAY.
DIM is required if ARRAY is an assumed-size array, and in that case
must be less than or equal to the rank of ARRAY.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND : indicates the kind parameter of the result. If absent, an
integer of the default kind is returned.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>RESULT</H3>

</A>
<BLOCKQUOTE>
<P>
The return value is of type integer and of kind KIND. If KIND is absent,
the return value is of default integer kind.
<P>
If DIM is absent, the result is an array of the upper bounds of each
dimension of the ARRAY.
<P>
If DIM is present, the result is a scalar corresponding to the upper
bound of the array along that dimension.
<P>
If ARRAY is an expression rather than a whole array or array structure
component, or if it has a zero extent along the relevant dimension, the
upper bound is taken to be the number of elements along the relevant
dimension.
</BLOCKQUOTE>
<A name=6>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Note this function should not be used on assumed-size arrays or in any
function without an explicit interface. Errors can occur if there is no
interface defined.
<P>
Sample program
<P>
<PRE>
    ! program demo_ubound
    module m2_bounds
    implicit none
<P>
    contains
<P>
    subroutine msub(arr)
    !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array
    integer,intent(in) :: arr(:)
       write(*,*)&#146;MSUB: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
    end subroutine msub
<P>
    end module m2_bounds
    !
    program demo_ubound
    use m2_bounds, only : msub
    implicit none
    interface
       subroutine esub(arr)
       integer,intent(in) :: arr(:)
       end subroutine esub
    end interface
    integer :: arr(-10:10)
       write(*,*)&#146;MAIN: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
       call csub()
       call msub(arr)
       call esub(arr)
    contains
    subroutine csub
       write(*,*)&#146;CSUB: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
    end subroutine csub
<P>
    end
<P>
    subroutine esub(arr)
    implicit none
    integer,intent(in) :: arr(:)
       ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE
       ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)
       write(*,*)&#146;ESUB: LOWER=&#146;,lbound(arr),&#146;UPPER=&#146;,ubound(arr), &
       & &#146;SIZE=&#146;,size(arr)
    end subroutine esub
    !end program demo_ubound
<P>
</PRE>
Results:
<P>
<PRE>
     &gt;  MAIN: LOWER=         -10 UPPER=          10 SIZE=          21
     &gt;  CSUB: LOWER=         -10 UPPER=          10 SIZE=          21
     &gt;  MSUB: LOWER=           1 UPPER=          21 SIZE=          21
     &gt;  ESUB: LOWER=           1 UPPER=          21 SIZE=          21
<P>
</PRE>
</BLOCKQUOTE>
<A name=7>

     <H3>STANDARD</H3>

</A>
<BLOCKQUOTE>
<P>
Fortran 95 , with KIND argument Fortran 2003
</BLOCKQUOTE>
<A name=8>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<P>
Array inquiry:
<TABLE cellpadding=3><!-- tsb: Array inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SIZE(3) - Determine the size of an array
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
RANK(3) - Rank of a data object
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SHAPE(3) - Determine the shape of an array
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
UBOUND(3) - Upper dimension bounds of an array
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
LBOUND(3) - Lower dimension bounds of an array
</TD></TR>
<TR></TR></TABLE>CO_UBOUND(3), [CO_LBOUND(3)(co_lbound)]
<P>
State Inquiry:
<TABLE cellpadding=3><!-- tsb: State Inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
ALLOCATED(3) - Status of an allocatable entity
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
IS_CONTIGUOUS(3) - Test if object is contiguous
</TD></TR>
<TR></TR></TABLE>Kind Inquiry:
<TABLE cellpadding=3><!-- tsb: Kind Inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
KIND(3) - Kind of an entity
</TD></TR>
<TR></TR></TABLE>Bit Inquiry:
<TABLE cellpadding=3><!-- tsb: Bit Inquiry:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
STORAGE_SIZE(3) - Storage size in bits
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
BIT_SIZE(3) - Bit size inquiry function
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
BTEST(3) - Tests a bit of an integer value.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
LBOUND(3),
</TD></TR>
<TR></TR></TABLE>fortran-lang intrinsic descriptions (license: MIT) @urbanjost
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I>Nemo Release 3.1</I></TD> <TD width=33% align=center>ubound (3fortran)</TD> <TD align=right width=33%><I>October 21, 2022</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from b7e6819c-2e45-4fcd-b86d-2cf0587e2b84 using man macros.</FONT>
<br><br><center><img src="images/ubound.3fortran.gif"></center>
</div>
</div>
</body>
</HTML>
